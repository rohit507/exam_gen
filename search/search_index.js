const local_index = {"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"exam_gen : Automatic, personalized assignment generation and grading. \u00b6 exam_gen is a library that allows people to create personalized exams unique to each student in a class. Documentation Sections \u00b6 Tutorial : A detailed walkthrough of how to build a simple exam with this library. Quick Reference : Links to different sections of this documentation organized by task.","title":"Home"},{"location":"index.html#exam_gen-automatic-personalized-assignment-generation-and-grading","text":"exam_gen is a library that allows people to create personalized exams unique to each student in a class.","title":"exam_gen : Automatic, personalized assignment generation and grading."},{"location":"index.html#documentation-sections","text":"Tutorial : A detailed walkthrough of how to build a simple exam with this library. Quick Reference : Links to different sections of this documentation organized by task.","title":"Documentation Sections"},{"location":"quick_reference.html","text":"Quick Reference \u00b6 Core \u00b6 What does the basic structure of an exam/assignment with this library? overview project as a whole in u_g/proj_setup overview of root exam obj specifially in u_g/exams Assignment Creation \u00b6 How do I set up my development environment? FIX LINK : (In the tutorial)[tutorial.html#setting-up-your-development-environment] in u_g/proj_setup How do I set up a new assignment project? FIX LINK : (In the tutorial)[tutorial.html#setting-up-the-project] add link: u_g/proj_setup How do I add a classroom to a project? FIX LINK : (In the tutorial)[tutorial.html#adding-a-classroom-and-roster-to-the-project] How do I add a roster to a project? FIX LINK : (In the tutorial)[tutorial.html#adding-a-classroom-and-roster-to-the-project] How do I associate student answers with exam problems? tut/answer for basic csv input How do I dump student grades? tut/answer for basic csv dump How do I set the body text of a question? Add link: minimal inline version in tutorial/writing_questions minimal external file in tut/proj_org How do I set the solution text for a question? Add link: minimal inline version in tutorial/writing_questions add link: More complex version in tut/adv_temp minimal external file in tut/proj_org What is the API for the rng provided to user_setup ? Add Link: python docs \"Random.Random\" How do I format templates? add Link: Jinja doccs lw1 add link: minimal notes in tut/cust_and_rand add link: info on loops and whitespace in tut/adv_temp What variables are available to the templates I use? add link: minimal notes in tut/cust_and_rand How do I pass new variables to my templates? add link: minimal notes via user_setup in tut/cust_and_rand How do I use latex libraries? add link tut/multi-choice/simple How do I add packages or modify the LaTeX header? see tule/mult_choi/simple to do so at the question or exam level LaTeX is giving me an error, how can I figure out where it's coming from? How do I override templates for embedding a question? add link tut/multi-choice/custom basic example How do I nest questions or add sub-questions? add link tut/multi-part How do I share information between questions and sub-questions? or an exam and its questions? add line tut/multipart Can I organize questions and sub-questions in sub-directories of the main assignment? yes, see tut/proj_org Can I split questions and sub-question into multiple files? yes, see tut/proj_org How do I use external files in my assignment? see tut/ext_assets How do i make multiple choice questions? see tule/mult_choi How do I set the choies in the multiple choice question? see tule/mult_choi/simple if they're all based on the same template see tut/mult_choi/choices to set them separately see tut/mult_choi/custom to set them within user_setup How can i shuffle the choices in a multiple choice queston? see tule/mult_choi/simple for basic yes-no see tut/mult_choi/choices for complex shuffle How can I refer to one multiple choice answer in another? see tut/mult_choi/choices for how to do so even with shuffling. How do I specify the grading scheme for a multiple choice question? see tule/mult_choi/simple for one option (percent correct) see tut/mult_choi/choices for all-or-nothing see tut/mult_choi/custom for an example of a custom grading function. Build Process \u00b6 How do I build an exam for a single student? add link: somewhere in tutorial for minimal version How can I change the settings for a single student? How do I build exams in bulk? add link: somewhere in tutorial for minimal version How do I build solution keys? add link: somewhere in tutorial for minimal version Build Debugging \u00b6 How can I test roster parsing? FIX LINK : (Testing via list )[tutorial.html#available-build-actions] FIX LINK : (Testing via parse-roster )[tutorial.html#testing-roster-parsing] How can I see what information is associated with a student? FIX LINK : (Testing via parse-roster )[tutorial.html#testing-roster-parsing] How can I add new template variables? What do the various logging and debug files in ~data mean? add link: For template rendering see tut/cust_and_rand Development Tasks \u00b6 How do I create a new roster parser? ADD LINK : should eventually be in dev_guide/adding_components/roster_parsers.md Useful External Links \u00b6 Python's Raw String Format Jinja2 Template Format Documentation Jinja2 and LaTeX quirks: spaces to separate latex braces { { so we can use jinja braces {{ be careful about escape codes, you usually don't want Example Index \u00b6","title":"Quick Reference"},{"location":"quick_reference.html#quick-reference","text":"","title":"Quick Reference"},{"location":"quick_reference.html#core","text":"What does the basic structure of an exam/assignment with this library? overview project as a whole in u_g/proj_setup overview of root exam obj specifially in u_g/exams","title":"Core"},{"location":"quick_reference.html#assignment-creation","text":"How do I set up my development environment? FIX LINK : (In the tutorial)[tutorial.html#setting-up-your-development-environment] in u_g/proj_setup How do I set up a new assignment project? FIX LINK : (In the tutorial)[tutorial.html#setting-up-the-project] add link: u_g/proj_setup How do I add a classroom to a project? FIX LINK : (In the tutorial)[tutorial.html#adding-a-classroom-and-roster-to-the-project] How do I add a roster to a project? FIX LINK : (In the tutorial)[tutorial.html#adding-a-classroom-and-roster-to-the-project] How do I associate student answers with exam problems? tut/answer for basic csv input How do I dump student grades? tut/answer for basic csv dump How do I set the body text of a question? Add link: minimal inline version in tutorial/writing_questions minimal external file in tut/proj_org How do I set the solution text for a question? Add link: minimal inline version in tutorial/writing_questions add link: More complex version in tut/adv_temp minimal external file in tut/proj_org What is the API for the rng provided to user_setup ? Add Link: python docs \"Random.Random\" How do I format templates? add Link: Jinja doccs lw1 add link: minimal notes in tut/cust_and_rand add link: info on loops and whitespace in tut/adv_temp What variables are available to the templates I use? add link: minimal notes in tut/cust_and_rand How do I pass new variables to my templates? add link: minimal notes via user_setup in tut/cust_and_rand How do I use latex libraries? add link tut/multi-choice/simple How do I add packages or modify the LaTeX header? see tule/mult_choi/simple to do so at the question or exam level LaTeX is giving me an error, how can I figure out where it's coming from? How do I override templates for embedding a question? add link tut/multi-choice/custom basic example How do I nest questions or add sub-questions? add link tut/multi-part How do I share information between questions and sub-questions? or an exam and its questions? add line tut/multipart Can I organize questions and sub-questions in sub-directories of the main assignment? yes, see tut/proj_org Can I split questions and sub-question into multiple files? yes, see tut/proj_org How do I use external files in my assignment? see tut/ext_assets How do i make multiple choice questions? see tule/mult_choi How do I set the choies in the multiple choice question? see tule/mult_choi/simple if they're all based on the same template see tut/mult_choi/choices to set them separately see tut/mult_choi/custom to set them within user_setup How can i shuffle the choices in a multiple choice queston? see tule/mult_choi/simple for basic yes-no see tut/mult_choi/choices for complex shuffle How can I refer to one multiple choice answer in another? see tut/mult_choi/choices for how to do so even with shuffling. How do I specify the grading scheme for a multiple choice question? see tule/mult_choi/simple for one option (percent correct) see tut/mult_choi/choices for all-or-nothing see tut/mult_choi/custom for an example of a custom grading function.","title":"Assignment Creation"},{"location":"quick_reference.html#build-process","text":"How do I build an exam for a single student? add link: somewhere in tutorial for minimal version How can I change the settings for a single student? How do I build exams in bulk? add link: somewhere in tutorial for minimal version How do I build solution keys? add link: somewhere in tutorial for minimal version","title":"Build Process"},{"location":"quick_reference.html#build-debugging","text":"How can I test roster parsing? FIX LINK : (Testing via list )[tutorial.html#available-build-actions] FIX LINK : (Testing via parse-roster )[tutorial.html#testing-roster-parsing] How can I see what information is associated with a student? FIX LINK : (Testing via parse-roster )[tutorial.html#testing-roster-parsing] How can I add new template variables? What do the various logging and debug files in ~data mean? add link: For template rendering see tut/cust_and_rand","title":"Build Debugging"},{"location":"quick_reference.html#development-tasks","text":"How do I create a new roster parser? ADD LINK : should eventually be in dev_guide/adding_components/roster_parsers.md","title":"Development Tasks"},{"location":"quick_reference.html#useful-external-links","text":"Python's Raw String Format Jinja2 Template Format Documentation Jinja2 and LaTeX quirks: spaces to separate latex braces { { so we can use jinja braces {{ be careful about escape codes, you usually don't want","title":"Useful External Links"},{"location":"quick_reference.html#example-index","text":"","title":"Example Index"},{"location":"tutorial.html","text":"Your First Assignment \u00b6 We'll be walking through the creation of a simple randomized assignment with some multiple-choice questions, as well as importing student answers and assigning grades. Setting up Your Development Environment \u00b6 There are two main requirements to run exam_gen : LaTeX and pipenv . Set each up on your machine as appropriate. TeX Live : Is needed to actually build the exams. Installing the full version (usually texlive-full ) is recommended. Ubuntu: sudo apt install texlive-full Other Linux: Check your distro's package manager or see here . Mac: MacTeX or install via homebrew. Windows: Follow the instructions here Pipenv : Hides a lot of python packing and dependency issues by creating a nice stable wrapper environment for our work. Installation instructions are here . With both of those ready to go, we can move on to making an assignment. Windows Users From here on out we'll be tailoring our instructions to unix-like systems. Windows users might need to edit the commands provided to make things work, but the library itself should be OS independent. Setting up the Project \u00b6 We'll create a new project directory called new_exam and move into it with: $ mkdir new_exam $ cd new_exam This would also be a good time to set up version control (with git init or similar). Then we can add the exam_gen library to our project using pipenv: $ pipenv install <repo_url> Right now <repo_url> would be https://github.com/rohit507/exam_gen.git but the project should probably be somewhere different soon. Once it's moved, that link should be directly embedded above. Finally we need to create exam.py , which is the most important file in any new project. We'll start by just creating a new file and making it executable. $ touch exam.py $ chmod +x exam.py exam.py will contain a full description of our assignment. We'll describe how to create it in the next section. Creating an Initial exam.py \u00b6 Open the editor of your choice and paste the following into exam.py : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/usr/bin/env -S pipenv run python3 from exam_gen import * class NewExam ( LatexDoc , Exam ): classes = {} questions = {} intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) Once you save, this constitutes a minimal description of an assignment. One with no content and a tiny snippet of text as an introduction. Line-by-Line Breakdown of exam.py 3 from exam_gen import * Importing our library. Simple enough, we can't get anything else done without this. 5 class NewExam ( LatexDoc , Exam ): Then we initialize our new assignment as a python class. This library uses classes to represents assignments (i.e. Exam ) and questions within those assignments. Individual versions of those assignments (which are student specific) will be objects initialized from these classes. It's also worth noting what classes NewExam inherits from. LatexDoc tells our backend that we're working in LaTeX and describes how to build new .pdf files from the text that's generated. Exam , on the other hand, describes various elements of the structure of an assignment which we'll go over later. 7 classes = {} The Exam class pulls double duty in this system. It acts as the definition of a single exam's contents, but it also captures some grading and student-roster management info. Most of that roster-management is delegated to Classrooms , which we'll look at in more detail soon, but we need to store the set of classrooms we are going to use somewhere. For now we leave this list empty. 9 questions = {} Each exam has to have some list of questions. It's empty for now, but we'll be adding to it later. 11 12 13 intro . text = r ''' \\emph{Example Exam Introduction} ''' The biggest content element of an Exam is the introduction, which tends to have the rules, instructions, honor-code, etc.. This is how we specify what text should appear in that intro. Note how we're using the r''' ... ''' string notation. This allows for multi-line strings where '\\' and other special characters don't need to be escaped. Given how TeX has a truly painful number of stupid syntax quirks this is very useful. 15 16 def user_setup ( self , ** kwargs ): pass This function can be filled in later to provide customization to each version of the exam. For now we leave it empty. 18 if __name__ == \"__main__\" : run_cli ( globals ()) This is an archaic python incantation. In short, one should read if __name__ == \"__main__\" : as \"Do this if we're running this file as a script\". Likewise globals () is a function that returns all the variables in scope where it was called, including classes like NewExam . run_cli () then searches through that list for a subclass of Exam to build assignments with. 1 #!/usr/bin/env -S pipenv run python3 This is a unix hashbang, when an executable text file is run and starts with #!some_command then the file's contents will be passed to some_command as an argument. Since we use pipenv for build isolation this will automatically wrap any invocation of ./exam.py with the appropriate environment. All together, this just lets us call exam_gen 's command line interface when we run the file as a script. Along with the chmod +x exam.py from earlier, this lets us run ./exam.py <arguments> instead of having to manually call pipenv and python. We can quickly test our setup by running ./exam.py in our terminal. You should see a result like this: exam_gen build tool Available Commands: <cmd_name> list List major available build actions. <cmd_name> list --all List all available build actions. Replace <cmd_name> with however you invoke this tool. (usually `./exam.py`,`pipenv run ./exam.py`,or `pipenv run python3 exam.py`) We can also take a look at the various possible build commands available to us by following the above instructions. (e.g. running ./exam.py list --all ) Which should produce a result like: build-exam Build all the exams for each student. build-solution Build all the answer keys for each student. cleanup Clean all generated files. (e.g. 'rm -rf ~*') parse-roster parse the class rosters (incl. answer and score data if available) None of those command do anything right now as they all depend on having a roster of students available to parse and build exams for. So let's add that on the next page.","title":"Your First Assignment"},{"location":"tutorial.html#your-first-assignment","text":"We'll be walking through the creation of a simple randomized assignment with some multiple-choice questions, as well as importing student answers and assigning grades.","title":"Your First Assignment"},{"location":"tutorial.html#setting-up-your-development-environment","text":"There are two main requirements to run exam_gen : LaTeX and pipenv . Set each up on your machine as appropriate. TeX Live : Is needed to actually build the exams. Installing the full version (usually texlive-full ) is recommended. Ubuntu: sudo apt install texlive-full Other Linux: Check your distro's package manager or see here . Mac: MacTeX or install via homebrew. Windows: Follow the instructions here Pipenv : Hides a lot of python packing and dependency issues by creating a nice stable wrapper environment for our work. Installation instructions are here . With both of those ready to go, we can move on to making an assignment. Windows Users From here on out we'll be tailoring our instructions to unix-like systems. Windows users might need to edit the commands provided to make things work, but the library itself should be OS independent.","title":"Setting up Your Development Environment"},{"location":"tutorial.html#setting-up-the-project","text":"We'll create a new project directory called new_exam and move into it with: $ mkdir new_exam $ cd new_exam This would also be a good time to set up version control (with git init or similar). Then we can add the exam_gen library to our project using pipenv: $ pipenv install <repo_url> Right now <repo_url> would be https://github.com/rohit507/exam_gen.git but the project should probably be somewhere different soon. Once it's moved, that link should be directly embedded above. Finally we need to create exam.py , which is the most important file in any new project. We'll start by just creating a new file and making it executable. $ touch exam.py $ chmod +x exam.py exam.py will contain a full description of our assignment. We'll describe how to create it in the next section.","title":"Setting up the Project"},{"location":"tutorial.html#creating-an-initial-exampy","text":"Open the editor of your choice and paste the following into exam.py : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/usr/bin/env -S pipenv run python3 from exam_gen import * class NewExam ( LatexDoc , Exam ): classes = {} questions = {} intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) Once you save, this constitutes a minimal description of an assignment. One with no content and a tiny snippet of text as an introduction. Line-by-Line Breakdown of exam.py 3 from exam_gen import * Importing our library. Simple enough, we can't get anything else done without this. 5 class NewExam ( LatexDoc , Exam ): Then we initialize our new assignment as a python class. This library uses classes to represents assignments (i.e. Exam ) and questions within those assignments. Individual versions of those assignments (which are student specific) will be objects initialized from these classes. It's also worth noting what classes NewExam inherits from. LatexDoc tells our backend that we're working in LaTeX and describes how to build new .pdf files from the text that's generated. Exam , on the other hand, describes various elements of the structure of an assignment which we'll go over later. 7 classes = {} The Exam class pulls double duty in this system. It acts as the definition of a single exam's contents, but it also captures some grading and student-roster management info. Most of that roster-management is delegated to Classrooms , which we'll look at in more detail soon, but we need to store the set of classrooms we are going to use somewhere. For now we leave this list empty. 9 questions = {} Each exam has to have some list of questions. It's empty for now, but we'll be adding to it later. 11 12 13 intro . text = r ''' \\emph{Example Exam Introduction} ''' The biggest content element of an Exam is the introduction, which tends to have the rules, instructions, honor-code, etc.. This is how we specify what text should appear in that intro. Note how we're using the r''' ... ''' string notation. This allows for multi-line strings where '\\' and other special characters don't need to be escaped. Given how TeX has a truly painful number of stupid syntax quirks this is very useful. 15 16 def user_setup ( self , ** kwargs ): pass This function can be filled in later to provide customization to each version of the exam. For now we leave it empty. 18 if __name__ == \"__main__\" : run_cli ( globals ()) This is an archaic python incantation. In short, one should read if __name__ == \"__main__\" : as \"Do this if we're running this file as a script\". Likewise globals () is a function that returns all the variables in scope where it was called, including classes like NewExam . run_cli () then searches through that list for a subclass of Exam to build assignments with. 1 #!/usr/bin/env -S pipenv run python3 This is a unix hashbang, when an executable text file is run and starts with #!some_command then the file's contents will be passed to some_command as an argument. Since we use pipenv for build isolation this will automatically wrap any invocation of ./exam.py with the appropriate environment. All together, this just lets us call exam_gen 's command line interface when we run the file as a script. Along with the chmod +x exam.py from earlier, this lets us run ./exam.py <arguments> instead of having to manually call pipenv and python. We can quickly test our setup by running ./exam.py in our terminal. You should see a result like this: exam_gen build tool Available Commands: <cmd_name> list List major available build actions. <cmd_name> list --all List all available build actions. Replace <cmd_name> with however you invoke this tool. (usually `./exam.py`,`pipenv run ./exam.py`,or `pipenv run python3 exam.py`) We can also take a look at the various possible build commands available to us by following the above instructions. (e.g. running ./exam.py list --all ) Which should produce a result like: build-exam Build all the exams for each student. build-solution Build all the answer keys for each student. cleanup Clean all generated files. (e.g. 'rm -rf ~*') parse-roster parse the class rosters (incl. answer and score data if available) None of those command do anything right now as they all depend on having a roster of students available to parse and build exams for. So let's add that on the next page.","title":"Creating an Initial exam.py"},{"location":"api/exam.html","text":"exam_gen.exam : Parent Class for User-Defined Exams \u00b6 base \u00b6 Exam \u00b6 Base class for all concrete exams, should be overridden when defining a new exam. metadata property writable \u00b6 Metadata used as part of rendering or annotating output. Metadata Fields Value Name Description Default metadata . assignment The name of the assignment. Can be changed in user_setup . 'Example Assignment' metadata . course The name of the course as it should appear in the corresponding template fields. Can be changed in user_setup . 'TEST 101' metadata . date The date of the exam. Can be changed in user_setup . '12-12-2012' metadata . semester The date of the exam. Can be changed in user_setup . 'Fall xx' metadata . teacher The name(s) of the instructors Can be changed in user_setup . 'J. Doe \\\\ & B. Smith' questions inherited \u00b6 settings property writable \u00b6 Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . assets A list of static files that should be copied into the directory where we're going build each exam. Glob patterns (e.g. assets/*.png or **/test.txt ) Note This will copy files relative to the class where it's set. If you have: An Exam in proj_dir/midterm.py asking for assets/foo.txt And Question in prod_dir/q1/timer.py asking for bar.png and assets/bar.txt Then you'll get: proj_dir/assets/foo.txt copied into build_dir/assets/foo.txt proj_dir/q1/assets/bar.txt copied into build_dir/assets/bar.txt proj_dir/q1/bar.png copied into build_dir/bar.png There is no guaranteed behavior if this would result in some file being clobbered. [] settings . build Various settings that control how exams and questions are built. settings . numbering_scheme The scheme for numbering child questions in the exam or document. Each char in the string represents a sequence to use for each sub-level of the document. 1 : Sequence of integers 1 , 2 , 3 , and so on. a : Sequence of lower-case letters in excel column order. a , b , c , ... , aa , ab , ac , etc.. A : as above but upper-case. Additionally . is a special character that tells when a period should be inserted as a separator. Also the sequence will repeat the For instance the default scheme 1a. would give us a tree like: - 1 - 2 - 2a - 2b - 2b.1 - 3 - 3a - 3a.1 - 3a.1a - 3a.1a.1 Note that this setting won't register any changes in user_setup '1a.' settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. 'exam_standalone.jn2' settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None use_class_root inherited \u00b6 Ensure that we're using the class file location as root of the search path __init__ ( self , student , classroom , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , parent_doc = None , template_manager = None , depth = 0 , numbering_depth = None , number = '' , root_seed = None , parent_context = NOTHING ) inherited special \u00b6 Source code in exam_gen/exam/base.py def __init__ ( self , student , classroom , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default , depth = attr_dict [ '_depth' ] . default , numbering_depth = attr_dict [ '_numbering_depth' ] . default , number = attr_dict [ '_number' ] . default , root_seed = attr_dict [ 'root_seed' ] . default , parent_context = NOTHING ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . _depth = depth self . _numbering_depth = numbering_depth self . _number = number self . student = student self . classroom = classroom self . root_seed = root_seed self . _rng_source = attr_dict [ '_rng_source' ] . default if parent_context is not NOTHING : self . parent_context = parent_context else : self . parent_context = __attr_factory_parent_context () self . result_context = attr_dict [ 'result_context' ] . default self . final_context = attr_dict [ 'final_context' ] . default self . classes = __attr_factory_classes () self . __attrs_post_init__ () build_template_spec ( self , build_info = None ) inherited \u00b6 build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/exam/base.py def build_template_spec ( self , build_info = None ): spec = super () . build_template_spec ( build_info ) spec . subtemplates [ 'intro' ] = template_spec_from_var ( self . intro , versions = [ build_info . exam_format ]) return spec cleanup_build ( self , build_info ) inherited \u00b6 Generic cleanup task for a build. Default: deletes the build directory Source code in exam_gen/exam/base.py def cleanup_build ( self , build_info ): \"\"\" Generic cleanup task for a build. Default: deletes the build directory \"\"\" shutil . rmtree ( build_dir ) ctxt ( self ) inherited \u00b6 A dictionary of values returned by the user_setup functions of any parent documents. Source code in exam_gen/exam/base.py @setup_arg def ctxt ( self ) -> dict : \"\"\" A dictionary of values returned by the `user_setup` functions of any parent documents. \"\"\" return deepcopy ( self . parent_context ) finalize_build ( self , build_info ) inherited \u00b6 To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: Type Description (log, success) Source code in exam_gen/exam/base.py def finalize_build ( self , build_info ): \"\"\" To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: (log, success) \"\"\" pass get_keyed_rng ( self , * keys ) inherited \u00b6 Source code in exam_gen/exam/base.py def get_keyed_rng ( self , * keys ): if self . root_seed == None : self . root_seed = self . init_root_seed () return Random ( stable_hash ( self . root_seed , * keys )) init_document ( self , doc_class , ** kwargs ) inherited \u00b6 Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/exam/base.py def init_document ( self , doc_class , ** kwargs ): return super ( PersonalDoc , self ) . init_document ( doc_class , student = self . student , classroom = self . classroom , ** kwargs ) init_questions ( self ) inherited \u00b6 Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/exam/base.py def init_questions ( self ): super ( Numbered , self ) . init_questions () if self . _parent_doc == None : self . push_numbering () init_root_seed ( self ) inherited \u00b6 Source code in exam_gen/exam/base.py def init_root_seed ( self ): from exam_gen.property.personalized import Personalized if isinstance ( self , Personalized ): return self . student . root_seed raise RuntimeError ( \"No method to get root seed\" ) lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/exam/base.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) on_children ( self , fun ) inherited \u00b6 Source code in exam_gen/exam/base.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log output_build ( self , build_info ) inherited \u00b6 Copies the files from the build directory to the output directory Options to rename them should be in build_settings. Source code in exam_gen/exam/base.py def output_build ( self , build_info ): \"\"\" Copies the files from the build directory to the output directory Options to rename them should be in build_settings. \"\"\" pass push_numbering ( self ) inherited \u00b6 Source code in exam_gen/exam/base.py def push_numbering ( self ): if self . _numbering_depth == None or self . _numbering_depth == \"\" : self . _numbering_depth = self . settings . numbering_scheme for ( ind , ( name , question )) in enumerate ( self . questions . items ()): self . questions [ name ] . settings . numbering_scheme = ( self . settings . numbering_scheme ) self . questions [ name ] . _numbering_depth = self . _numbering_depth [ 1 :] self . questions [ name ] . _depth = self . _depth + 1 self . questions [ name ] . _number = self . _get_subq_number ( ind ) self . questions [ name ] . push_numbering () rng ( self ) inherited \u00b6 A repeatable random number generator that will always produce the same sequence of outputs for any given student, exam pair. Source code in exam_gen/exam/base.py @setup_arg def rng ( self ) -> Random : \"\"\" A repeatable random number generator that will always produce the same sequence of outputs for any given student, exam pair. \"\"\" return self . get_keyed_rng ( 'user_setup' ) root_document ( self ) inherited \u00b6 Source code in exam_gen/exam/base.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self setup_build ( self , build_info ) inherited \u00b6 Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. Source code in exam_gen/exam/base.py def setup_build ( self , build_info ): log = super ( HasRNG , self ) . setup_build ( build_info ) if self . root_seed == None : self . root_seed = self . init_root_seed () for ( name , memb ) in self . questions . items (): memb . root_seed = stable_hash ( self . root_seed , name ) log [ 'root_seed' ] = self . root_seed return log template_spec ( self , out_file = None , build_info = None ) inherited \u00b6 Source code in exam_gen/exam/base.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec user_setup ( self , ctxt , rng ) \u00b6 Override this function in your code, otherwise it won't customize stuff. Todo We need a nicer output format here, but this will do for the moment. Function Signature: py <Signature (self, ctxt: dict, rng: random.Random)> Arg Metadata: { 'ctxt' : { 'arg' : 'ctxt' , 'doc' : 'A dictionary of values returned by the `user_setup` ' 'functions of \\n ' 'any parent documents.' , 'fun' : < function HasContext . ctxt at 0x7fdee2f8e4c0 > , 'typ' : < class ' dict '>}, 'rng' : { 'arg' : 'rng' , 'doc' : 'A repeatable random number generator that will always produce ' 'the same \\n ' 'sequence of outputs for any given student, exam pair.' , 'fun' : < function HasRNG . rng at 0x7fdee2fa3940 > , 'typ' : < class ' random . Random '>}}","title":"exam_gen.exam"},{"location":"api/exam.html#exam_genexam-parent-class-for-user-defined-exams","text":"","title":"exam_gen.exam: Parent Class for User-Defined Exams"},{"location":"api/exam.html#exam_gen.exam.base","text":"","title":"base"},{"location":"api/exam.html#exam_gen.exam.base.Exam","text":"Base class for all concrete exams, should be overridden when defining a new exam.","title":"Exam"},{"location":"api/exam.html#exam_gen.exam.base.Exam.metadata","text":"Metadata used as part of rendering or annotating output. Metadata Fields Value Name Description Default metadata . assignment The name of the assignment. Can be changed in user_setup . 'Example Assignment' metadata . course The name of the course as it should appear in the corresponding template fields. Can be changed in user_setup . 'TEST 101' metadata . date The date of the exam. Can be changed in user_setup . '12-12-2012' metadata . semester The date of the exam. Can be changed in user_setup . 'Fall xx' metadata . teacher The name(s) of the instructors Can be changed in user_setup . 'J. Doe \\\\ & B. Smith'","title":"metadata"},{"location":"api/exam.html#exam_gen.exam.base.Exam.questions","text":"","title":"questions"},{"location":"api/exam.html#exam_gen.exam.base.Exam.settings","text":"Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . assets A list of static files that should be copied into the directory where we're going build each exam. Glob patterns (e.g. assets/*.png or **/test.txt ) Note This will copy files relative to the class where it's set. If you have: An Exam in proj_dir/midterm.py asking for assets/foo.txt And Question in prod_dir/q1/timer.py asking for bar.png and assets/bar.txt Then you'll get: proj_dir/assets/foo.txt copied into build_dir/assets/foo.txt proj_dir/q1/assets/bar.txt copied into build_dir/assets/bar.txt proj_dir/q1/bar.png copied into build_dir/bar.png There is no guaranteed behavior if this would result in some file being clobbered. [] settings . build Various settings that control how exams and questions are built. settings . numbering_scheme The scheme for numbering child questions in the exam or document. Each char in the string represents a sequence to use for each sub-level of the document. 1 : Sequence of integers 1 , 2 , 3 , and so on. a : Sequence of lower-case letters in excel column order. a , b , c , ... , aa , ab , ac , etc.. A : as above but upper-case. Additionally . is a special character that tells when a period should be inserted as a separator. Also the sequence will repeat the For instance the default scheme 1a. would give us a tree like: - 1 - 2 - 2a - 2b - 2b.1 - 3 - 3a - 3a.1 - 3a.1a - 3a.1a.1 Note that this setting won't register any changes in user_setup '1a.' settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. 'exam_standalone.jn2' settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None","title":"settings"},{"location":"api/exam.html#exam_gen.exam.base.Exam.use_class_root","text":"Ensure that we're using the class file location as root of the search path","title":"use_class_root"},{"location":"api/exam.html#exam_gen.exam.base.Exam.__init__","text":"Source code in exam_gen/exam/base.py def __init__ ( self , student , classroom , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default , depth = attr_dict [ '_depth' ] . default , numbering_depth = attr_dict [ '_numbering_depth' ] . default , number = attr_dict [ '_number' ] . default , root_seed = attr_dict [ 'root_seed' ] . default , parent_context = NOTHING ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . _depth = depth self . _numbering_depth = numbering_depth self . _number = number self . student = student self . classroom = classroom self . root_seed = root_seed self . _rng_source = attr_dict [ '_rng_source' ] . default if parent_context is not NOTHING : self . parent_context = parent_context else : self . parent_context = __attr_factory_parent_context () self . result_context = attr_dict [ 'result_context' ] . default self . final_context = attr_dict [ 'final_context' ] . default self . classes = __attr_factory_classes () self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.build_template_spec","text":"build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/exam/base.py def build_template_spec ( self , build_info = None ): spec = super () . build_template_spec ( build_info ) spec . subtemplates [ 'intro' ] = template_spec_from_var ( self . intro , versions = [ build_info . exam_format ]) return spec","title":"build_template_spec()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.cleanup_build","text":"Generic cleanup task for a build. Default: deletes the build directory Source code in exam_gen/exam/base.py def cleanup_build ( self , build_info ): \"\"\" Generic cleanup task for a build. Default: deletes the build directory \"\"\" shutil . rmtree ( build_dir )","title":"cleanup_build()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.ctxt","text":"A dictionary of values returned by the user_setup functions of any parent documents. Source code in exam_gen/exam/base.py @setup_arg def ctxt ( self ) -> dict : \"\"\" A dictionary of values returned by the `user_setup` functions of any parent documents. \"\"\" return deepcopy ( self . parent_context )","title":"ctxt()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.finalize_build","text":"To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: Type Description (log, success) Source code in exam_gen/exam/base.py def finalize_build ( self , build_info ): \"\"\" To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: (log, success) \"\"\" pass","title":"finalize_build()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.get_keyed_rng","text":"Source code in exam_gen/exam/base.py def get_keyed_rng ( self , * keys ): if self . root_seed == None : self . root_seed = self . init_root_seed () return Random ( stable_hash ( self . root_seed , * keys ))","title":"get_keyed_rng()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.init_document","text":"Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/exam/base.py def init_document ( self , doc_class , ** kwargs ): return super ( PersonalDoc , self ) . init_document ( doc_class , student = self . student , classroom = self . classroom , ** kwargs )","title":"init_document()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.init_questions","text":"Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/exam/base.py def init_questions ( self ): super ( Numbered , self ) . init_questions () if self . _parent_doc == None : self . push_numbering ()","title":"init_questions()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.init_root_seed","text":"Source code in exam_gen/exam/base.py def init_root_seed ( self ): from exam_gen.property.personalized import Personalized if isinstance ( self , Personalized ): return self . student . root_seed raise RuntimeError ( \"No method to get root seed\" )","title":"init_root_seed()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.lookup_file","text":"Source code in exam_gen/exam/base.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.on_children","text":"Source code in exam_gen/exam/base.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log","title":"on_children()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.output_build","text":"Copies the files from the build directory to the output directory Options to rename them should be in build_settings. Source code in exam_gen/exam/base.py def output_build ( self , build_info ): \"\"\" Copies the files from the build directory to the output directory Options to rename them should be in build_settings. \"\"\" pass","title":"output_build()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.push_numbering","text":"Source code in exam_gen/exam/base.py def push_numbering ( self ): if self . _numbering_depth == None or self . _numbering_depth == \"\" : self . _numbering_depth = self . settings . numbering_scheme for ( ind , ( name , question )) in enumerate ( self . questions . items ()): self . questions [ name ] . settings . numbering_scheme = ( self . settings . numbering_scheme ) self . questions [ name ] . _numbering_depth = self . _numbering_depth [ 1 :] self . questions [ name ] . _depth = self . _depth + 1 self . questions [ name ] . _number = self . _get_subq_number ( ind ) self . questions [ name ] . push_numbering ()","title":"push_numbering()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.rng","text":"A repeatable random number generator that will always produce the same sequence of outputs for any given student, exam pair. Source code in exam_gen/exam/base.py @setup_arg def rng ( self ) -> Random : \"\"\" A repeatable random number generator that will always produce the same sequence of outputs for any given student, exam pair. \"\"\" return self . get_keyed_rng ( 'user_setup' )","title":"rng()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.root_document","text":"Source code in exam_gen/exam/base.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self","title":"root_document()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.setup_build","text":"Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. Source code in exam_gen/exam/base.py def setup_build ( self , build_info ): log = super ( HasRNG , self ) . setup_build ( build_info ) if self . root_seed == None : self . root_seed = self . init_root_seed () for ( name , memb ) in self . questions . items (): memb . root_seed = stable_hash ( self . root_seed , name ) log [ 'root_seed' ] = self . root_seed return log","title":"setup_build()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.template_spec","text":"Source code in exam_gen/exam/base.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec","title":"template_spec()"},{"location":"api/exam.html#exam_gen.exam.base.Exam.user_setup","text":"Override this function in your code, otherwise it won't customize stuff. Todo We need a nicer output format here, but this will do for the moment. Function Signature: py <Signature (self, ctxt: dict, rng: random.Random)> Arg Metadata: { 'ctxt' : { 'arg' : 'ctxt' , 'doc' : 'A dictionary of values returned by the `user_setup` ' 'functions of \\n ' 'any parent documents.' , 'fun' : < function HasContext . ctxt at 0x7fdee2f8e4c0 > , 'typ' : < class ' dict '>}, 'rng' : { 'arg' : 'rng' , 'doc' : 'A repeatable random number generator that will always produce ' 'the same \\n ' 'sequence of outputs for any given student, exam pair.' , 'fun' : < function HasRNG . rng at 0x7fdee2fa3940 > , 'typ' : < class ' random . Random '>}}","title":"user_setup()"},{"location":"api/build/cli.html","text":"exam_gen.build.cli : Command Line Entry-Point and Helpers \u00b6 The entry point and core functions for the command line interface. exam_root \u00b6 get_exam ( global_vars ) \u00b6 Parses through a list of global variables to find the Exam subclass that we're going to be building. Parameters: Name Type Description Default global_vars The local namespace that will be searched in order to find an Exam . required Source code in exam_gen/build/cli.py def get_exam ( global_vars ): \"\"\" Parses through a list of global variables to find the `Exam` subclass that we're going to be building. Parameters: global_vars: The local namespace that will be searched in order to find an `Exam`. \"\"\" exam = None source_file = Path ( global_vars [ '__file__' ]) for ( k , v ) in global_vars . items (): if ( inspect . isclass ( v ) and issubclass ( v , Exam ) and v != Exam and Path ( inspect . getsourcefile ( v )) == source_file ): assert ( exam == None ), ( \"Found multiple potential exam classes in\" + \" file, should only ever have one\" ) exam = v assert ( exam != None ), ( \"Found no potential exams in file, need one.\" ) return exam get_var_opts ( global_vars ) \u00b6 Pulls any settings information from the global variables. Currently does nothing. Parameters: Name Type Description Default global_vars The local namespace which contains options. required Source code in exam_gen/build/cli.py def get_var_opts ( global_vars ): \"\"\" Pulls any settings information from the global variables. !!! important \"Currently does nothing.\" Parameters: global_vars: The local namespace which contains options. \"\"\" return {} run_cli ( global_vars ) \u00b6 The entry point for when we're using exam_gen as a pure library. Should be used in exam.py as follows: if __name__ == \"main\" : run_cli ( globals ()) Parameters: Name Type Description Default global_vars The local namespace to build a cli around. required Source code in exam_gen/build/cli.py def run_cli ( global_vars ): \"\"\" The entry point for when we're using `exam_gen` as a pure library. Should be used in `exam.py` as follows: ```python if __name__ == \"main\": run_cli(globals()) ``` Parameters: global_vars: The local namespace to build a cli around. \"\"\" # var_opts = get_var_opts(global_vars) exam = get_exam ( global_vars ) builder = BuildLoader ( exam ) sys . exit ( DoitMain ( builder ) . run ( sys . argv [ 1 :]))","title":".build.cli"},{"location":"api/build/cli.html#exam_genbuildcli-command-line-entry-point-and-helpers","text":"The entry point and core functions for the command line interface.","title":"exam_gen.build.cli : Command Line Entry-Point and Helpers"},{"location":"api/build/cli.html#exam_gen.build.cli.exam_root","text":"","title":"exam_root"},{"location":"api/build/cli.html#exam_gen.build.cli.get_exam","text":"Parses through a list of global variables to find the Exam subclass that we're going to be building. Parameters: Name Type Description Default global_vars The local namespace that will be searched in order to find an Exam . required Source code in exam_gen/build/cli.py def get_exam ( global_vars ): \"\"\" Parses through a list of global variables to find the `Exam` subclass that we're going to be building. Parameters: global_vars: The local namespace that will be searched in order to find an `Exam`. \"\"\" exam = None source_file = Path ( global_vars [ '__file__' ]) for ( k , v ) in global_vars . items (): if ( inspect . isclass ( v ) and issubclass ( v , Exam ) and v != Exam and Path ( inspect . getsourcefile ( v )) == source_file ): assert ( exam == None ), ( \"Found multiple potential exam classes in\" + \" file, should only ever have one\" ) exam = v assert ( exam != None ), ( \"Found no potential exams in file, need one.\" ) return exam","title":"get_exam()"},{"location":"api/build/cli.html#exam_gen.build.cli.get_var_opts","text":"Pulls any settings information from the global variables. Currently does nothing. Parameters: Name Type Description Default global_vars The local namespace which contains options. required Source code in exam_gen/build/cli.py def get_var_opts ( global_vars ): \"\"\" Pulls any settings information from the global variables. !!! important \"Currently does nothing.\" Parameters: global_vars: The local namespace which contains options. \"\"\" return {}","title":"get_var_opts()"},{"location":"api/build/cli.html#exam_gen.build.cli.run_cli","text":"The entry point for when we're using exam_gen as a pure library. Should be used in exam.py as follows: if __name__ == \"main\" : run_cli ( globals ()) Parameters: Name Type Description Default global_vars The local namespace to build a cli around. required Source code in exam_gen/build/cli.py def run_cli ( global_vars ): \"\"\" The entry point for when we're using `exam_gen` as a pure library. Should be used in `exam.py` as follows: ```python if __name__ == \"main\": run_cli(globals()) ``` Parameters: global_vars: The local namespace to build a cli around. \"\"\" # var_opts = get_var_opts(global_vars) exam = get_exam ( global_vars ) builder = BuildLoader ( exam ) sys . exit ( DoitMain ( builder ) . run ( sys . argv [ 1 :]))","title":"run_cli()"},{"location":"api/build/data.html","text":"exam_gen.build.data : Build Information Dataclass \u00b6 BuildInfo \u00b6 Information about the build process Todo: Write up attribute information __init__ ( self , * , student_id = None , student = None , class_name = None , classroom = None , is_standalone = False , exam_format = None , settings = NOTHING , data_path = None , build_path = None , out_path = None , data_dir = '~data' , build_dir = '~build' , out_dir = '~out' , class_prefix = 'class-' , student_prefix = 'student-' , exam_prefix = 'exam-' , question_prefix = 'question-' , base_roster_file = 'roster.yaml' , answered_roster_file = 'answered-roster.yaml' , scored_roster_file = 'scored-roster.yaml' , graded_roster_file = 'graded-roster.yaml' , pre_prefix = 'pre-' , post_prefix = 'post-' , init_prefix = 'init-' , setup_prefix = 'setup-' , finalize_prefix = 'finalize-' , template_prefix = 'template-' , output_prefix = 'output-' , doc_file = 'doc.yaml' , log_file = 'log.yaml' , spec_file = 'spec.yaml' , result_file = 'result.yaml' , student_data_file = 'data.yaml' , grade_data_file = 'grade-data.yaml' , build_settings = NOTHING ) special \u00b6 Method generated by attrs for class BuildInfo. Source code in exam_gen/build/data.py def __init__ ( self , * , student_id = attr_dict [ 'student_id' ] . default , student = attr_dict [ 'student' ] . default , class_name = attr_dict [ 'class_name' ] . default , classroom = attr_dict [ 'classroom' ] . default , is_standalone = attr_dict [ 'is_standalone' ] . default , exam_format = attr_dict [ 'exam_format' ] . default , settings = NOTHING , data_path = attr_dict [ 'data_path' ] . default , build_path = attr_dict [ 'build_path' ] . default , out_path = attr_dict [ 'out_path' ] . default , data_dir = attr_dict [ 'data_dir' ] . default , build_dir = attr_dict [ 'build_dir' ] . default , out_dir = attr_dict [ 'out_dir' ] . default , class_prefix = attr_dict [ 'class_prefix' ] . default , student_prefix = attr_dict [ 'student_prefix' ] . default , exam_prefix = attr_dict [ 'exam_prefix' ] . default , question_prefix = attr_dict [ 'question_prefix' ] . default , base_roster_file = attr_dict [ 'base_roster_file' ] . default , answered_roster_file = attr_dict [ 'answered_roster_file' ] . default , scored_roster_file = attr_dict [ 'scored_roster_file' ] . default , graded_roster_file = attr_dict [ 'graded_roster_file' ] . default , pre_prefix = attr_dict [ 'pre_prefix' ] . default , post_prefix = attr_dict [ 'post_prefix' ] . default , init_prefix = attr_dict [ 'init_prefix' ] . default , setup_prefix = attr_dict [ 'setup_prefix' ] . default , finalize_prefix = attr_dict [ 'finalize_prefix' ] . default , template_prefix = attr_dict [ 'template_prefix' ] . default , output_prefix = attr_dict [ 'output_prefix' ] . default , doc_file = attr_dict [ 'doc_file' ] . default , log_file = attr_dict [ 'log_file' ] . default , spec_file = attr_dict [ 'spec_file' ] . default , result_file = attr_dict [ 'result_file' ] . default , student_data_file = attr_dict [ 'student_data_file' ] . default , grade_data_file = attr_dict [ 'grade_data_file' ] . default , build_settings = NOTHING ): self . student_id = student_id self . student = student self . class_name = class_name self . classroom = classroom self . is_standalone = is_standalone self . exam_format = exam_format if settings is not NOTHING : self . settings = settings else : self . settings = __attr_factory_settings () self . data_path = data_path self . build_path = build_path self . out_path = out_path self . data_dir = data_dir self . build_dir = build_dir self . out_dir = out_dir self . class_prefix = class_prefix self . student_prefix = student_prefix self . exam_prefix = exam_prefix self . question_prefix = question_prefix self . base_roster_file = base_roster_file self . answered_roster_file = answered_roster_file self . scored_roster_file = scored_roster_file self . graded_roster_file = graded_roster_file self . pre_prefix = pre_prefix self . post_prefix = post_prefix self . init_prefix = init_prefix self . setup_prefix = setup_prefix self . finalize_prefix = finalize_prefix self . template_prefix = template_prefix self . output_prefix = output_prefix self . doc_file = doc_file self . log_file = log_file self . spec_file = spec_file self . result_file = result_file self . student_data_file = student_data_file self . grade_data_file = grade_data_file self . root_dir = attr_dict [ 'root_dir' ] . default if build_settings is not NOTHING : self . build_settings = build_settings else : self . build_settings = __attr_factory_build_settings () base_build_path ( self ) \u00b6 Source code in exam_gen/build/data.py def base_build_path ( self ): return Path ( self . root_dir , self . build_dir ) base_data_path ( self ) \u00b6 Source code in exam_gen/build/data.py def base_data_path ( self ): return Path ( self . root_dir , self . data_dir ) base_out_path ( self ) \u00b6 Source code in exam_gen/build/data.py def base_out_path ( self ): return Path ( self . root_dir , self . out_dir ) class_build_path ( self ) \u00b6 Source code in exam_gen/build/data.py def class_build_path ( self ): return Path ( self . base_build_path (), self . class_prefix + self . class_name ) class_data_path ( self ) \u00b6 Source code in exam_gen/build/data.py def class_data_path ( self ): return Path ( self . base_data_path (), self . class_prefix + self . class_name ) class_out_path ( self ) \u00b6 Source code in exam_gen/build/data.py def class_out_path ( self ): return Path ( self . base_out_path (), self . class_prefix + self . class_name ) exam_build_path ( self ) \u00b6 Source code in exam_gen/build/data.py def exam_build_path ( self ): return Path ( self . student_build_path (), self . exam_prefix + self . exam_format ) exam_data_path ( self ) \u00b6 Source code in exam_gen/build/data.py def exam_data_path ( self ): return Path ( self . student_data_path (), self . exam_prefix + self . exam_format ) exam_out_path ( self ) \u00b6 Source code in exam_gen/build/data.py def exam_out_path ( self ): return Path ( self . base_out_path (), self . exam_prefix + self . exam_format , self . class_prefix + self . class_name ) question_build_path ( self ) \u00b6 Source code in exam_gen/build/data.py def question_build_path ( self ): return Path ( self . student_build_path (), self . question_prefix + self . question_format ) question_data_path ( self ) \u00b6 Source code in exam_gen/build/data.py def question_data_path ( self ): return Path ( self . student_data_path ( self . class_name , self . student_id ), self . question_prefix + self . question_format ) question_out_path ( self ) \u00b6 Source code in exam_gen/build/data.py def question_out_path ( self ): return Path ( self . base_out_path (), self . question_prefix + self . question_format , self . class_prefix + self . class_name ) student_build_path ( self ) \u00b6 Source code in exam_gen/build/data.py def student_build_path ( self ): return Path ( self . class_build_path (), self . student_prefix + self . student_id ) student_data_path ( self ) \u00b6 Source code in exam_gen/build/data.py def student_data_path ( self ): return Path ( self . class_data_path (), self . student_prefix + self . student_id ) where ( self , ** kwargs ) \u00b6 Create a new copy of this object with some attributes changed. Parameters are identical to the parameters of BuildInfo.__init__ . Source code in exam_gen/build/data.py def where ( self , ** kwargs ): \"\"\" Create a new copy of this object with some attributes changed. Parameters are identical to the parameters of `BuildInfo.__init__`. \"\"\" new = deepcopy ( self ) for ( k , v ) in kwargs . items (): setattr ( new , k , v ) return new","title":".build.data"},{"location":"api/build/data.html#exam_genbuilddata-build-information-dataclass","text":"","title":"exam_gen.build.data: Build Information Dataclass"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo","text":"Information about the build process Todo: Write up attribute information","title":"BuildInfo"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.__init__","text":"Method generated by attrs for class BuildInfo. Source code in exam_gen/build/data.py def __init__ ( self , * , student_id = attr_dict [ 'student_id' ] . default , student = attr_dict [ 'student' ] . default , class_name = attr_dict [ 'class_name' ] . default , classroom = attr_dict [ 'classroom' ] . default , is_standalone = attr_dict [ 'is_standalone' ] . default , exam_format = attr_dict [ 'exam_format' ] . default , settings = NOTHING , data_path = attr_dict [ 'data_path' ] . default , build_path = attr_dict [ 'build_path' ] . default , out_path = attr_dict [ 'out_path' ] . default , data_dir = attr_dict [ 'data_dir' ] . default , build_dir = attr_dict [ 'build_dir' ] . default , out_dir = attr_dict [ 'out_dir' ] . default , class_prefix = attr_dict [ 'class_prefix' ] . default , student_prefix = attr_dict [ 'student_prefix' ] . default , exam_prefix = attr_dict [ 'exam_prefix' ] . default , question_prefix = attr_dict [ 'question_prefix' ] . default , base_roster_file = attr_dict [ 'base_roster_file' ] . default , answered_roster_file = attr_dict [ 'answered_roster_file' ] . default , scored_roster_file = attr_dict [ 'scored_roster_file' ] . default , graded_roster_file = attr_dict [ 'graded_roster_file' ] . default , pre_prefix = attr_dict [ 'pre_prefix' ] . default , post_prefix = attr_dict [ 'post_prefix' ] . default , init_prefix = attr_dict [ 'init_prefix' ] . default , setup_prefix = attr_dict [ 'setup_prefix' ] . default , finalize_prefix = attr_dict [ 'finalize_prefix' ] . default , template_prefix = attr_dict [ 'template_prefix' ] . default , output_prefix = attr_dict [ 'output_prefix' ] . default , doc_file = attr_dict [ 'doc_file' ] . default , log_file = attr_dict [ 'log_file' ] . default , spec_file = attr_dict [ 'spec_file' ] . default , result_file = attr_dict [ 'result_file' ] . default , student_data_file = attr_dict [ 'student_data_file' ] . default , grade_data_file = attr_dict [ 'grade_data_file' ] . default , build_settings = NOTHING ): self . student_id = student_id self . student = student self . class_name = class_name self . classroom = classroom self . is_standalone = is_standalone self . exam_format = exam_format if settings is not NOTHING : self . settings = settings else : self . settings = __attr_factory_settings () self . data_path = data_path self . build_path = build_path self . out_path = out_path self . data_dir = data_dir self . build_dir = build_dir self . out_dir = out_dir self . class_prefix = class_prefix self . student_prefix = student_prefix self . exam_prefix = exam_prefix self . question_prefix = question_prefix self . base_roster_file = base_roster_file self . answered_roster_file = answered_roster_file self . scored_roster_file = scored_roster_file self . graded_roster_file = graded_roster_file self . pre_prefix = pre_prefix self . post_prefix = post_prefix self . init_prefix = init_prefix self . setup_prefix = setup_prefix self . finalize_prefix = finalize_prefix self . template_prefix = template_prefix self . output_prefix = output_prefix self . doc_file = doc_file self . log_file = log_file self . spec_file = spec_file self . result_file = result_file self . student_data_file = student_data_file self . grade_data_file = grade_data_file self . root_dir = attr_dict [ 'root_dir' ] . default if build_settings is not NOTHING : self . build_settings = build_settings else : self . build_settings = __attr_factory_build_settings ()","title":"__init__()"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.base_build_path","text":"Source code in exam_gen/build/data.py def base_build_path ( self ): return Path ( self . root_dir , self . build_dir )","title":"base_build_path()"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.base_data_path","text":"Source code in exam_gen/build/data.py def base_data_path ( self ): return Path ( self . root_dir , self . data_dir )","title":"base_data_path()"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.base_out_path","text":"Source code in exam_gen/build/data.py def base_out_path ( self ): return Path ( self . root_dir , self . out_dir )","title":"base_out_path()"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.class_build_path","text":"Source code in exam_gen/build/data.py def class_build_path ( self ): return Path ( self . base_build_path (), self . class_prefix + self . class_name )","title":"class_build_path()"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.class_data_path","text":"Source code in exam_gen/build/data.py def class_data_path ( self ): return Path ( self . base_data_path (), self . class_prefix + self . class_name )","title":"class_data_path()"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.class_out_path","text":"Source code in exam_gen/build/data.py def class_out_path ( self ): return Path ( self . base_out_path (), self . class_prefix + self . class_name )","title":"class_out_path()"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.exam_build_path","text":"Source code in exam_gen/build/data.py def exam_build_path ( self ): return Path ( self . student_build_path (), self . exam_prefix + self . exam_format )","title":"exam_build_path()"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.exam_data_path","text":"Source code in exam_gen/build/data.py def exam_data_path ( self ): return Path ( self . student_data_path (), self . exam_prefix + self . exam_format )","title":"exam_data_path()"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.exam_out_path","text":"Source code in exam_gen/build/data.py def exam_out_path ( self ): return Path ( self . base_out_path (), self . exam_prefix + self . exam_format , self . class_prefix + self . class_name )","title":"exam_out_path()"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.question_build_path","text":"Source code in exam_gen/build/data.py def question_build_path ( self ): return Path ( self . student_build_path (), self . question_prefix + self . question_format )","title":"question_build_path()"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.question_data_path","text":"Source code in exam_gen/build/data.py def question_data_path ( self ): return Path ( self . student_data_path ( self . class_name , self . student_id ), self . question_prefix + self . question_format )","title":"question_data_path()"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.question_out_path","text":"Source code in exam_gen/build/data.py def question_out_path ( self ): return Path ( self . base_out_path (), self . question_prefix + self . question_format , self . class_prefix + self . class_name )","title":"question_out_path()"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.student_build_path","text":"Source code in exam_gen/build/data.py def student_build_path ( self ): return Path ( self . class_build_path (), self . student_prefix + self . student_id )","title":"student_build_path()"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.student_data_path","text":"Source code in exam_gen/build/data.py def student_data_path ( self ): return Path ( self . class_data_path (), self . student_prefix + self . student_id )","title":"student_data_path()"},{"location":"api/build/data.html#exam_gen.build.data.BuildInfo.where","text":"Create a new copy of this object with some attributes changed. Parameters are identical to the parameters of BuildInfo.__init__ . Source code in exam_gen/build/data.py def where ( self , ** kwargs ): \"\"\" Create a new copy of this object with some attributes changed. Parameters are identical to the parameters of `BuildInfo.__init__`. \"\"\" new = deepcopy ( self ) for ( k , v ) in kwargs . items (): setattr ( new , k , v ) return new","title":"where()"},{"location":"api/build/formats.html","text":"exam_gen.build.formats : List of Build Formats \u00b6 __exam_formats__ special \u00b6 List of possible formats for exams.","title":".build.formats"},{"location":"api/build/formats.html#exam_genbuildformats-list-of-build-formats","text":"","title":"exam_gen.build.formats: List of Build Formats"},{"location":"api/build/formats.html#exam_gen.build.formats.__exam_formats__","text":"List of possible formats for exams.","title":"__exam_formats__"},{"location":"api/build/loader.html","text":"","title":"Loader"},{"location":"api/classroom/answers.html","text":"exam_gen.classroom.answers : Classes for Parsing and Loading Student Answers \u00b6 log \u00b6 Answers \u00b6 __eq__ ( self , other ) special \u00b6 Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __eq__ ( self , other ): if other . __class__ is not self . __class__ : return NotImplemented return ( self . root_dir , self . parent_obj , self . parent_path , self . use_class_root , self . root_file , self . exam , ) == ( other . root_dir , other . parent_obj , other . parent_path , other . use_class_root , other . root_file , other . exam , ) __ge__ ( self , other ) special \u00b6 Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __ge__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) >= attrs_to_tuple ( other ) return NotImplemented __gt__ ( self , other ) special \u00b6 Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __gt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) > attrs_to_tuple ( other ) return NotImplemented __init__ ( self , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , exam ) special \u00b6 Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , exam ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . exam = exam self . __attrs_post_init__ () __le__ ( self , other ) special \u00b6 Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __le__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) <= attrs_to_tuple ( other ) return NotImplemented __lt__ ( self , other ) special \u00b6 Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __lt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) < attrs_to_tuple ( other ) return NotImplemented __ne__ ( self , other ) special \u00b6 Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __ne__ ( self , other ): \"\"\" Check equality and either forward a NotImplemented or return the result negated. \"\"\" result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result __repr__ ( self ) special \u00b6 Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __repr__ ( self ): \"\"\" Automatically created by attrs. \"\"\" try : working_set = _already_repring . working_set except AttributeError : working_set = set () _already_repring . working_set = working_set if id ( self ) in working_set : return \"...\" real_cls = self . __class__ if ns is None : qualname = getattr ( real_cls , \"__qualname__\" , None ) if qualname is not None : class_name = qualname . rsplit ( \">.\" , 1 )[ - 1 ] else : class_name = real_cls . __name__ else : class_name = ns + \".\" + real_cls . __name__ # Since 'self' remains on the stack (i.e.: strongly referenced) for the # duration of this call, it's safe to depend on id(...) stability, and # not need to track the instance and therefore worry about properties # like weakref- or hash-ability. working_set . add ( id ( self )) try : result = [ class_name , \"(\" ] first = True for name , attr_repr in attr_names_with_reprs : if first : first = False else : result . append ( \", \" ) result . extend ( ( name , \"=\" , attr_repr ( getattr ( self , name , NOTHING ))) ) return \"\" . join ( result ) + \")\" finally : working_set . remove ( id ( self )) load_answers ( self , students ) \u00b6 Load the answers from file, producing a dictionary from student id to AnswerData for that student Source code in exam_gen/classroom/answers.py def load_answers ( self , students ): \"\"\" Load the answers from file, producing a dictionary from student id to AnswerData for that student \"\"\" raise RuntimeError ( \"Must implement in subclass\" ) CSVAnswers \u00b6 __attrs_post_init__ ( self ) special \u00b6 Source code in exam_gen/classroom/answers.py def __attrs_post_init__ ( self ): if hasattr ( super (), '__attrs_post_init__' ): super () . __attrs_post_init__ () self . mapping = DocSelect ( self . mapping , norm_field = CSVAnswers . _norm_map_field ) if self . attempt_column != None : self . attempt_column = FieldSelect ( self . attempt_column ) __eq__ ( self , other ) special \u00b6 Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __eq__ ( self , other ): if other . __class__ is not self . __class__ : return NotImplemented return ( self . root_dir , self . parent_obj , self . parent_path , self . use_class_root , self . root_file , self . exam , self . file_name , self . mapping , self . ident_column , self . attempt_column , ) == ( other . root_dir , other . parent_obj , other . parent_path , other . use_class_root , other . root_file , other . exam , other . file_name , other . mapping , other . ident_column , other . attempt_column , ) __ge__ ( self , other ) special \u00b6 Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __ge__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) >= attrs_to_tuple ( other ) return NotImplemented __gt__ ( self , other ) special \u00b6 Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __gt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) > attrs_to_tuple ( other ) return NotImplemented __init__ ( self , file_name , mapping , ident_column = 'Student ID' , attempt_column = None , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , exam ) special \u00b6 Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __init__ ( self , file_name , mapping , ident_column = attr_dict [ 'ident_column' ] . default , attempt_column = attr_dict [ 'attempt_column' ] . default , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , exam ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . exam = exam self . file_name = file_name self . mapping = mapping self . ident_column = __attr_converter_ident_column ( ident_column ) self . attempt_column = attempt_column self . __attrs_post_init__ () __le__ ( self , other ) special \u00b6 Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __le__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) <= attrs_to_tuple ( other ) return NotImplemented __lt__ ( self , other ) special \u00b6 Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __lt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) < attrs_to_tuple ( other ) return NotImplemented __ne__ ( self , other ) special \u00b6 Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __ne__ ( self , other ): \"\"\" Check equality and either forward a NotImplemented or return the result negated. \"\"\" result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result __repr__ ( self ) special \u00b6 Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __repr__ ( self ): \"\"\" Automatically created by attrs. \"\"\" try : working_set = _already_repring . working_set except AttributeError : working_set = set () _already_repring . working_set = working_set if id ( self ) in working_set : return \"...\" real_cls = self . __class__ if ns is None : qualname = getattr ( real_cls , \"__qualname__\" , None ) if qualname is not None : class_name = qualname . rsplit ( \">.\" , 1 )[ - 1 ] else : class_name = real_cls . __name__ else : class_name = ns + \".\" + real_cls . __name__ # Since 'self' remains on the stack (i.e.: strongly referenced) for the # duration of this call, it's safe to depend on id(...) stability, and # not need to track the instance and therefore worry about properties # like weakref- or hash-ability. working_set . add ( id ( self )) try : result = [ class_name , \"(\" ] first = True for name , attr_repr in attr_names_with_reprs : if first : first = False else : result . append ( \", \" ) result . extend ( ( name , \"=\" , attr_repr ( getattr ( self , name , NOTHING ))) ) return \"\" . join ( result ) + \")\" finally : working_set . remove ( id ( self )) convert_answers ( self , students , answers ) \u00b6 Parse single submissions out to students and merge them Source code in exam_gen/classroom/answers.py def convert_answers ( self , students , answers ): \"\"\" Parse single submissions out to students and merge them \"\"\" merge_attempts = lambda new , old : [ new ] if old == None else [ new ] + old student_attempts = self . ident_column . partition ( students , answers , merge_with = merge_attempts ) student_answers = dict () for ( ident , attempts ) in student_attempts . items (): student_answers [ ident ] = self . unify_attempts ( attempts ) return student_answers convert_attempt ( self , attempt ) \u00b6 Convert a single submission into an answerdata using the mapping info Source code in exam_gen/classroom/answers.py def convert_attempt ( self , attempt ): \"\"\" Convert a single submission into an answerdata using the mapping info \"\"\" return self . mapping . select ( attempt , supress_error = True , with_meta = lambda match , meta : AnswerData ( match , ** meta ) ) load_answers ( self , students ) \u00b6 Load the answers from file, producing a dictionary from student id to AnswerData for that student Source code in exam_gen/classroom/answers.py def load_answers ( self , students ): file_name = self . lookup_file ( self . file_name ) raw_answers = self . read_answers ( file_name ) return self . convert_answers ( students , raw_answers ) read_answers ( self , file_name ) \u00b6 Source code in exam_gen/classroom/answers.py def read_answers ( self , file_name ): input_file = Path ( file_name ) . open ( mode = 'r' ) answer_list = list ( csv . DictReader ( input_file )) return answer_list unify_attempts ( self , attempt_list ) \u00b6 Will combine all the submission attempts of the students keeping the most recent of each submitted answer. Source code in exam_gen/classroom/answers.py def unify_attempts ( self , attempt_list ): \"\"\" Will combine all the submission attempts of the students keeping the most recent of each submitted answer. \"\"\" if self . attempt_column == None and len ( attempt_list ) != 1 : raise RuntimeError ( \"Multiple Submissions the same student with no\" \" attempt number column specified.\" ) answer_data = None for attempt in attempt_list : new_data = AnswerData ( children = self . convert_attempt ( attempt ), meta = { 'raw' : attempt } ) if self . attempt_column != None : new_data . meta [ 'attempt_num' ] = self . attempt_column . select ( attempt ) if answer_data != None : if new_data . meta [ 'attempt_num' ] < answer_data . meta [ 'attempt_num' ]: answer_data , new_data = ( new_data , answer_data ) new_data . meta [ 'prev_attempt' ] = answer_data answer_data = deepcopy ( answer_data ) answer_data . merge ( deepcopy ( new_data )) else : answer_data = new_data return answer_data selection: filters: - \"!^_[^_]*\" - \"!log\" - \"__init__\"","title":".classroom.answers"},{"location":"api/classroom/answers.html#exam_genclassroomanswers-classes-for-parsing-and-loading-student-answers","text":"","title":"exam_gen.classroom.answers: Classes for Parsing and Loading Student Answers"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.log","text":"","title":"log"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.Answers","text":"","title":"Answers"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.Answers.__eq__","text":"Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __eq__ ( self , other ): if other . __class__ is not self . __class__ : return NotImplemented return ( self . root_dir , self . parent_obj , self . parent_path , self . use_class_root , self . root_file , self . exam , ) == ( other . root_dir , other . parent_obj , other . parent_path , other . use_class_root , other . root_file , other . exam , )","title":"__eq__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.Answers.__ge__","text":"Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __ge__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) >= attrs_to_tuple ( other ) return NotImplemented","title":"__ge__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.Answers.__gt__","text":"Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __gt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) > attrs_to_tuple ( other ) return NotImplemented","title":"__gt__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.Answers.__init__","text":"Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , exam ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . exam = exam self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.Answers.__le__","text":"Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __le__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) <= attrs_to_tuple ( other ) return NotImplemented","title":"__le__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.Answers.__lt__","text":"Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __lt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) < attrs_to_tuple ( other ) return NotImplemented","title":"__lt__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.Answers.__ne__","text":"Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __ne__ ( self , other ): \"\"\" Check equality and either forward a NotImplemented or return the result negated. \"\"\" result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result","title":"__ne__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.Answers.__repr__","text":"Method generated by attrs for class Answers. Source code in exam_gen/classroom/answers.py def __repr__ ( self ): \"\"\" Automatically created by attrs. \"\"\" try : working_set = _already_repring . working_set except AttributeError : working_set = set () _already_repring . working_set = working_set if id ( self ) in working_set : return \"...\" real_cls = self . __class__ if ns is None : qualname = getattr ( real_cls , \"__qualname__\" , None ) if qualname is not None : class_name = qualname . rsplit ( \">.\" , 1 )[ - 1 ] else : class_name = real_cls . __name__ else : class_name = ns + \".\" + real_cls . __name__ # Since 'self' remains on the stack (i.e.: strongly referenced) for the # duration of this call, it's safe to depend on id(...) stability, and # not need to track the instance and therefore worry about properties # like weakref- or hash-ability. working_set . add ( id ( self )) try : result = [ class_name , \"(\" ] first = True for name , attr_repr in attr_names_with_reprs : if first : first = False else : result . append ( \", \" ) result . extend ( ( name , \"=\" , attr_repr ( getattr ( self , name , NOTHING ))) ) return \"\" . join ( result ) + \")\" finally : working_set . remove ( id ( self ))","title":"__repr__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.Answers.load_answers","text":"Load the answers from file, producing a dictionary from student id to AnswerData for that student Source code in exam_gen/classroom/answers.py def load_answers ( self , students ): \"\"\" Load the answers from file, producing a dictionary from student id to AnswerData for that student \"\"\" raise RuntimeError ( \"Must implement in subclass\" )","title":"load_answers()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.CSVAnswers","text":"","title":"CSVAnswers"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.CSVAnswers.__attrs_post_init__","text":"Source code in exam_gen/classroom/answers.py def __attrs_post_init__ ( self ): if hasattr ( super (), '__attrs_post_init__' ): super () . __attrs_post_init__ () self . mapping = DocSelect ( self . mapping , norm_field = CSVAnswers . _norm_map_field ) if self . attempt_column != None : self . attempt_column = FieldSelect ( self . attempt_column )","title":"__attrs_post_init__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.CSVAnswers.__eq__","text":"Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __eq__ ( self , other ): if other . __class__ is not self . __class__ : return NotImplemented return ( self . root_dir , self . parent_obj , self . parent_path , self . use_class_root , self . root_file , self . exam , self . file_name , self . mapping , self . ident_column , self . attempt_column , ) == ( other . root_dir , other . parent_obj , other . parent_path , other . use_class_root , other . root_file , other . exam , other . file_name , other . mapping , other . ident_column , other . attempt_column , )","title":"__eq__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.CSVAnswers.__ge__","text":"Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __ge__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) >= attrs_to_tuple ( other ) return NotImplemented","title":"__ge__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.CSVAnswers.__gt__","text":"Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __gt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) > attrs_to_tuple ( other ) return NotImplemented","title":"__gt__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.CSVAnswers.__init__","text":"Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __init__ ( self , file_name , mapping , ident_column = attr_dict [ 'ident_column' ] . default , attempt_column = attr_dict [ 'attempt_column' ] . default , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , exam ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . exam = exam self . file_name = file_name self . mapping = mapping self . ident_column = __attr_converter_ident_column ( ident_column ) self . attempt_column = attempt_column self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.CSVAnswers.__le__","text":"Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __le__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) <= attrs_to_tuple ( other ) return NotImplemented","title":"__le__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.CSVAnswers.__lt__","text":"Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __lt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) < attrs_to_tuple ( other ) return NotImplemented","title":"__lt__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.CSVAnswers.__ne__","text":"Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __ne__ ( self , other ): \"\"\" Check equality and either forward a NotImplemented or return the result negated. \"\"\" result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result","title":"__ne__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.CSVAnswers.__repr__","text":"Method generated by attrs for class CSVAnswers. Source code in exam_gen/classroom/answers.py def __repr__ ( self ): \"\"\" Automatically created by attrs. \"\"\" try : working_set = _already_repring . working_set except AttributeError : working_set = set () _already_repring . working_set = working_set if id ( self ) in working_set : return \"...\" real_cls = self . __class__ if ns is None : qualname = getattr ( real_cls , \"__qualname__\" , None ) if qualname is not None : class_name = qualname . rsplit ( \">.\" , 1 )[ - 1 ] else : class_name = real_cls . __name__ else : class_name = ns + \".\" + real_cls . __name__ # Since 'self' remains on the stack (i.e.: strongly referenced) for the # duration of this call, it's safe to depend on id(...) stability, and # not need to track the instance and therefore worry about properties # like weakref- or hash-ability. working_set . add ( id ( self )) try : result = [ class_name , \"(\" ] first = True for name , attr_repr in attr_names_with_reprs : if first : first = False else : result . append ( \", \" ) result . extend ( ( name , \"=\" , attr_repr ( getattr ( self , name , NOTHING ))) ) return \"\" . join ( result ) + \")\" finally : working_set . remove ( id ( self ))","title":"__repr__()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.CSVAnswers.convert_answers","text":"Parse single submissions out to students and merge them Source code in exam_gen/classroom/answers.py def convert_answers ( self , students , answers ): \"\"\" Parse single submissions out to students and merge them \"\"\" merge_attempts = lambda new , old : [ new ] if old == None else [ new ] + old student_attempts = self . ident_column . partition ( students , answers , merge_with = merge_attempts ) student_answers = dict () for ( ident , attempts ) in student_attempts . items (): student_answers [ ident ] = self . unify_attempts ( attempts ) return student_answers","title":"convert_answers()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.CSVAnswers.convert_attempt","text":"Convert a single submission into an answerdata using the mapping info Source code in exam_gen/classroom/answers.py def convert_attempt ( self , attempt ): \"\"\" Convert a single submission into an answerdata using the mapping info \"\"\" return self . mapping . select ( attempt , supress_error = True , with_meta = lambda match , meta : AnswerData ( match , ** meta ) )","title":"convert_attempt()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.CSVAnswers.load_answers","text":"Load the answers from file, producing a dictionary from student id to AnswerData for that student Source code in exam_gen/classroom/answers.py def load_answers ( self , students ): file_name = self . lookup_file ( self . file_name ) raw_answers = self . read_answers ( file_name ) return self . convert_answers ( students , raw_answers )","title":"load_answers()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.CSVAnswers.read_answers","text":"Source code in exam_gen/classroom/answers.py def read_answers ( self , file_name ): input_file = Path ( file_name ) . open ( mode = 'r' ) answer_list = list ( csv . DictReader ( input_file )) return answer_list","title":"read_answers()"},{"location":"api/classroom/answers.html#exam_gen.classroom.answers.CSVAnswers.unify_attempts","text":"Will combine all the submission attempts of the students keeping the most recent of each submitted answer. Source code in exam_gen/classroom/answers.py def unify_attempts ( self , attempt_list ): \"\"\" Will combine all the submission attempts of the students keeping the most recent of each submitted answer. \"\"\" if self . attempt_column == None and len ( attempt_list ) != 1 : raise RuntimeError ( \"Multiple Submissions the same student with no\" \" attempt number column specified.\" ) answer_data = None for attempt in attempt_list : new_data = AnswerData ( children = self . convert_attempt ( attempt ), meta = { 'raw' : attempt } ) if self . attempt_column != None : new_data . meta [ 'attempt_num' ] = self . attempt_column . select ( attempt ) if answer_data != None : if new_data . meta [ 'attempt_num' ] < answer_data . meta [ 'attempt_num' ]: answer_data , new_data = ( new_data , answer_data ) new_data . meta [ 'prev_attempt' ] = answer_data answer_data = deepcopy ( answer_data ) answer_data . merge ( deepcopy ( new_data )) else : answer_data = new_data return answer_data selection: filters: - \"!^_[^_]*\" - \"!log\" - \"__init__\"","title":"unify_attempts()"},{"location":"api/classroom/base.html","text":"exam_gen.classroom.base : Class Representing a Set of Students \u00b6 Classroom \u00b6 __init__ ( self , exam , ** kwargs ) special \u00b6 Source code in exam_gen/classroom/base.py def __init__ ( self , exam , ** kwargs ): key_attribs = [ 'roster' , 'answers' , 'scores' , 'grades' ] new_kwargs = dict () for k in key_attribs : attr = getattr ( type ( self ), k , None ) if ( k not in kwargs and attr != None and not isinstance ( attr , _CountingAttr )): new_kwargs [ k ] = attr kwargs |= new_kwargs self . __attrs_init__ ( exam , ** kwargs ) assign_grades ( self , ident , grade_data ) \u00b6 Source code in exam_gen/classroom/base.py def assign_grades ( self , ident , grade_data ): self . students [ ident ] . grade_data = grade_data load_answers ( self ) \u00b6 Source code in exam_gen/classroom/base.py def load_answers ( self ): assert self . students != None , ( \"Classroom must load students before loading answers.\" ) answers = self . answers . load_answers ( self . students ) for ( ident , answer ) in answers . items (): if self . students [ ident ] . answer_data == None : self . students [ ident ] . answer_data = answer else : self . students [ ident ] . answer_data . merge ( answer ) load_scores ( self ) \u00b6 Source code in exam_gen/classroom/base.py def load_scores ( self ): scores = self . scored . load_scores () for ( ident , score ) in scores . items (): if self . students [ ident ] . score_data == None : self . students [ ident ] . score_data = score else : self . students [ ident ] . score_data . merge ( score ) load_students ( self ) \u00b6 Source code in exam_gen/classroom/base.py def load_students ( self ): self . students |= self . roster . load_roster () lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/classroom/base.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) print_grades ( self , out_dir ) \u00b6 Source code in exam_gen/classroom/base.py def print_grades ( self , out_dir ): self . grades . print_grades ( self . students , out_dir )","title":".classroom.base"},{"location":"api/classroom/base.html#exam_genclassroombase-class-representing-a-set-of-students","text":"","title":"exam_gen.classroom.base: Class Representing a Set of Students"},{"location":"api/classroom/base.html#exam_gen.classroom.base.Classroom","text":"","title":"Classroom"},{"location":"api/classroom/base.html#exam_gen.classroom.base.Classroom.__init__","text":"Source code in exam_gen/classroom/base.py def __init__ ( self , exam , ** kwargs ): key_attribs = [ 'roster' , 'answers' , 'scores' , 'grades' ] new_kwargs = dict () for k in key_attribs : attr = getattr ( type ( self ), k , None ) if ( k not in kwargs and attr != None and not isinstance ( attr , _CountingAttr )): new_kwargs [ k ] = attr kwargs |= new_kwargs self . __attrs_init__ ( exam , ** kwargs )","title":"__init__()"},{"location":"api/classroom/base.html#exam_gen.classroom.base.Classroom.assign_grades","text":"Source code in exam_gen/classroom/base.py def assign_grades ( self , ident , grade_data ): self . students [ ident ] . grade_data = grade_data","title":"assign_grades()"},{"location":"api/classroom/base.html#exam_gen.classroom.base.Classroom.load_answers","text":"Source code in exam_gen/classroom/base.py def load_answers ( self ): assert self . students != None , ( \"Classroom must load students before loading answers.\" ) answers = self . answers . load_answers ( self . students ) for ( ident , answer ) in answers . items (): if self . students [ ident ] . answer_data == None : self . students [ ident ] . answer_data = answer else : self . students [ ident ] . answer_data . merge ( answer )","title":"load_answers()"},{"location":"api/classroom/base.html#exam_gen.classroom.base.Classroom.load_scores","text":"Source code in exam_gen/classroom/base.py def load_scores ( self ): scores = self . scored . load_scores () for ( ident , score ) in scores . items (): if self . students [ ident ] . score_data == None : self . students [ ident ] . score_data = score else : self . students [ ident ] . score_data . merge ( score )","title":"load_scores()"},{"location":"api/classroom/base.html#exam_gen.classroom.base.Classroom.load_students","text":"Source code in exam_gen/classroom/base.py def load_students ( self ): self . students |= self . roster . load_roster ()","title":"load_students()"},{"location":"api/classroom/base.html#exam_gen.classroom.base.Classroom.lookup_file","text":"Source code in exam_gen/classroom/base.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/classroom/base.html#exam_gen.classroom.base.Classroom.print_grades","text":"Source code in exam_gen/classroom/base.py def print_grades ( self , out_dir ): self . grades . print_grades ( self . students , out_dir )","title":"print_grades()"},{"location":"api/classroom/grade.html","text":"exam_gen.classroom.grades : Class for Printing Grades \u00b6 CSVGrades \u00b6 Mapping is a dict with entries as follows __init__ ( self , exam , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , file_name = 'grades.csv' , columns = NOTHING ) special \u00b6 Method generated by attrs for class CSVGrades. Source code in exam_gen/classroom/grades.py def __init__ ( self , exam , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , file_name = attr_dict [ 'file_name' ] . default , columns = NOTHING ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . exam = exam self . file_name = file_name if columns is not NOTHING : self . columns = columns else : self . columns = __attr_factory_columns () self . __attrs_post_init__ () gen_grade_record ( self , col_keys , student ) \u00b6 Source code in exam_gen/classroom/grades.py def gen_grade_record ( self , col_keys , student ): fields = dict () for key in col_keys : fields [ key ] = self . parse_field ( spec = self . columns [ key ] . split ( '.' ), student = student , grade_data = student . grade_data ) return fields lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/classroom/grades.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) parse_field ( self , spec , student , grade_data , base_field = True ) \u00b6 Source code in exam_gen/classroom/grades.py def parse_field ( self , spec , student , grade_data , base_field = True ): if not isinstance ( spec , list ): raise TypeError ( \"Expected list\" ) elif len ( spec ) == 0 : raise RuntimeError ( \"empty parse spec\" ) elif len ( spec ) > 1 : if spec [ 0 ] in grade_data . children : return self . parse_field ( spec [ 1 :], student , grade_data . children [ spec [ 0 ]], base_field = False ) else : raise RuntimeError ( \"Could not find question \" + spec [ 0 ] + \".\" ) elif base_field and hasattr ( student , spec [ 0 ]): return getattr ( student , spec [ 0 ]) elif hasattr ( grade_data , spec [ 0 ]): return getattr ( grade_data , spec [ 0 ]) else : raise RuntimeError ( \"Could not find field {} .\" . format ( spec [ 0 ])) print_grades ( self , student_dict , out_dir ) \u00b6 Source code in exam_gen/classroom/grades.py def print_grades ( self , student_dict , out_dir ): col_keys = list ( self . columns . keys ()) out_file = Path ( out_dir , self . file_name ) out_file . parent . mkdir ( parents = True , exist_ok = True ) writer = csv . DictWriter ( out_file . open ( 'w' ), fieldnames = col_keys ) writer . writeheader () out_entries = dict () for ( student_id , student ) in student_dict . items (): entry = self . gen_grade_record ( col_keys , student ) writer . writerow ( entry ) out_entries [ student_id ] = entry return out_entries Grades \u00b6 __init__ ( self , exam , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None ) special \u00b6 Method generated by attrs for class Grades. Source code in exam_gen/classroom/grades.py def __init__ ( self , exam , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . exam = exam self . __attrs_post_init__ () lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/classroom/grades.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) print_grades ( self , student_dict , out_dir ) \u00b6 Source code in exam_gen/classroom/grades.py def print_grades ( self , student_dict , out_dir ): pass","title":".classroom.grades"},{"location":"api/classroom/grade.html#exam_genclassroomgrades-class-for-printing-grades","text":"","title":"exam_gen.classroom.grades: Class for Printing Grades"},{"location":"api/classroom/grade.html#exam_gen.classroom.grades.CSVGrades","text":"Mapping is a dict with entries as follows","title":"CSVGrades"},{"location":"api/classroom/grade.html#exam_gen.classroom.grades.CSVGrades.__init__","text":"Method generated by attrs for class CSVGrades. Source code in exam_gen/classroom/grades.py def __init__ ( self , exam , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , file_name = attr_dict [ 'file_name' ] . default , columns = NOTHING ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . exam = exam self . file_name = file_name if columns is not NOTHING : self . columns = columns else : self . columns = __attr_factory_columns () self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/classroom/grade.html#exam_gen.classroom.grades.CSVGrades.gen_grade_record","text":"Source code in exam_gen/classroom/grades.py def gen_grade_record ( self , col_keys , student ): fields = dict () for key in col_keys : fields [ key ] = self . parse_field ( spec = self . columns [ key ] . split ( '.' ), student = student , grade_data = student . grade_data ) return fields","title":"gen_grade_record()"},{"location":"api/classroom/grade.html#exam_gen.classroom.grades.CSVGrades.lookup_file","text":"Source code in exam_gen/classroom/grades.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/classroom/grade.html#exam_gen.classroom.grades.CSVGrades.parse_field","text":"Source code in exam_gen/classroom/grades.py def parse_field ( self , spec , student , grade_data , base_field = True ): if not isinstance ( spec , list ): raise TypeError ( \"Expected list\" ) elif len ( spec ) == 0 : raise RuntimeError ( \"empty parse spec\" ) elif len ( spec ) > 1 : if spec [ 0 ] in grade_data . children : return self . parse_field ( spec [ 1 :], student , grade_data . children [ spec [ 0 ]], base_field = False ) else : raise RuntimeError ( \"Could not find question \" + spec [ 0 ] + \".\" ) elif base_field and hasattr ( student , spec [ 0 ]): return getattr ( student , spec [ 0 ]) elif hasattr ( grade_data , spec [ 0 ]): return getattr ( grade_data , spec [ 0 ]) else : raise RuntimeError ( \"Could not find field {} .\" . format ( spec [ 0 ]))","title":"parse_field()"},{"location":"api/classroom/grade.html#exam_gen.classroom.grades.CSVGrades.print_grades","text":"Source code in exam_gen/classroom/grades.py def print_grades ( self , student_dict , out_dir ): col_keys = list ( self . columns . keys ()) out_file = Path ( out_dir , self . file_name ) out_file . parent . mkdir ( parents = True , exist_ok = True ) writer = csv . DictWriter ( out_file . open ( 'w' ), fieldnames = col_keys ) writer . writeheader () out_entries = dict () for ( student_id , student ) in student_dict . items (): entry = self . gen_grade_record ( col_keys , student ) writer . writerow ( entry ) out_entries [ student_id ] = entry return out_entries","title":"print_grades()"},{"location":"api/classroom/grade.html#exam_gen.classroom.grades.Grades","text":"","title":"Grades"},{"location":"api/classroom/grade.html#exam_gen.classroom.grades.Grades.__init__","text":"Method generated by attrs for class Grades. Source code in exam_gen/classroom/grades.py def __init__ ( self , exam , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . exam = exam self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/classroom/grade.html#exam_gen.classroom.grades.Grades.lookup_file","text":"Source code in exam_gen/classroom/grades.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/classroom/grade.html#exam_gen.classroom.grades.Grades.print_grades","text":"Source code in exam_gen/classroom/grades.py def print_grades ( self , student_dict , out_dir ): pass","title":"print_grades()"},{"location":"api/classroom/rosters.html","text":"exam_gen.classroom.rosters : Classes for Loading and Parsing Rosters \u00b6 BCoursesCSVRoster \u00b6 __init__ ( self , file_name , exam , domain = 'berkeley.edu' , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , tweaks = NOTHING ) special \u00b6 Method generated by attrs for class BCoursesCSVRoster. Source code in exam_gen/classroom/rosters.py def __init__ ( self , file_name , exam , domain = attr_dict [ 'domain' ] . default , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , tweaks = NOTHING ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . file_name = file_name self . exam = exam if tweaks is not NOTHING : self . tweaks = tweaks else : self . tweaks = __attr_factory_tweaks () self . students = __attr_factory_students () self . domain = domain self . __attrs_post_init__ () load_roster ( self ) inherited \u00b6 Source code in exam_gen/classroom/rosters.py def load_roster ( self ): file_name = self . lookup_file ( self . file_name ) base_roster = self . read_roster ( file_name ) for ( ident , student ) in base_roster . items (): if ident in self . tweaks : student = self . tweak_entry ( ident , student , self . tweaks [ ident ]) if student . root_seed == None : student . root_seed = self . student_seed ( student ) self . students [ ident ] = student return self . students lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/classroom/rosters.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) read_roster ( self , file_name ) inherited \u00b6 Read in the roster file and produce a dict of students (the py object) where each key is a student ID. These must have the mandatory fields set. Source code in exam_gen/classroom/rosters.py def read_roster ( self , file_name ): input_file = Path ( file_name ) . open ( mode = 'r' ) roster_list = list ( csv . DictReader ( input_file )) outputs = dict () for student in roster_list : ( username , domain ) = student [ 'Email Address' ] . split ( '@' ) if domain != self . domain : username = student [ 'Email Address' ] sid = student [ 'Student ID' ] name = student [ 'Name' ] student [ 'name' ] = name student [ 'sid' ] = sid student [ 'username' ] = username outputs [ username ] = Student ( ident = username , name = name , username = username , student_id = sid , student_data = student ) return outputs student_seed ( self , student_obj ) inherited \u00b6 Source code in exam_gen/classroom/rosters.py def student_seed ( self , student_obj ): \"\"\" \"\"\" return stable_hash ( student_obj . ident , student_obj . name , student_obj . username ) tweak_entry ( self , student_id , student_obj , tweak_entry ) inherited \u00b6 Modifies a single student entry with whatever tweak data is provided. Source code in exam_gen/classroom/rosters.py def tweak_entry ( self , student_id , student_obj , tweak_entry ): \"\"\" Modifies a single student entry with whatever tweak data is provided. \"\"\" if 'root_seed' in tweak_entry : student_obj . root_seed = tweak_entry [ 'root_seed' ] if 'name' in tweak_entry : student_obj . name = tweak_entry [ 'name' ] if 'username' in tweak_entry : student_obj . username = tweak_entry [ 'username' ] student_obj . student_data |= tweak_entry return student_obj CanvasCSVRoster \u00b6 __init__ ( self , file_name , exam , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , tweaks = NOTHING , domain ) special \u00b6 Method generated by attrs for class CanvasCSVRoster. Source code in exam_gen/classroom/rosters.py def __init__ ( self , file_name , exam , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , tweaks = NOTHING , domain ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . file_name = file_name self . exam = exam if tweaks is not NOTHING : self . tweaks = tweaks else : self . tweaks = __attr_factory_tweaks () self . students = __attr_factory_students () self . domain = domain self . __attrs_post_init__ () load_roster ( self ) inherited \u00b6 Source code in exam_gen/classroom/rosters.py def load_roster ( self ): file_name = self . lookup_file ( self . file_name ) base_roster = self . read_roster ( file_name ) for ( ident , student ) in base_roster . items (): if ident in self . tweaks : student = self . tweak_entry ( ident , student , self . tweaks [ ident ]) if student . root_seed == None : student . root_seed = self . student_seed ( student ) self . students [ ident ] = student return self . students lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/classroom/rosters.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) read_roster ( self , file_name ) \u00b6 Read in the roster file and produce a dict of students (the py object) where each key is a student ID. These must have the mandatory fields set. Source code in exam_gen/classroom/rosters.py def read_roster ( self , file_name ): input_file = Path ( file_name ) . open ( mode = 'r' ) roster_list = list ( csv . DictReader ( input_file )) outputs = dict () for student in roster_list : ( username , domain ) = student [ 'Email Address' ] . split ( '@' ) if domain != self . domain : username = student [ 'Email Address' ] sid = student [ 'Student ID' ] name = student [ 'Name' ] student [ 'name' ] = name student [ 'sid' ] = sid student [ 'username' ] = username outputs [ username ] = Student ( ident = username , name = name , username = username , student_id = sid , student_data = student ) return outputs student_seed ( self , student_obj ) inherited \u00b6 Source code in exam_gen/classroom/rosters.py def student_seed ( self , student_obj ): \"\"\" \"\"\" return stable_hash ( student_obj . ident , student_obj . name , student_obj . username ) tweak_entry ( self , student_id , student_obj , tweak_entry ) inherited \u00b6 Modifies a single student entry with whatever tweak data is provided. Source code in exam_gen/classroom/rosters.py def tweak_entry ( self , student_id , student_obj , tweak_entry ): \"\"\" Modifies a single student entry with whatever tweak data is provided. \"\"\" if 'root_seed' in tweak_entry : student_obj . root_seed = tweak_entry [ 'root_seed' ] if 'name' in tweak_entry : student_obj . name = tweak_entry [ 'name' ] if 'username' in tweak_entry : student_obj . username = tweak_entry [ 'username' ] student_obj . student_data |= tweak_entry return student_obj Roster \u00b6 __init__ ( self , file_name , exam , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , tweaks = NOTHING ) special \u00b6 Method generated by attrs for class Roster. Source code in exam_gen/classroom/rosters.py def __init__ ( self , file_name , exam , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , tweaks = NOTHING ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . file_name = file_name self . exam = exam if tweaks is not NOTHING : self . tweaks = tweaks else : self . tweaks = __attr_factory_tweaks () self . students = __attr_factory_students () self . __attrs_post_init__ () load_roster ( self ) \u00b6 Source code in exam_gen/classroom/rosters.py def load_roster ( self ): file_name = self . lookup_file ( self . file_name ) base_roster = self . read_roster ( file_name ) for ( ident , student ) in base_roster . items (): if ident in self . tweaks : student = self . tweak_entry ( ident , student , self . tweaks [ ident ]) if student . root_seed == None : student . root_seed = self . student_seed ( student ) self . students [ ident ] = student return self . students lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/classroom/rosters.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) read_roster ( self , file_name ) \u00b6 Read in the roster file and produce a dict of students (the py object) where each key is a student ID. These must have the mandatory fields set. Source code in exam_gen/classroom/rosters.py def read_roster ( self , file_name ): \"\"\" Read in the roster file and produce a dict of students (the py object) where each key is a student ID. These must have the mandatory fields set. \"\"\" raise NotImplementedError ( \"Should be implemented in specific sub-classes of `Roster` \" \"that are format specific\" ) student_seed ( self , student_obj ) \u00b6 Source code in exam_gen/classroom/rosters.py def student_seed ( self , student_obj ): \"\"\" \"\"\" return stable_hash ( student_obj . ident , student_obj . name , student_obj . username ) tweak_entry ( self , student_id , student_obj , tweak_entry ) \u00b6 Modifies a single student entry with whatever tweak data is provided. Source code in exam_gen/classroom/rosters.py def tweak_entry ( self , student_id , student_obj , tweak_entry ): \"\"\" Modifies a single student entry with whatever tweak data is provided. \"\"\" if 'root_seed' in tweak_entry : student_obj . root_seed = tweak_entry [ 'root_seed' ] if 'name' in tweak_entry : student_obj . name = tweak_entry [ 'name' ] if 'username' in tweak_entry : student_obj . username = tweak_entry [ 'username' ] student_obj . student_data |= tweak_entry return student_obj","title":".classroom.rosters"},{"location":"api/classroom/rosters.html#exam_genclassroomrosters-classes-for-loading-and-parsing-rosters","text":"","title":"exam_gen.classroom.rosters: Classes for Loading and Parsing Rosters"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.BCoursesCSVRoster","text":"","title":"BCoursesCSVRoster"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.BCoursesCSVRoster.__init__","text":"Method generated by attrs for class BCoursesCSVRoster. Source code in exam_gen/classroom/rosters.py def __init__ ( self , file_name , exam , domain = attr_dict [ 'domain' ] . default , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , tweaks = NOTHING ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . file_name = file_name self . exam = exam if tweaks is not NOTHING : self . tweaks = tweaks else : self . tweaks = __attr_factory_tweaks () self . students = __attr_factory_students () self . domain = domain self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.BCoursesCSVRoster.load_roster","text":"Source code in exam_gen/classroom/rosters.py def load_roster ( self ): file_name = self . lookup_file ( self . file_name ) base_roster = self . read_roster ( file_name ) for ( ident , student ) in base_roster . items (): if ident in self . tweaks : student = self . tweak_entry ( ident , student , self . tweaks [ ident ]) if student . root_seed == None : student . root_seed = self . student_seed ( student ) self . students [ ident ] = student return self . students","title":"load_roster()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.BCoursesCSVRoster.lookup_file","text":"Source code in exam_gen/classroom/rosters.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.BCoursesCSVRoster.read_roster","text":"Read in the roster file and produce a dict of students (the py object) where each key is a student ID. These must have the mandatory fields set. Source code in exam_gen/classroom/rosters.py def read_roster ( self , file_name ): input_file = Path ( file_name ) . open ( mode = 'r' ) roster_list = list ( csv . DictReader ( input_file )) outputs = dict () for student in roster_list : ( username , domain ) = student [ 'Email Address' ] . split ( '@' ) if domain != self . domain : username = student [ 'Email Address' ] sid = student [ 'Student ID' ] name = student [ 'Name' ] student [ 'name' ] = name student [ 'sid' ] = sid student [ 'username' ] = username outputs [ username ] = Student ( ident = username , name = name , username = username , student_id = sid , student_data = student ) return outputs","title":"read_roster()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.BCoursesCSVRoster.student_seed","text":"Source code in exam_gen/classroom/rosters.py def student_seed ( self , student_obj ): \"\"\" \"\"\" return stable_hash ( student_obj . ident , student_obj . name , student_obj . username )","title":"student_seed()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.BCoursesCSVRoster.tweak_entry","text":"Modifies a single student entry with whatever tweak data is provided. Source code in exam_gen/classroom/rosters.py def tweak_entry ( self , student_id , student_obj , tweak_entry ): \"\"\" Modifies a single student entry with whatever tweak data is provided. \"\"\" if 'root_seed' in tweak_entry : student_obj . root_seed = tweak_entry [ 'root_seed' ] if 'name' in tweak_entry : student_obj . name = tweak_entry [ 'name' ] if 'username' in tweak_entry : student_obj . username = tweak_entry [ 'username' ] student_obj . student_data |= tweak_entry return student_obj","title":"tweak_entry()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.CanvasCSVRoster","text":"","title":"CanvasCSVRoster"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.CanvasCSVRoster.__init__","text":"Method generated by attrs for class CanvasCSVRoster. Source code in exam_gen/classroom/rosters.py def __init__ ( self , file_name , exam , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , tweaks = NOTHING , domain ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . file_name = file_name self . exam = exam if tweaks is not NOTHING : self . tweaks = tweaks else : self . tweaks = __attr_factory_tweaks () self . students = __attr_factory_students () self . domain = domain self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.CanvasCSVRoster.load_roster","text":"Source code in exam_gen/classroom/rosters.py def load_roster ( self ): file_name = self . lookup_file ( self . file_name ) base_roster = self . read_roster ( file_name ) for ( ident , student ) in base_roster . items (): if ident in self . tweaks : student = self . tweak_entry ( ident , student , self . tweaks [ ident ]) if student . root_seed == None : student . root_seed = self . student_seed ( student ) self . students [ ident ] = student return self . students","title":"load_roster()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.CanvasCSVRoster.lookup_file","text":"Source code in exam_gen/classroom/rosters.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.CanvasCSVRoster.read_roster","text":"Read in the roster file and produce a dict of students (the py object) where each key is a student ID. These must have the mandatory fields set. Source code in exam_gen/classroom/rosters.py def read_roster ( self , file_name ): input_file = Path ( file_name ) . open ( mode = 'r' ) roster_list = list ( csv . DictReader ( input_file )) outputs = dict () for student in roster_list : ( username , domain ) = student [ 'Email Address' ] . split ( '@' ) if domain != self . domain : username = student [ 'Email Address' ] sid = student [ 'Student ID' ] name = student [ 'Name' ] student [ 'name' ] = name student [ 'sid' ] = sid student [ 'username' ] = username outputs [ username ] = Student ( ident = username , name = name , username = username , student_id = sid , student_data = student ) return outputs","title":"read_roster()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.CanvasCSVRoster.student_seed","text":"Source code in exam_gen/classroom/rosters.py def student_seed ( self , student_obj ): \"\"\" \"\"\" return stable_hash ( student_obj . ident , student_obj . name , student_obj . username )","title":"student_seed()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.CanvasCSVRoster.tweak_entry","text":"Modifies a single student entry with whatever tweak data is provided. Source code in exam_gen/classroom/rosters.py def tweak_entry ( self , student_id , student_obj , tweak_entry ): \"\"\" Modifies a single student entry with whatever tweak data is provided. \"\"\" if 'root_seed' in tweak_entry : student_obj . root_seed = tweak_entry [ 'root_seed' ] if 'name' in tweak_entry : student_obj . name = tweak_entry [ 'name' ] if 'username' in tweak_entry : student_obj . username = tweak_entry [ 'username' ] student_obj . student_data |= tweak_entry return student_obj","title":"tweak_entry()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.Roster","text":"","title":"Roster"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.Roster.__init__","text":"Method generated by attrs for class Roster. Source code in exam_gen/classroom/rosters.py def __init__ ( self , file_name , exam , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , tweaks = NOTHING ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . file_name = file_name self . exam = exam if tweaks is not NOTHING : self . tweaks = tweaks else : self . tweaks = __attr_factory_tweaks () self . students = __attr_factory_students () self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.Roster.load_roster","text":"Source code in exam_gen/classroom/rosters.py def load_roster ( self ): file_name = self . lookup_file ( self . file_name ) base_roster = self . read_roster ( file_name ) for ( ident , student ) in base_roster . items (): if ident in self . tweaks : student = self . tweak_entry ( ident , student , self . tweaks [ ident ]) if student . root_seed == None : student . root_seed = self . student_seed ( student ) self . students [ ident ] = student return self . students","title":"load_roster()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.Roster.lookup_file","text":"Source code in exam_gen/classroom/rosters.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.Roster.read_roster","text":"Read in the roster file and produce a dict of students (the py object) where each key is a student ID. These must have the mandatory fields set. Source code in exam_gen/classroom/rosters.py def read_roster ( self , file_name ): \"\"\" Read in the roster file and produce a dict of students (the py object) where each key is a student ID. These must have the mandatory fields set. \"\"\" raise NotImplementedError ( \"Should be implemented in specific sub-classes of `Roster` \" \"that are format specific\" )","title":"read_roster()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.Roster.student_seed","text":"Source code in exam_gen/classroom/rosters.py def student_seed ( self , student_obj ): \"\"\" \"\"\" return stable_hash ( student_obj . ident , student_obj . name , student_obj . username )","title":"student_seed()"},{"location":"api/classroom/rosters.html#exam_gen.classroom.rosters.Roster.tweak_entry","text":"Modifies a single student entry with whatever tweak data is provided. Source code in exam_gen/classroom/rosters.py def tweak_entry ( self , student_id , student_obj , tweak_entry ): \"\"\" Modifies a single student entry with whatever tweak data is provided. \"\"\" if 'root_seed' in tweak_entry : student_obj . root_seed = tweak_entry [ 'root_seed' ] if 'name' in tweak_entry : student_obj . name = tweak_entry [ 'name' ] if 'username' in tweak_entry : student_obj . username = tweak_entry [ 'username' ] student_obj . student_data |= tweak_entry return student_obj","title":"tweak_entry()"},{"location":"api/classroom/scores.html","text":"exam_gen.classroom.scores : Classes for Loading and Parsing Scores \u00b6 Scores \u00b6 __init__ ( self , exam , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None ) special \u00b6 Method generated by attrs for class Scores. Source code in exam_gen/classroom/scores.py def __init__ ( self , exam , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . exam = exam self . __attrs_post_init__ () format_scores ( self ) \u00b6 Source code in exam_gen/classroom/scores.py def format_scores ( self ): pass load_scores ( self ) \u00b6 Source code in exam_gen/classroom/scores.py def load_scores ( self ): pass lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/classroom/scores.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) read_scores ( self ) \u00b6 Source code in exam_gen/classroom/scores.py def read_scores ( self ): raise NotImplementedError ( \"\" )","title":".classroom.scores"},{"location":"api/classroom/scores.html#exam_genclassroomscores-classes-for-loading-and-parsing-scores","text":"","title":"exam_gen.classroom.scores: Classes for Loading and Parsing Scores"},{"location":"api/classroom/scores.html#exam_gen.classroom.scores.Scores","text":"","title":"Scores"},{"location":"api/classroom/scores.html#exam_gen.classroom.scores.Scores.__init__","text":"Method generated by attrs for class Scores. Source code in exam_gen/classroom/scores.py def __init__ ( self , exam , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . exam = exam self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/classroom/scores.html#exam_gen.classroom.scores.Scores.format_scores","text":"Source code in exam_gen/classroom/scores.py def format_scores ( self ): pass","title":"format_scores()"},{"location":"api/classroom/scores.html#exam_gen.classroom.scores.Scores.load_scores","text":"Source code in exam_gen/classroom/scores.py def load_scores ( self ): pass","title":"load_scores()"},{"location":"api/classroom/scores.html#exam_gen.classroom.scores.Scores.lookup_file","text":"Source code in exam_gen/classroom/scores.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/classroom/scores.html#exam_gen.classroom.scores.Scores.read_scores","text":"Source code in exam_gen/classroom/scores.py def read_scores ( self ): raise NotImplementedError ( \"\" )","title":"read_scores()"},{"location":"api/classroom/student.html","text":"exam_gen.classroom.student : Dataclass Representing a Single Student \u00b6 Student \u00b6 __init__ ( self , ident , name , username , student_id , root_seed = None , student_data = None , answer_data = None , score_data = None , grade_data = None ) special \u00b6 Method generated by attrs for class Student. Source code in exam_gen/classroom/student.py def __init__ ( self , ident , name , username , student_id , root_seed = attr_dict [ 'root_seed' ] . default , student_data = attr_dict [ 'student_data' ] . default , answer_data = attr_dict [ 'answer_data' ] . default , score_data = attr_dict [ 'score_data' ] . default , grade_data = attr_dict [ 'grade_data' ] . default ): self . ident = ident self . name = name self . username = username self . student_id = student_id self . root_seed = root_seed self . student_data = student_data self . answer_data = answer_data self . score_data = score_data self . grade_data = grade_data","title":".classroom.student"},{"location":"api/classroom/student.html#exam_genclassroomstudent-dataclass-representing-a-single-student","text":"","title":"exam_gen.classroom.student: Dataclass Representing a Single Student"},{"location":"api/classroom/student.html#exam_gen.classroom.student.Student","text":"","title":"Student"},{"location":"api/classroom/student.html#exam_gen.classroom.student.Student.__init__","text":"Method generated by attrs for class Student. Source code in exam_gen/classroom/student.py def __init__ ( self , ident , name , username , student_id , root_seed = attr_dict [ 'root_seed' ] . default , student_data = attr_dict [ 'student_data' ] . default , answer_data = attr_dict [ 'answer_data' ] . default , score_data = attr_dict [ 'score_data' ] . default , grade_data = attr_dict [ 'grade_data' ] . default ): self . ident = ident self . name = name self . username = username self . student_id = student_id self . root_seed = root_seed self . student_data = student_data self . answer_data = answer_data self . score_data = score_data self . grade_data = grade_data","title":"__init__()"},{"location":"api/property/answerable.html","text":"exam_gen.property.answerable : Items Which Can Hold Answers \u00b6 Answerable \u00b6 questions inherited \u00b6 settings property writable \u00b6 Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . answer Settings about answers settings . answer . format An identifier string that describes how an answer should be formatted. None settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None __init__ ( self , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , parent_doc = None , template_manager = None ) special \u00b6 Method generated by attrs for class Answerable. Source code in exam_gen/property/answerable.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . _answer = attr_dict [ '_answer' ] . default self . __attrs_post_init__ () build_template_spec ( self , build_info ) \u00b6 build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/answerable.py def build_template_spec ( self , build_info ): spec = super ( Answerable , self ) . build_template_spec ( build_info ) answer = self . template_answer ( self . get_answer (), build_info ) if answer != None : spec . context [ 'answer' ] = answer return spec get_answer ( self ) \u00b6 Source code in exam_gen/property/answerable.py def get_answer ( self ): return self . _answer init_document ( self , doc_class , ** kwargs ) inherited \u00b6 Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/answerable.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj init_questions ( self ) inherited \u00b6 Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/answerable.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self ) lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/property/answerable.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) normalize_answer ( self , answer , format = None ) \u00b6 Overload this to convert answers into a single format on a per-question basis. Ideally to make future auto-grading and printing possible. Source code in exam_gen/property/answerable.py def normalize_answer ( self , answer , format = None ): \"\"\" Overload this to convert answers into a single format on a per-question basis. Ideally to make future auto-grading and printing possible. \"\"\" return answer on_children ( self , fun ) inherited \u00b6 Source code in exam_gen/property/answerable.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log root_document ( self ) inherited \u00b6 Source code in exam_gen/property/answerable.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self set_answer ( self , answer , format = None ) \u00b6 Set the answer for this document to something. Source code in exam_gen/property/answerable.py def set_answer ( self , answer , format = None ): \"\"\" Set the answer for this document to something. \"\"\" self . _answer = self . normalize_answer ( answer , format ) template_answer ( self , answer , build_info ) \u00b6 Used to turn the answer returned by normalize_answer and get_answer into a dict or string that is inserted into the template. Return none if no answer should appear in the template. Overload to change how this works. If you are looking up files that are named in the answer then consider using build_info.classroom.answers to finding the correct directory for the corresponding classroom. Source code in exam_gen/property/answerable.py def template_answer ( self , answer , build_info ): \"\"\" Used to turn the answer returned by `normalize_answer` and `get_answer` into a dict or string that is inserted into the template. Return `none` if no answer should appear in the template. Overload to change how this works. If you are looking up files that are named in the answer then consider using `build_info.classroom.answers` to finding the correct directory for the corresponding classroom. \"\"\" return answer template_spec ( self , out_file = None , build_info = None ) inherited \u00b6 Source code in exam_gen/property/answerable.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec AnswerData \u00b6 Available data about the answers for a document or sub-document __init__ ( self , * args , ** kwargs ) special \u00b6 Source code in exam_gen/property/answerable.py def __init__ ( self , * args , ** kwargs ): if len ( args ) == 1 : if isinstance ( args [ 0 ], AnswerData ): kwargs = attr . asdict ( args [ 0 ], recurse = False ) args = [] elif isinstance ( args [ 0 ], dict ) and 'children' not in kwargs : kwargs [ 'children' ] = args [ 0 ] args = list () self . __attrs_init__ ( * args , ** kwargs ) merge ( self , other ) \u00b6 Source code in exam_gen/property/answerable.py def merge ( self , other ): other = AnswerData ( other ) self . meta |= other . meta if other . answer != None : self . answer = other . answer self . format = other . format for ( name , child ) in other . children . items (): if name in self . children : self . children [ name ] = self . children [ name ] . merge ( child ) else : self . children [ name ] = AnswerData ( child ) distribute_answers ( obj , answers ) \u00b6 Takes a document and splits out all the answer information in an AnswerData to it's children. Source code in exam_gen/property/answerable.py def distribute_answers ( obj , answers ): \"\"\" Takes a document and splits out all the answer information in an `AnswerData` to it's children. \"\"\" # Check if valid if not isinstance ( obj , Document ): raise RuntimeError ( \"Can't distribute answers to non-document\" ) # for convenience allow users to pass in raw dictionaries by converting # it into an answer data, or single value. answers = AnswerData ( answers ) # Copy out basic answers if isinstance ( obj , Answerable ): if answers . answer != None : obj . set_answer ( answers . answer ) if answers . format != None : obj . settings . answer . format = answers . format elif answers . answer != None : raise RuntimeError ( \"Trying to set answer on non-answerable doc.\" ) # apply to children for ( name , sub_q ) in obj . questions . items (): if name in answers . children : distribute_answers ( sub_q , answers . children [ name ]) # get extra keys and throw error if any extra = [ k for k in answers . children . keys () if k not in obj . questions ] if len ( extra ) != 0 : raise RuntimeError ( \"Tried to supply answers for non-existent children : \" . format ( extra ))","title":".property.answerable"},{"location":"api/property/answerable.html#exam_genpropertyanswerable-items-which-can-hold-answers","text":"","title":"exam_gen.property.answerable: Items Which Can Hold Answers"},{"location":"api/property/answerable.html#exam_gen.property.answerable.Answerable","text":"","title":"Answerable"},{"location":"api/property/answerable.html#exam_gen.property.answerable.Answerable.questions","text":"","title":"questions"},{"location":"api/property/answerable.html#exam_gen.property.answerable.Answerable.settings","text":"Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . answer Settings about answers settings . answer . format An identifier string that describes how an answer should be formatted. None settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None","title":"settings"},{"location":"api/property/answerable.html#exam_gen.property.answerable.Answerable.__init__","text":"Method generated by attrs for class Answerable. Source code in exam_gen/property/answerable.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . _answer = attr_dict [ '_answer' ] . default self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/property/answerable.html#exam_gen.property.answerable.Answerable.build_template_spec","text":"build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/answerable.py def build_template_spec ( self , build_info ): spec = super ( Answerable , self ) . build_template_spec ( build_info ) answer = self . template_answer ( self . get_answer (), build_info ) if answer != None : spec . context [ 'answer' ] = answer return spec","title":"build_template_spec()"},{"location":"api/property/answerable.html#exam_gen.property.answerable.Answerable.get_answer","text":"Source code in exam_gen/property/answerable.py def get_answer ( self ): return self . _answer","title":"get_answer()"},{"location":"api/property/answerable.html#exam_gen.property.answerable.Answerable.init_document","text":"Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/answerable.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj","title":"init_document()"},{"location":"api/property/answerable.html#exam_gen.property.answerable.Answerable.init_questions","text":"Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/answerable.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self )","title":"init_questions()"},{"location":"api/property/answerable.html#exam_gen.property.answerable.Answerable.lookup_file","text":"Source code in exam_gen/property/answerable.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/property/answerable.html#exam_gen.property.answerable.Answerable.normalize_answer","text":"Overload this to convert answers into a single format on a per-question basis. Ideally to make future auto-grading and printing possible. Source code in exam_gen/property/answerable.py def normalize_answer ( self , answer , format = None ): \"\"\" Overload this to convert answers into a single format on a per-question basis. Ideally to make future auto-grading and printing possible. \"\"\" return answer","title":"normalize_answer()"},{"location":"api/property/answerable.html#exam_gen.property.answerable.Answerable.on_children","text":"Source code in exam_gen/property/answerable.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log","title":"on_children()"},{"location":"api/property/answerable.html#exam_gen.property.answerable.Answerable.root_document","text":"Source code in exam_gen/property/answerable.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self","title":"root_document()"},{"location":"api/property/answerable.html#exam_gen.property.answerable.Answerable.set_answer","text":"Set the answer for this document to something. Source code in exam_gen/property/answerable.py def set_answer ( self , answer , format = None ): \"\"\" Set the answer for this document to something. \"\"\" self . _answer = self . normalize_answer ( answer , format )","title":"set_answer()"},{"location":"api/property/answerable.html#exam_gen.property.answerable.Answerable.template_answer","text":"Used to turn the answer returned by normalize_answer and get_answer into a dict or string that is inserted into the template. Return none if no answer should appear in the template. Overload to change how this works. If you are looking up files that are named in the answer then consider using build_info.classroom.answers to finding the correct directory for the corresponding classroom. Source code in exam_gen/property/answerable.py def template_answer ( self , answer , build_info ): \"\"\" Used to turn the answer returned by `normalize_answer` and `get_answer` into a dict or string that is inserted into the template. Return `none` if no answer should appear in the template. Overload to change how this works. If you are looking up files that are named in the answer then consider using `build_info.classroom.answers` to finding the correct directory for the corresponding classroom. \"\"\" return answer","title":"template_answer()"},{"location":"api/property/answerable.html#exam_gen.property.answerable.Answerable.template_spec","text":"Source code in exam_gen/property/answerable.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec","title":"template_spec()"},{"location":"api/property/answerable.html#exam_gen.property.answerable.AnswerData","text":"Available data about the answers for a document or sub-document","title":"AnswerData"},{"location":"api/property/answerable.html#exam_gen.property.answerable.AnswerData.__init__","text":"Source code in exam_gen/property/answerable.py def __init__ ( self , * args , ** kwargs ): if len ( args ) == 1 : if isinstance ( args [ 0 ], AnswerData ): kwargs = attr . asdict ( args [ 0 ], recurse = False ) args = [] elif isinstance ( args [ 0 ], dict ) and 'children' not in kwargs : kwargs [ 'children' ] = args [ 0 ] args = list () self . __attrs_init__ ( * args , ** kwargs )","title":"__init__()"},{"location":"api/property/answerable.html#exam_gen.property.answerable.AnswerData.merge","text":"Source code in exam_gen/property/answerable.py def merge ( self , other ): other = AnswerData ( other ) self . meta |= other . meta if other . answer != None : self . answer = other . answer self . format = other . format for ( name , child ) in other . children . items (): if name in self . children : self . children [ name ] = self . children [ name ] . merge ( child ) else : self . children [ name ] = AnswerData ( child )","title":"merge()"},{"location":"api/property/answerable.html#exam_gen.property.answerable.distribute_answers","text":"Takes a document and splits out all the answer information in an AnswerData to it's children. Source code in exam_gen/property/answerable.py def distribute_answers ( obj , answers ): \"\"\" Takes a document and splits out all the answer information in an `AnswerData` to it's children. \"\"\" # Check if valid if not isinstance ( obj , Document ): raise RuntimeError ( \"Can't distribute answers to non-document\" ) # for convenience allow users to pass in raw dictionaries by converting # it into an answer data, or single value. answers = AnswerData ( answers ) # Copy out basic answers if isinstance ( obj , Answerable ): if answers . answer != None : obj . set_answer ( answers . answer ) if answers . format != None : obj . settings . answer . format = answers . format elif answers . answer != None : raise RuntimeError ( \"Trying to set answer on non-answerable doc.\" ) # apply to children for ( name , sub_q ) in obj . questions . items (): if name in answers . children : distribute_answers ( sub_q , answers . children [ name ]) # get extra keys and throw error if any extra = [ k for k in answers . children . keys () if k not in obj . questions ] if len ( extra ) != 0 : raise RuntimeError ( \"Tried to supply answers for non-existent children : \" . format ( extra ))","title":"distribute_answers()"},{"location":"api/property/auto_gradeable.html","text":"exam_gen.property.auto_gradeable : Items Which Can Be Graded Automatically \u00b6 AutoGradeable \u00b6 grade_data inherited property writable \u00b6 percent_grade inherited property readonly \u00b6 returns a grade from between 0 and 1 questions inherited \u00b6 settings property writable \u00b6 Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . answer Settings about answers settings . answer . format An identifier string that describes how an answer should be formatted. None settings . grade Settings covering how grades are managed for this problem. settings . grade . max_points The maximum number of points that can be assigned to problem 1 settings . grade . weight The weight of this problem relative to others in exam. If None , this is assumed to be the same as settings.grade.max_points . None settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None total_weight inherited property readonly \u00b6 ungraded inherited property readonly \u00b6 weighted_grade inherited property readonly \u00b6 returns a grade after weighting __init__ ( self , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , parent_doc = None , template_manager = None , weight = None ) special \u00b6 Method generated by attrs for class AutoGradeable. Source code in exam_gen/property/auto_gradeable.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default , weight = attr_dict [ '_weight' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . _grade_data = attr_dict [ '_grade_data' ] . default self . _weight = weight self . _answer = attr_dict [ '_answer' ] . default self . __attrs_post_init__ () build_template_spec ( self , build_info ) inherited \u00b6 build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/auto_gradeable.py def build_template_spec ( self , build_info ): spec = super ( Gradeable , self ) . build_template_spec ( build_info ) grade_data = collect_grades ( self ) if grade_data . percent_ungraded != 1 : spec . context [ 'grade' ] = attr . asdict ( grade_data , recurse = True ) return spec calculate_grade ( self , answer ) \u00b6 Source code in exam_gen/property/auto_gradeable.py def calculate_grade ( self , answer ): raise NotImplementedError (( \"Overload the `calculate_grade` function in any autogradable \" \"class\" )) get_answer ( self ) inherited \u00b6 Source code in exam_gen/property/auto_gradeable.py def get_answer ( self ): return self . _answer init_document ( self , doc_class , ** kwargs ) inherited \u00b6 Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/auto_gradeable.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj init_questions ( self ) inherited \u00b6 Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/auto_gradeable.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self ) lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/property/auto_gradeable.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) normalize_answer ( self , answer , format = None ) inherited \u00b6 Overload this to convert answers into a single format on a per-question basis. Ideally to make future auto-grading and printing possible. Source code in exam_gen/property/auto_gradeable.py def normalize_answer ( self , answer , format = None ): \"\"\" Overload this to convert answers into a single format on a per-question basis. Ideally to make future auto-grading and printing possible. \"\"\" return answer on_children ( self , fun ) inherited \u00b6 Source code in exam_gen/property/auto_gradeable.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log root_document ( self ) inherited \u00b6 Source code in exam_gen/property/auto_gradeable.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self set_answer ( self , answer ) \u00b6 Set the answer for this document to something. Source code in exam_gen/property/auto_gradeable.py def set_answer ( self , answer ): super ( AutoGradeable , self ) . set_answer ( answer ) set_points ( self , points , comment = None ) \u00b6 Source code in exam_gen/property/auto_gradeable.py def set_points ( self , points , comment = None ): raise RuntimeError ( \"Don't assign a points score directly for an \" \"auto-gradable question, it will be calculated \" \"when an answer is provided.\" ) template_answer ( self , answer , build_info ) inherited \u00b6 Used to turn the answer returned by normalize_answer and get_answer into a dict or string that is inserted into the template. Return none if no answer should appear in the template. Overload to change how this works. If you are looking up files that are named in the answer then consider using build_info.classroom.answers to finding the correct directory for the corresponding classroom. Source code in exam_gen/property/auto_gradeable.py def template_answer ( self , answer , build_info ): \"\"\" Used to turn the answer returned by `normalize_answer` and `get_answer` into a dict or string that is inserted into the template. Return `none` if no answer should appear in the template. Overload to change how this works. If you are looking up files that are named in the answer then consider using `build_info.classroom.answers` to finding the correct directory for the corresponding classroom. \"\"\" return answer template_spec ( self , out_file = None , build_info = None ) inherited \u00b6 Source code in exam_gen/property/auto_gradeable.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec","title":".property.auto_gradeable"},{"location":"api/property/auto_gradeable.html#exam_genpropertyauto_gradeable-items-which-can-be-graded-automatically","text":"","title":"exam_gen.property.auto_gradeable: Items Which Can Be Graded Automatically"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable","text":"","title":"AutoGradeable"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.grade_data","text":"","title":"grade_data"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.percent_grade","text":"returns a grade from between 0 and 1","title":"percent_grade"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.questions","text":"","title":"questions"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.settings","text":"Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . answer Settings about answers settings . answer . format An identifier string that describes how an answer should be formatted. None settings . grade Settings covering how grades are managed for this problem. settings . grade . max_points The maximum number of points that can be assigned to problem 1 settings . grade . weight The weight of this problem relative to others in exam. If None , this is assumed to be the same as settings.grade.max_points . None settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None","title":"settings"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.total_weight","text":"","title":"total_weight"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.ungraded","text":"","title":"ungraded"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.weighted_grade","text":"returns a grade after weighting","title":"weighted_grade"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.__init__","text":"Method generated by attrs for class AutoGradeable. Source code in exam_gen/property/auto_gradeable.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default , weight = attr_dict [ '_weight' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . _grade_data = attr_dict [ '_grade_data' ] . default self . _weight = weight self . _answer = attr_dict [ '_answer' ] . default self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.build_template_spec","text":"build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/auto_gradeable.py def build_template_spec ( self , build_info ): spec = super ( Gradeable , self ) . build_template_spec ( build_info ) grade_data = collect_grades ( self ) if grade_data . percent_ungraded != 1 : spec . context [ 'grade' ] = attr . asdict ( grade_data , recurse = True ) return spec","title":"build_template_spec()"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.calculate_grade","text":"Source code in exam_gen/property/auto_gradeable.py def calculate_grade ( self , answer ): raise NotImplementedError (( \"Overload the `calculate_grade` function in any autogradable \" \"class\" ))","title":"calculate_grade()"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.get_answer","text":"Source code in exam_gen/property/auto_gradeable.py def get_answer ( self ): return self . _answer","title":"get_answer()"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.init_document","text":"Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/auto_gradeable.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj","title":"init_document()"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.init_questions","text":"Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/auto_gradeable.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self )","title":"init_questions()"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.lookup_file","text":"Source code in exam_gen/property/auto_gradeable.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.normalize_answer","text":"Overload this to convert answers into a single format on a per-question basis. Ideally to make future auto-grading and printing possible. Source code in exam_gen/property/auto_gradeable.py def normalize_answer ( self , answer , format = None ): \"\"\" Overload this to convert answers into a single format on a per-question basis. Ideally to make future auto-grading and printing possible. \"\"\" return answer","title":"normalize_answer()"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.on_children","text":"Source code in exam_gen/property/auto_gradeable.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log","title":"on_children()"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.root_document","text":"Source code in exam_gen/property/auto_gradeable.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self","title":"root_document()"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.set_answer","text":"Set the answer for this document to something. Source code in exam_gen/property/auto_gradeable.py def set_answer ( self , answer ): super ( AutoGradeable , self ) . set_answer ( answer )","title":"set_answer()"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.set_points","text":"Source code in exam_gen/property/auto_gradeable.py def set_points ( self , points , comment = None ): raise RuntimeError ( \"Don't assign a points score directly for an \" \"auto-gradable question, it will be calculated \" \"when an answer is provided.\" )","title":"set_points()"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.template_answer","text":"Used to turn the answer returned by normalize_answer and get_answer into a dict or string that is inserted into the template. Return none if no answer should appear in the template. Overload to change how this works. If you are looking up files that are named in the answer then consider using build_info.classroom.answers to finding the correct directory for the corresponding classroom. Source code in exam_gen/property/auto_gradeable.py def template_answer ( self , answer , build_info ): \"\"\" Used to turn the answer returned by `normalize_answer` and `get_answer` into a dict or string that is inserted into the template. Return `none` if no answer should appear in the template. Overload to change how this works. If you are looking up files that are named in the answer then consider using `build_info.classroom.answers` to finding the correct directory for the corresponding classroom. \"\"\" return answer","title":"template_answer()"},{"location":"api/property/auto_gradeable.html#exam_gen.property.auto_gradeable.AutoGradeable.template_spec","text":"Source code in exam_gen/property/auto_gradeable.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec","title":"template_spec()"},{"location":"api/property/buildable.html","text":"exam_gen.property.buildable : Items Which Fit Into The Build Process \u00b6 Buildable \u00b6 Different pieces of metadata and settings that are part of the build process. settings property writable \u00b6 Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . assets A list of static files that should be copied into the directory where we're going build each exam. Glob patterns (e.g. assets/*.png or **/test.txt ) Note This will copy files relative to the class where it's set. If you have: An Exam in proj_dir/midterm.py asking for assets/foo.txt And Question in prod_dir/q1/timer.py asking for bar.png and assets/bar.txt Then you'll get: proj_dir/assets/foo.txt copied into build_dir/assets/foo.txt proj_dir/q1/assets/bar.txt copied into build_dir/assets/bar.txt proj_dir/q1/bar.png copied into build_dir/bar.png There is no guaranteed behavior if this would result in some file being clobbered. [] settings . build Various settings that control how exams and questions are built. __init__ ( self , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None ) inherited special \u00b6 Method generated by attrs for class HasDirPath. Source code in exam_gen/property/buildable.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . __attrs_post_init__ () cleanup_build ( self , build_info ) \u00b6 Generic cleanup task for a build. Default: deletes the build directory Source code in exam_gen/property/buildable.py def cleanup_build ( self , build_info ): \"\"\" Generic cleanup task for a build. Default: deletes the build directory \"\"\" shutil . rmtree ( build_dir ) finalize_build ( self , build_info ) \u00b6 To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: Type Description (log, success) Source code in exam_gen/property/buildable.py def finalize_build ( self , build_info ): \"\"\" To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: (log, success) \"\"\" pass lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/property/buildable.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) output_build ( self , build_info ) \u00b6 Copies the files from the build directory to the output directory Options to rename them should be in build_settings. Source code in exam_gen/property/buildable.py def output_build ( self , build_info ): \"\"\" Copies the files from the build directory to the output directory Options to rename them should be in build_settings. \"\"\" pass setup_build ( self , build_info ) \u00b6 Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. Source code in exam_gen/property/buildable.py def setup_build ( self , build_info ): \"\"\" Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. \"\"\" data_dir = build_info . data_path build_dir = build_info . build_path log_data = dict () log_data [ 'files_copied' ] = list () for glob_pattern in self . settings . assets : input_files = list ( self . root_dir . glob ( glob_pattern )) log . debug ( \" \\n\\n root dir: %s \" \" \\n\\n file pattern: %s \" \" \\n\\n data_dir: %s \" \" \\n\\n build_dir: %s \" \" \\n\\n input_files: %s \" , self . root_dir , glob_pattern , data_dir , build_dir , input_files ) assert ( len ( input_files ) > 0 ), ( \"Did not find any matching file assets to copy into build \" \" directory. \\n\\n root dir: {} \\n\\n file pattern: {} \" ) . format ( self . root_dir , glob_pattern ) for in_file in input_files : rel_path = in_file . relative_to ( self . root_dir ) out_file = build_dir / rel_path log . debug ( \" \\n\\n root dir: %s \" \" \\n\\n file pattern: %s \" \" \\n\\n data_dir: %s \" \" \\n\\n build_dir: %s \" \" \\n\\n in_file: %s \" \" \\n\\n out_file: %s \" \" \\n\\n rel_path: %s \" , self . root_dir , glob_pattern , data_dir , build_dir , in_file , out_file , rel_path ) shutil . copyfile ( in_file , out_file ) log . debug ( \"Copying file from %s to %s \" , in_file , out_file ) log_data [ 'files_copied' ] . append ({ 'from' : str ( in_file ), 'to' : str ( out_file )}) return log_data # will be dumped into data file for debug","title":".property.buildable"},{"location":"api/property/buildable.html#exam_genpropertybuildable-items-which-fit-into-the-build-process","text":"","title":"exam_gen.property.buildable: Items Which Fit Into The Build Process"},{"location":"api/property/buildable.html#exam_gen.property.buildable.Buildable","text":"Different pieces of metadata and settings that are part of the build process.","title":"Buildable"},{"location":"api/property/buildable.html#exam_gen.property.buildable.Buildable.settings","text":"Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . assets A list of static files that should be copied into the directory where we're going build each exam. Glob patterns (e.g. assets/*.png or **/test.txt ) Note This will copy files relative to the class where it's set. If you have: An Exam in proj_dir/midterm.py asking for assets/foo.txt And Question in prod_dir/q1/timer.py asking for bar.png and assets/bar.txt Then you'll get: proj_dir/assets/foo.txt copied into build_dir/assets/foo.txt proj_dir/q1/assets/bar.txt copied into build_dir/assets/bar.txt proj_dir/q1/bar.png copied into build_dir/bar.png There is no guaranteed behavior if this would result in some file being clobbered. [] settings . build Various settings that control how exams and questions are built.","title":"settings"},{"location":"api/property/buildable.html#exam_gen.property.buildable.Buildable.__init__","text":"Method generated by attrs for class HasDirPath. Source code in exam_gen/property/buildable.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/property/buildable.html#exam_gen.property.buildable.Buildable.cleanup_build","text":"Generic cleanup task for a build. Default: deletes the build directory Source code in exam_gen/property/buildable.py def cleanup_build ( self , build_info ): \"\"\" Generic cleanup task for a build. Default: deletes the build directory \"\"\" shutil . rmtree ( build_dir )","title":"cleanup_build()"},{"location":"api/property/buildable.html#exam_gen.property.buildable.Buildable.finalize_build","text":"To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: Type Description (log, success) Source code in exam_gen/property/buildable.py def finalize_build ( self , build_info ): \"\"\" To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: (log, success) \"\"\" pass","title":"finalize_build()"},{"location":"api/property/buildable.html#exam_gen.property.buildable.Buildable.lookup_file","text":"Source code in exam_gen/property/buildable.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/property/buildable.html#exam_gen.property.buildable.Buildable.output_build","text":"Copies the files from the build directory to the output directory Options to rename them should be in build_settings. Source code in exam_gen/property/buildable.py def output_build ( self , build_info ): \"\"\" Copies the files from the build directory to the output directory Options to rename them should be in build_settings. \"\"\" pass","title":"output_build()"},{"location":"api/property/buildable.html#exam_gen.property.buildable.Buildable.setup_build","text":"Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. Source code in exam_gen/property/buildable.py def setup_build ( self , build_info ): \"\"\" Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. \"\"\" data_dir = build_info . data_path build_dir = build_info . build_path log_data = dict () log_data [ 'files_copied' ] = list () for glob_pattern in self . settings . assets : input_files = list ( self . root_dir . glob ( glob_pattern )) log . debug ( \" \\n\\n root dir: %s \" \" \\n\\n file pattern: %s \" \" \\n\\n data_dir: %s \" \" \\n\\n build_dir: %s \" \" \\n\\n input_files: %s \" , self . root_dir , glob_pattern , data_dir , build_dir , input_files ) assert ( len ( input_files ) > 0 ), ( \"Did not find any matching file assets to copy into build \" \" directory. \\n\\n root dir: {} \\n\\n file pattern: {} \" ) . format ( self . root_dir , glob_pattern ) for in_file in input_files : rel_path = in_file . relative_to ( self . root_dir ) out_file = build_dir / rel_path log . debug ( \" \\n\\n root dir: %s \" \" \\n\\n file pattern: %s \" \" \\n\\n data_dir: %s \" \" \\n\\n build_dir: %s \" \" \\n\\n in_file: %s \" \" \\n\\n out_file: %s \" \" \\n\\n rel_path: %s \" , self . root_dir , glob_pattern , data_dir , build_dir , in_file , out_file , rel_path ) shutil . copyfile ( in_file , out_file ) log . debug ( \"Copying file from %s to %s \" , in_file , out_file ) log_data [ 'files_copied' ] . append ({ 'from' : str ( in_file ), 'to' : str ( out_file )}) return log_data # will be dumped into data file for debug","title":"setup_build()"},{"location":"api/property/document.html","text":"exam_gen.property.document : Base Class for Exams and Questions \u00b6 Document \u00b6 Root class for exams, questions, and the like. Mainly this specifies that there's a list of questions that can be included and set for all the children. questions \u00b6 __init__ ( self , * , parent_doc = None ) special \u00b6 Method generated by attrs for class Document. Source code in exam_gen/property/document.py def __init__ ( self , * , parent_doc = attr_dict [ '_parent_doc' ] . default ): self . _parent_doc = parent_doc self . __attrs_post_init__ () init_document ( self , doc_class , ** kwargs ) \u00b6 Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/document.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj init_questions ( self ) \u00b6 Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/document.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self ) on_children ( self , fun ) \u00b6 Source code in exam_gen/property/document.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log root_document ( self ) \u00b6 Source code in exam_gen/property/document.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self","title":".property.document"},{"location":"api/property/document.html#exam_genpropertydocument-base-class-for-exams-and-questions","text":"","title":"exam_gen.property.document: Base Class for Exams and Questions"},{"location":"api/property/document.html#exam_gen.property.document.Document","text":"Root class for exams, questions, and the like. Mainly this specifies that there's a list of questions that can be included and set for all the children.","title":"Document"},{"location":"api/property/document.html#exam_gen.property.document.Document.questions","text":"","title":"questions"},{"location":"api/property/document.html#exam_gen.property.document.Document.__init__","text":"Method generated by attrs for class Document. Source code in exam_gen/property/document.py def __init__ ( self , * , parent_doc = attr_dict [ '_parent_doc' ] . default ): self . _parent_doc = parent_doc self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/property/document.html#exam_gen.property.document.Document.init_document","text":"Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/document.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj","title":"init_document()"},{"location":"api/property/document.html#exam_gen.property.document.Document.init_questions","text":"Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/document.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self )","title":"init_questions()"},{"location":"api/property/document.html#exam_gen.property.document.Document.on_children","text":"Source code in exam_gen/property/document.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log","title":"on_children()"},{"location":"api/property/document.html#exam_gen.property.document.Document.root_document","text":"Source code in exam_gen/property/document.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self","title":"root_document()"},{"location":"api/property/format.html","text":"exam_gen.property.format : Properties for Various Output Formats \u00b6 latex \u00b6 LatexDoc \u00b6 Specializes the document type for latex questions inherited \u00b6 settings property writable \u00b6 Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . assets A list of static files that should be copied into the directory where we're going build each exam. Glob patterns (e.g. assets/*.png or **/test.txt ) Note This will copy files relative to the class where it's set. If you have: An Exam in proj_dir/midterm.py asking for assets/foo.txt And Question in prod_dir/q1/timer.py asking for bar.png and assets/bar.txt Then you'll get: proj_dir/assets/foo.txt copied into build_dir/assets/foo.txt proj_dir/q1/assets/bar.txt copied into build_dir/assets/bar.txt proj_dir/q1/bar.png copied into build_dir/bar.png There is no guaranteed behavior if this would result in some file being clobbered. [] settings . build Various settings that control how exams and questions are built. settings . latex Settings specific to LaTeX output. settings . latex . command The actual command line application that will be used to build the document. 'xelatex' and 'lualatex' are some other possible options. 'pdflatex' settings . latex . header_includes The extra LaTeX code to be included in the header of the output document. Can either be a single string or a list of strings to be included in the output document. Todo: more specific examples None settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 'latex' settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. 'tex' settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None __init__ ( self , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , parent_doc = None , template_manager = None ) inherited special \u00b6 Method generated by attrs for class Templated. Source code in exam_gen/property/format/latex.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . __attrs_post_init__ () build_template_spec ( self , build_info ) \u00b6 build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/format/latex.py def build_template_spec ( self , build_info ): spec = super ( LatexDoc , self ) . build_template_spec ( build_info ) spec . context [ 'header_includes' ] = self . get_header_includes () return spec cleanup_build ( self , build_info ) inherited \u00b6 Generic cleanup task for a build. Default: deletes the build directory Source code in exam_gen/property/format/latex.py def cleanup_build ( self , build_info ): \"\"\" Generic cleanup task for a build. Default: deletes the build directory \"\"\" shutil . rmtree ( build_dir ) finalize_build ( self , build_info ) \u00b6 To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: Type Description (log, success) Source code in exam_gen/property/format/latex.py def finalize_build ( self , build_info ): if Path ( os . getcwd ()) != build_info . build_path : raise RuntimeError ( \"LatexDoc Builds must be run in build dir\" ) file_stem = self . settings . template . output tex_file = Path ( file_stem + '.' + self . settings . template . format_ext ) pdf_file = tex_file . with_suffix ( '.pdf' ) # template_spec = self.template_spec( # out_file = self.settings.build.tex_file, # **build_settings) # results = build_template_spec( # file_stem, template_spec, dict(), tex_file, data_dir) build_cmd = subprocess . run ([ self . settings . latex . command , tex_file ]) log_ = { 'tex_file' : tex_file , 'pdf_file' : pdf_file , 'build_info' : build_info , 'latex_command' : self . settings . latex . command } try : build_cmd . check_returncode () except err : log_name = \"finalize-error- {} .yaml\" . format ( file_stem ) dump_yaml ( log_ , path = ( data_dir , log_name )) raise err return log_ get_header_includes ( self ) \u00b6 Retrieves the list of all header includes for each child and self. Source code in exam_gen/property/format/latex.py def get_header_includes ( self ): \"\"\" Retrieves the list of all header includes for each child and self. \"\"\" includes = list () self_includes = self . settings . latex . header_includes if isinstance ( self_includes , str ): includes . append ( textwrap . dedent ( self_includes )) elif isinstance ( self_includes , Iterable ): for inc in self_includes : if isinstance ( inc , str ): includes . append ( textwrap . dedent ( inc )) else : raise RuntimeError ( \"Invalid entry for header includes\" ) elif self_includes == None : pass else : raise RuntimeError ( \"Invalid entry for header includes\" ) for ( q , v ) in self . questions . items (): includes += v . get_header_includes () return list ( dict . fromkeys ( includes )) init_document ( self , doc_class , ** kwargs ) inherited \u00b6 Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/format/latex.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj init_questions ( self ) inherited \u00b6 Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/format/latex.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self ) lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/property/format/latex.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) on_children ( self , fun ) inherited \u00b6 Source code in exam_gen/property/format/latex.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log output_build ( self , build_info , output_file = None ) \u00b6 Copies the files from the build directory to the output directory Options to rename them should be in build_settings. Source code in exam_gen/property/format/latex.py def output_build ( self , build_info , output_file = None ): if output_file == None : output_file = self . settings . template . output output_file = Path ( build_info . out_path , output_file ) . with_suffix ( '.pdf' ) pdf_file = Path ( build_info . build_path , self . settings . template . output ) . with_suffix ( '.pdf' ) shutil . copyfile ( pdf_file , output_file ) return { 'output_file' : output_file , 'pdf_file' : pdf_file , 'build_info' : build_info } root_document ( self ) inherited \u00b6 Source code in exam_gen/property/format/latex.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self setup_build ( self , build_info ) inherited \u00b6 Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. Source code in exam_gen/property/format/latex.py def setup_build ( self , build_info ): \"\"\" Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. \"\"\" data_dir = build_info . data_path build_dir = build_info . build_path log_data = dict () log_data [ 'files_copied' ] = list () for glob_pattern in self . settings . assets : input_files = list ( self . root_dir . glob ( glob_pattern )) log . debug ( \" \\n\\n root dir: %s \" \" \\n\\n file pattern: %s \" \" \\n\\n data_dir: %s \" \" \\n\\n build_dir: %s \" \" \\n\\n input_files: %s \" , self . root_dir , glob_pattern , data_dir , build_dir , input_files ) assert ( len ( input_files ) > 0 ), ( \"Did not find any matching file assets to copy into build \" \" directory. \\n\\n root dir: {} \\n\\n file pattern: {} \" ) . format ( self . root_dir , glob_pattern ) for in_file in input_files : rel_path = in_file . relative_to ( self . root_dir ) out_file = build_dir / rel_path log . debug ( \" \\n\\n root dir: %s \" \" \\n\\n file pattern: %s \" \" \\n\\n data_dir: %s \" \" \\n\\n build_dir: %s \" \" \\n\\n in_file: %s \" \" \\n\\n out_file: %s \" \" \\n\\n rel_path: %s \" , self . root_dir , glob_pattern , data_dir , build_dir , in_file , out_file , rel_path ) shutil . copyfile ( in_file , out_file ) log . debug ( \"Copying file from %s to %s \" , in_file , out_file ) log_data [ 'files_copied' ] . append ({ 'from' : str ( in_file ), 'to' : str ( out_file )}) return log_data # will be dumped into data file for debug template_spec ( self , out_file = None , build_info = None ) inherited \u00b6 Source code in exam_gen/property/format/latex.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec","title":".property.format"},{"location":"api/property/format.html#exam_genpropertyformat-properties-for-various-output-formats","text":"","title":"exam_gen.property.format: Properties for Various Output Formats"},{"location":"api/property/format.html#exam_gen.property.format.latex","text":"","title":"latex"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc","text":"Specializes the document type for latex","title":"LatexDoc"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc.questions","text":"","title":"questions"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc.settings","text":"Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . assets A list of static files that should be copied into the directory where we're going build each exam. Glob patterns (e.g. assets/*.png or **/test.txt ) Note This will copy files relative to the class where it's set. If you have: An Exam in proj_dir/midterm.py asking for assets/foo.txt And Question in prod_dir/q1/timer.py asking for bar.png and assets/bar.txt Then you'll get: proj_dir/assets/foo.txt copied into build_dir/assets/foo.txt proj_dir/q1/assets/bar.txt copied into build_dir/assets/bar.txt proj_dir/q1/bar.png copied into build_dir/bar.png There is no guaranteed behavior if this would result in some file being clobbered. [] settings . build Various settings that control how exams and questions are built. settings . latex Settings specific to LaTeX output. settings . latex . command The actual command line application that will be used to build the document. 'xelatex' and 'lualatex' are some other possible options. 'pdflatex' settings . latex . header_includes The extra LaTeX code to be included in the header of the output document. Can either be a single string or a list of strings to be included in the output document. Todo: more specific examples None settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 'latex' settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. 'tex' settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None","title":"settings"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc.__init__","text":"Method generated by attrs for class Templated. Source code in exam_gen/property/format/latex.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc.build_template_spec","text":"build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/format/latex.py def build_template_spec ( self , build_info ): spec = super ( LatexDoc , self ) . build_template_spec ( build_info ) spec . context [ 'header_includes' ] = self . get_header_includes () return spec","title":"build_template_spec()"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc.cleanup_build","text":"Generic cleanup task for a build. Default: deletes the build directory Source code in exam_gen/property/format/latex.py def cleanup_build ( self , build_info ): \"\"\" Generic cleanup task for a build. Default: deletes the build directory \"\"\" shutil . rmtree ( build_dir )","title":"cleanup_build()"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc.finalize_build","text":"To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: Type Description (log, success) Source code in exam_gen/property/format/latex.py def finalize_build ( self , build_info ): if Path ( os . getcwd ()) != build_info . build_path : raise RuntimeError ( \"LatexDoc Builds must be run in build dir\" ) file_stem = self . settings . template . output tex_file = Path ( file_stem + '.' + self . settings . template . format_ext ) pdf_file = tex_file . with_suffix ( '.pdf' ) # template_spec = self.template_spec( # out_file = self.settings.build.tex_file, # **build_settings) # results = build_template_spec( # file_stem, template_spec, dict(), tex_file, data_dir) build_cmd = subprocess . run ([ self . settings . latex . command , tex_file ]) log_ = { 'tex_file' : tex_file , 'pdf_file' : pdf_file , 'build_info' : build_info , 'latex_command' : self . settings . latex . command } try : build_cmd . check_returncode () except err : log_name = \"finalize-error- {} .yaml\" . format ( file_stem ) dump_yaml ( log_ , path = ( data_dir , log_name )) raise err return log_","title":"finalize_build()"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc.get_header_includes","text":"Retrieves the list of all header includes for each child and self. Source code in exam_gen/property/format/latex.py def get_header_includes ( self ): \"\"\" Retrieves the list of all header includes for each child and self. \"\"\" includes = list () self_includes = self . settings . latex . header_includes if isinstance ( self_includes , str ): includes . append ( textwrap . dedent ( self_includes )) elif isinstance ( self_includes , Iterable ): for inc in self_includes : if isinstance ( inc , str ): includes . append ( textwrap . dedent ( inc )) else : raise RuntimeError ( \"Invalid entry for header includes\" ) elif self_includes == None : pass else : raise RuntimeError ( \"Invalid entry for header includes\" ) for ( q , v ) in self . questions . items (): includes += v . get_header_includes () return list ( dict . fromkeys ( includes ))","title":"get_header_includes()"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc.init_document","text":"Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/format/latex.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj","title":"init_document()"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc.init_questions","text":"Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/format/latex.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self )","title":"init_questions()"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc.lookup_file","text":"Source code in exam_gen/property/format/latex.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc.on_children","text":"Source code in exam_gen/property/format/latex.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log","title":"on_children()"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc.output_build","text":"Copies the files from the build directory to the output directory Options to rename them should be in build_settings. Source code in exam_gen/property/format/latex.py def output_build ( self , build_info , output_file = None ): if output_file == None : output_file = self . settings . template . output output_file = Path ( build_info . out_path , output_file ) . with_suffix ( '.pdf' ) pdf_file = Path ( build_info . build_path , self . settings . template . output ) . with_suffix ( '.pdf' ) shutil . copyfile ( pdf_file , output_file ) return { 'output_file' : output_file , 'pdf_file' : pdf_file , 'build_info' : build_info }","title":"output_build()"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc.root_document","text":"Source code in exam_gen/property/format/latex.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self","title":"root_document()"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc.setup_build","text":"Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. Source code in exam_gen/property/format/latex.py def setup_build ( self , build_info ): \"\"\" Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. \"\"\" data_dir = build_info . data_path build_dir = build_info . build_path log_data = dict () log_data [ 'files_copied' ] = list () for glob_pattern in self . settings . assets : input_files = list ( self . root_dir . glob ( glob_pattern )) log . debug ( \" \\n\\n root dir: %s \" \" \\n\\n file pattern: %s \" \" \\n\\n data_dir: %s \" \" \\n\\n build_dir: %s \" \" \\n\\n input_files: %s \" , self . root_dir , glob_pattern , data_dir , build_dir , input_files ) assert ( len ( input_files ) > 0 ), ( \"Did not find any matching file assets to copy into build \" \" directory. \\n\\n root dir: {} \\n\\n file pattern: {} \" ) . format ( self . root_dir , glob_pattern ) for in_file in input_files : rel_path = in_file . relative_to ( self . root_dir ) out_file = build_dir / rel_path log . debug ( \" \\n\\n root dir: %s \" \" \\n\\n file pattern: %s \" \" \\n\\n data_dir: %s \" \" \\n\\n build_dir: %s \" \" \\n\\n in_file: %s \" \" \\n\\n out_file: %s \" \" \\n\\n rel_path: %s \" , self . root_dir , glob_pattern , data_dir , build_dir , in_file , out_file , rel_path ) shutil . copyfile ( in_file , out_file ) log . debug ( \"Copying file from %s to %s \" , in_file , out_file ) log_data [ 'files_copied' ] . append ({ 'from' : str ( in_file ), 'to' : str ( out_file )}) return log_data # will be dumped into data file for debug","title":"setup_build()"},{"location":"api/property/format.html#exam_gen.property.format.latex.LatexDoc.template_spec","text":"Source code in exam_gen/property/format/latex.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec","title":"template_spec()"},{"location":"api/property/gradeable.html","text":"exam_gen.property.gradeable : Items With Grades and Scores \u00b6 Gradeable \u00b6 grade_data property writable \u00b6 percent_grade property readonly \u00b6 returns a grade from between 0 and 1 questions inherited \u00b6 settings property writable \u00b6 Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . grade Settings covering how grades are managed for this problem. settings . grade . max_points The maximum number of points that can be assigned to problem 1 settings . grade . weight The weight of this problem relative to others in exam. If None , this is assumed to be the same as settings.grade.max_points . None settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None total_weight property readonly \u00b6 ungraded property readonly \u00b6 weighted_grade property readonly \u00b6 returns a grade after weighting __init__ ( self , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , parent_doc = None , template_manager = None , weight = None ) special \u00b6 Method generated by attrs for class Gradeable. Source code in exam_gen/property/gradeable.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default , weight = attr_dict [ '_weight' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . _grade_data = attr_dict [ '_grade_data' ] . default self . _weight = weight self . __attrs_post_init__ () build_template_spec ( self , build_info ) \u00b6 build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/gradeable.py def build_template_spec ( self , build_info ): spec = super ( Gradeable , self ) . build_template_spec ( build_info ) grade_data = collect_grades ( self ) if grade_data . percent_ungraded != 1 : spec . context [ 'grade' ] = attr . asdict ( grade_data , recurse = True ) return spec init_document ( self , doc_class , ** kwargs ) inherited \u00b6 Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/gradeable.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj init_questions ( self ) inherited \u00b6 Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/gradeable.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self ) lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/property/gradeable.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) on_children ( self , fun ) inherited \u00b6 Source code in exam_gen/property/gradeable.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log root_document ( self ) inherited \u00b6 Source code in exam_gen/property/gradeable.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self set_points ( self , points , comment = None , ** kwargs ) \u00b6 Source code in exam_gen/property/gradeable.py def set_points ( self , points , comment = None , ** kwargs ): self . _set_points ( points , comment , ** kwargs ) template_spec ( self , out_file = None , build_info = None ) inherited \u00b6 Source code in exam_gen/property/gradeable.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec GradeData \u00b6 percent_grade property readonly \u00b6 percent_ungraded property readonly \u00b6 __init__ ( self , * args , ** kwargs ) special \u00b6 Source code in exam_gen/property/gradeable.py def __init__ ( self , * args , ** kwargs ): if len ( args ) == 1 : if isinstance ( args [ 0 ], GradeData ): kwargs = attr . asdict ( args [ 0 ], recurse = False ) args = [] elif isinstance ( args [ 0 ], dict ) and 'children' not in kwargs : kwargs [ 'children' ] = args [ 0 ] args = [] if len ( args ) == 2 and 'comment' not in kwargs : kwargs [ 'comment' ] = args [ 1 ] args = [ args [ 0 ]] return self . __attrs_init__ ( * args , ** kwargs ) merge ( self , other ) \u00b6 Source code in exam_gen/property/gradeable.py def merge ( self , other ): other = GradeData ( other ) if other . grade != None : self . grade = other . grade self . comment += other . comment if other . answer : self . answer = other . answer if other . correct : self . correct = other . correct for ( name , child ) in other . children . items (): if name in self . children : self . children [ name ] = self . children [ name ] . merge ( child ) else : self . children [ name ] = child return self collect_grades ( obj ) \u00b6 Goes through a document and gathers the grade info from all the sub-elements, keeping track of grade and weight Source code in exam_gen/property/gradeable.py def collect_grades ( obj ): \"\"\" Goes through a document and gathers the grade info from all the sub-elements, keeping track of grade and weight \"\"\" grade_data = None if isinstance ( obj , Gradeable ): # Leaves have existing grades grade_data = deepcopy ( obj . grade_data ) elif isinstance ( obj , Document ): # Other documents will not grade_data = GradeData () else : raise RuntimeError ( \"Can't gather grades from non-document\" ) # Add children to the calculation if any for ( name , sub_q ) in obj . questions . items (): sub_data = collect_grades ( sub_q ) grade_data . children [ name ] = sub_data grade_data . total_weight += sub_data . total_weight grade_data . ungraded_points += sub_data . ungraded_points grade_data . weighted_points += sub_data . weighted_points return grade_data distribute_scores ( obj , grades ) \u00b6 Takes a document and splits out all the grade information in an GradeData to it's children. Source code in exam_gen/property/gradeable.py def distribute_scores ( obj , grades ): \"\"\" Takes a document and splits out all the grade information in an `GradeData` to it's children. \"\"\" # Check if valid if not isinstance ( obj , Document ): raise RuntimeError ( \"Can't distribute grades to non-document\" ) # for convinience allow the user to supply grades or points directly grades = GradeData ( grades ) # Copy out basic grades if isinstance ( obj , Gradeable ): obj . set_points ( grades . points , comment = grade . comment , answer = grade . answer , correct = grade . correct , ) elif grades . points != None : raise RuntimeError ( \"Trying to set grade on non-gradeable doc.\" ) # apply to children for ( name , sub_q ) in obj . questions . items (): if name in grades . children : distribute_grades ( sub_q , grades . children [ name ]) # get extra keys and throw error if any extra = [ k for k in grades . children . keys () if k not in obj . questions ] if len ( extra ) != 0 : raise RuntimeError ( \"Tried to supply grades for non-existent children : \" . format ( extra ))","title":".property.gradeable"},{"location":"api/property/gradeable.html#exam_genpropertygradeable-items-with-grades-and-scores","text":"","title":"exam_gen.property.gradeable: Items With Grades and Scores"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable","text":"","title":"Gradeable"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.grade_data","text":"","title":"grade_data"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.percent_grade","text":"returns a grade from between 0 and 1","title":"percent_grade"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.questions","text":"","title":"questions"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.settings","text":"Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . grade Settings covering how grades are managed for this problem. settings . grade . max_points The maximum number of points that can be assigned to problem 1 settings . grade . weight The weight of this problem relative to others in exam. If None , this is assumed to be the same as settings.grade.max_points . None settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None","title":"settings"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.total_weight","text":"","title":"total_weight"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.ungraded","text":"","title":"ungraded"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.weighted_grade","text":"returns a grade after weighting","title":"weighted_grade"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.__init__","text":"Method generated by attrs for class Gradeable. Source code in exam_gen/property/gradeable.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default , weight = attr_dict [ '_weight' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . _grade_data = attr_dict [ '_grade_data' ] . default self . _weight = weight self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.build_template_spec","text":"build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/gradeable.py def build_template_spec ( self , build_info ): spec = super ( Gradeable , self ) . build_template_spec ( build_info ) grade_data = collect_grades ( self ) if grade_data . percent_ungraded != 1 : spec . context [ 'grade' ] = attr . asdict ( grade_data , recurse = True ) return spec","title":"build_template_spec()"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.init_document","text":"Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/gradeable.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj","title":"init_document()"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.init_questions","text":"Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/gradeable.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self )","title":"init_questions()"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.lookup_file","text":"Source code in exam_gen/property/gradeable.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.on_children","text":"Source code in exam_gen/property/gradeable.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log","title":"on_children()"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.root_document","text":"Source code in exam_gen/property/gradeable.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self","title":"root_document()"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.set_points","text":"Source code in exam_gen/property/gradeable.py def set_points ( self , points , comment = None , ** kwargs ): self . _set_points ( points , comment , ** kwargs )","title":"set_points()"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.Gradeable.template_spec","text":"Source code in exam_gen/property/gradeable.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec","title":"template_spec()"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.GradeData","text":"","title":"GradeData"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.GradeData.percent_grade","text":"","title":"percent_grade"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.GradeData.percent_ungraded","text":"","title":"percent_ungraded"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.GradeData.__init__","text":"Source code in exam_gen/property/gradeable.py def __init__ ( self , * args , ** kwargs ): if len ( args ) == 1 : if isinstance ( args [ 0 ], GradeData ): kwargs = attr . asdict ( args [ 0 ], recurse = False ) args = [] elif isinstance ( args [ 0 ], dict ) and 'children' not in kwargs : kwargs [ 'children' ] = args [ 0 ] args = [] if len ( args ) == 2 and 'comment' not in kwargs : kwargs [ 'comment' ] = args [ 1 ] args = [ args [ 0 ]] return self . __attrs_init__ ( * args , ** kwargs )","title":"__init__()"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.GradeData.merge","text":"Source code in exam_gen/property/gradeable.py def merge ( self , other ): other = GradeData ( other ) if other . grade != None : self . grade = other . grade self . comment += other . comment if other . answer : self . answer = other . answer if other . correct : self . correct = other . correct for ( name , child ) in other . children . items (): if name in self . children : self . children [ name ] = self . children [ name ] . merge ( child ) else : self . children [ name ] = child return self","title":"merge()"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.collect_grades","text":"Goes through a document and gathers the grade info from all the sub-elements, keeping track of grade and weight Source code in exam_gen/property/gradeable.py def collect_grades ( obj ): \"\"\" Goes through a document and gathers the grade info from all the sub-elements, keeping track of grade and weight \"\"\" grade_data = None if isinstance ( obj , Gradeable ): # Leaves have existing grades grade_data = deepcopy ( obj . grade_data ) elif isinstance ( obj , Document ): # Other documents will not grade_data = GradeData () else : raise RuntimeError ( \"Can't gather grades from non-document\" ) # Add children to the calculation if any for ( name , sub_q ) in obj . questions . items (): sub_data = collect_grades ( sub_q ) grade_data . children [ name ] = sub_data grade_data . total_weight += sub_data . total_weight grade_data . ungraded_points += sub_data . ungraded_points grade_data . weighted_points += sub_data . weighted_points return grade_data","title":"collect_grades()"},{"location":"api/property/gradeable.html#exam_gen.property.gradeable.distribute_scores","text":"Takes a document and splits out all the grade information in an GradeData to it's children. Source code in exam_gen/property/gradeable.py def distribute_scores ( obj , grades ): \"\"\" Takes a document and splits out all the grade information in an `GradeData` to it's children. \"\"\" # Check if valid if not isinstance ( obj , Document ): raise RuntimeError ( \"Can't distribute grades to non-document\" ) # for convinience allow the user to supply grades or points directly grades = GradeData ( grades ) # Copy out basic grades if isinstance ( obj , Gradeable ): obj . set_points ( grades . points , comment = grade . comment , answer = grade . answer , correct = grade . correct , ) elif grades . points != None : raise RuntimeError ( \"Trying to set grade on non-gradeable doc.\" ) # apply to children for ( name , sub_q ) in obj . questions . items (): if name in grades . children : distribute_grades ( sub_q , grades . children [ name ]) # get extra keys and throw error if any extra = [ k for k in grades . children . keys () if k not in obj . questions ] if len ( extra ) != 0 : raise RuntimeError ( \"Tried to supply grades for non-existent children : \" . format ( extra ))","title":"distribute_scores()"},{"location":"api/property/has_context.html","text":"exam_gen.property.has_context : Items With Context Information for Templates and Children \u00b6 HasContext \u00b6 questions inherited \u00b6 settings property writable \u00b6 Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . assets A list of static files that should be copied into the directory where we're going build each exam. Glob patterns (e.g. assets/*.png or **/test.txt ) Note This will copy files relative to the class where it's set. If you have: An Exam in proj_dir/midterm.py asking for assets/foo.txt And Question in prod_dir/q1/timer.py asking for bar.png and assets/bar.txt Then you'll get: proj_dir/assets/foo.txt copied into build_dir/assets/foo.txt proj_dir/q1/assets/bar.txt copied into build_dir/assets/bar.txt proj_dir/q1/bar.png copied into build_dir/bar.png There is no guaranteed behavior if this would result in some file being clobbered. [] settings . build Various settings that control how exams and questions are built. settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None __init__ ( self , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , parent_doc = None , template_manager = None , parent_context = NOTHING ) special \u00b6 Method generated by attrs for class HasContext. Source code in exam_gen/property/has_context.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default , parent_context = NOTHING ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager if parent_context is not NOTHING : self . parent_context = parent_context else : self . parent_context = __attr_factory_parent_context () self . result_context = attr_dict [ 'result_context' ] . default self . final_context = attr_dict [ 'final_context' ] . default self . __attrs_post_init__ () build_template_spec ( self , build_info = None ) \u00b6 build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/has_context.py def build_template_spec ( self , build_info = None ): spec = super () . build_template_spec ( build_info ) # log.warning(pformat((type(self), self.final_context))) spec . context = merge_dicts ( spec . context , self . final_context ) return spec cleanup_build ( self , build_info ) inherited \u00b6 Generic cleanup task for a build. Default: deletes the build directory Source code in exam_gen/property/has_context.py def cleanup_build ( self , build_info ): \"\"\" Generic cleanup task for a build. Default: deletes the build directory \"\"\" shutil . rmtree ( build_dir ) ctxt ( self ) \u00b6 A dictionary of values returned by the user_setup functions of any parent documents. Source code in exam_gen/property/has_context.py @setup_arg def ctxt ( self ) -> dict : \"\"\" A dictionary of values returned by the `user_setup` functions of any parent documents. \"\"\" return deepcopy ( self . parent_context ) finalize_build ( self , build_info ) inherited \u00b6 To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: Type Description (log, success) Source code in exam_gen/property/has_context.py def finalize_build ( self , build_info ): \"\"\" To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: (log, success) \"\"\" pass init_document ( self , doc_class , ** kwargs ) inherited \u00b6 Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/has_context.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj init_questions ( self ) inherited \u00b6 Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/has_context.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self ) lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/property/has_context.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) on_children ( self , fun ) inherited \u00b6 Source code in exam_gen/property/has_context.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log output_build ( self , build_info ) inherited \u00b6 Copies the files from the build directory to the output directory Options to rename them should be in build_settings. Source code in exam_gen/property/has_context.py def output_build ( self , build_info ): \"\"\" Copies the files from the build directory to the output directory Options to rename them should be in build_settings. \"\"\" pass root_document ( self ) inherited \u00b6 Source code in exam_gen/property/has_context.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self setup_build ( self , build_info ) \u00b6 Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. Source code in exam_gen/property/has_context.py def setup_build ( self , build_info ): log = super ( HasContext , self ) . setup_build ( build_info ) for ( name , memb ) in self . questions . items (): memb . parent_context = deepcopy ( self . final_context ) log [ 'context' ] = self . final_context return log template_spec ( self , out_file = None , build_info = None ) inherited \u00b6 Source code in exam_gen/property/has_context.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec user_setup ( self , ctxt ) \u00b6 Override this function in your code, otherwise it won't customize stuff. Todo We need a nicer output format here, but this will do for the moment. Function Signature: py <Signature (self, ctxt: dict)> Arg Metadata: { 'ctxt' : { 'arg' : 'ctxt' , 'doc' : 'A dictionary of values returned by the `user_setup` ' 'functions of \\n ' 'any parent documents.' , 'fun' : < function HasContext . ctxt at 0x7fdee2f8e4c0 > , 'typ' : < class ' dict '>}}","title":".property.has_context"},{"location":"api/property/has_context.html#exam_genpropertyhas_context-items-with-context-information-for-templates-and-children","text":"","title":"exam_gen.property.has_context: Items With Context Information for Templates and Children"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext","text":"","title":"HasContext"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.questions","text":"","title":"questions"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.settings","text":"Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . assets A list of static files that should be copied into the directory where we're going build each exam. Glob patterns (e.g. assets/*.png or **/test.txt ) Note This will copy files relative to the class where it's set. If you have: An Exam in proj_dir/midterm.py asking for assets/foo.txt And Question in prod_dir/q1/timer.py asking for bar.png and assets/bar.txt Then you'll get: proj_dir/assets/foo.txt copied into build_dir/assets/foo.txt proj_dir/q1/assets/bar.txt copied into build_dir/assets/bar.txt proj_dir/q1/bar.png copied into build_dir/bar.png There is no guaranteed behavior if this would result in some file being clobbered. [] settings . build Various settings that control how exams and questions are built. settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None","title":"settings"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.__init__","text":"Method generated by attrs for class HasContext. Source code in exam_gen/property/has_context.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default , parent_context = NOTHING ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager if parent_context is not NOTHING : self . parent_context = parent_context else : self . parent_context = __attr_factory_parent_context () self . result_context = attr_dict [ 'result_context' ] . default self . final_context = attr_dict [ 'final_context' ] . default self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.build_template_spec","text":"build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/has_context.py def build_template_spec ( self , build_info = None ): spec = super () . build_template_spec ( build_info ) # log.warning(pformat((type(self), self.final_context))) spec . context = merge_dicts ( spec . context , self . final_context ) return spec","title":"build_template_spec()"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.cleanup_build","text":"Generic cleanup task for a build. Default: deletes the build directory Source code in exam_gen/property/has_context.py def cleanup_build ( self , build_info ): \"\"\" Generic cleanup task for a build. Default: deletes the build directory \"\"\" shutil . rmtree ( build_dir )","title":"cleanup_build()"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.ctxt","text":"A dictionary of values returned by the user_setup functions of any parent documents. Source code in exam_gen/property/has_context.py @setup_arg def ctxt ( self ) -> dict : \"\"\" A dictionary of values returned by the `user_setup` functions of any parent documents. \"\"\" return deepcopy ( self . parent_context )","title":"ctxt()"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.finalize_build","text":"To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: Type Description (log, success) Source code in exam_gen/property/has_context.py def finalize_build ( self , build_info ): \"\"\" To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: (log, success) \"\"\" pass","title":"finalize_build()"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.init_document","text":"Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/has_context.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj","title":"init_document()"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.init_questions","text":"Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/has_context.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self )","title":"init_questions()"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.lookup_file","text":"Source code in exam_gen/property/has_context.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.on_children","text":"Source code in exam_gen/property/has_context.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log","title":"on_children()"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.output_build","text":"Copies the files from the build directory to the output directory Options to rename them should be in build_settings. Source code in exam_gen/property/has_context.py def output_build ( self , build_info ): \"\"\" Copies the files from the build directory to the output directory Options to rename them should be in build_settings. \"\"\" pass","title":"output_build()"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.root_document","text":"Source code in exam_gen/property/has_context.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self","title":"root_document()"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.setup_build","text":"Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. Source code in exam_gen/property/has_context.py def setup_build ( self , build_info ): log = super ( HasContext , self ) . setup_build ( build_info ) for ( name , memb ) in self . questions . items (): memb . parent_context = deepcopy ( self . final_context ) log [ 'context' ] = self . final_context return log","title":"setup_build()"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.template_spec","text":"Source code in exam_gen/property/has_context.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec","title":"template_spec()"},{"location":"api/property/has_context.html#exam_gen.property.has_context.HasContext.user_setup","text":"Override this function in your code, otherwise it won't customize stuff. Todo We need a nicer output format here, but this will do for the moment. Function Signature: py <Signature (self, ctxt: dict)> Arg Metadata: { 'ctxt' : { 'arg' : 'ctxt' , 'doc' : 'A dictionary of values returned by the `user_setup` ' 'functions of \\n ' 'any parent documents.' , 'fun' : < function HasContext . ctxt at 0x7fdee2f8e4c0 > , 'typ' : < class ' dict '>}}","title":"user_setup()"},{"location":"api/property/has_dir_path.html","text":"exam_gen.property.has_dir_path : Items With a Well-Defined Root Directory \u00b6 HasDirPath \u00b6 Helps handle path and file lookup information esp. handling links that are written relative to a specific file or definition. Parameters: Name Type Description Default root_dir Path A path to the root directory for this object. required root_file Path The path to the root file for this object. Just used to set root_dir after the file at the end is stripped. required parent_obj HasDirPath A parent object that should have a root_dir in the same directory or a parent directory of this one. required parent_path Path A path that should be a parent of, or equal to, this object's root directory. Usually derived from parent_obj . required __init__ ( self , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None ) special \u00b6 Method generated by attrs for class HasDirPath. Source code in exam_gen/property/has_dir_path.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . __attrs_post_init__ () lookup_file ( self , filename ) \u00b6 Source code in exam_gen/property/has_dir_path.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":".property.has_dir_path"},{"location":"api/property/has_dir_path.html#exam_genpropertyhas_dir_path-items-with-a-well-defined-root-directory","text":"","title":"exam_gen.property.has_dir_path: Items With a Well-Defined Root Directory"},{"location":"api/property/has_dir_path.html#exam_gen.property.has_dir_path.HasDirPath","text":"Helps handle path and file lookup information esp. handling links that are written relative to a specific file or definition. Parameters: Name Type Description Default root_dir Path A path to the root directory for this object. required root_file Path The path to the root file for this object. Just used to set root_dir after the file at the end is stripped. required parent_obj HasDirPath A parent object that should have a root_dir in the same directory or a parent directory of this one. required parent_path Path A path that should be a parent of, or equal to, this object's root directory. Usually derived from parent_obj . required","title":"HasDirPath"},{"location":"api/property/has_dir_path.html#exam_gen.property.has_dir_path.HasDirPath.__init__","text":"Method generated by attrs for class HasDirPath. Source code in exam_gen/property/has_dir_path.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/property/has_dir_path.html#exam_gen.property.has_dir_path.HasDirPath.lookup_file","text":"Source code in exam_gen/property/has_dir_path.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/property/has_metadata.html","text":"exam_gen.property.has_metadata : Items with Metadata Fields \u00b6 HasMetadata \u00b6 metadata property writable \u00b6 A group of configuration variables and their subgroups. Only to be used within `exam_gen.mixins.config` and the class shouldn't be used outside of that. Some of the instance functions will be accessible to the user however. Attributes: members (dict): A dict of values and subgroups indexed by name. doc (str): The docstring explain what's within this group of configuration settings. ctxt (class or instance): The current evaluation context for this group. It's used to update the assignment context when values are defined or modified. root (ConfigGroup): The root of the configuration tree. If it's set to self then this instance is the root. path (list[str]): The path of attrs needed to access this config group as a list of strings. metadata Setup \u00b6 Empty configuration group variable that you can extend in subclasses as needed. These extensions will be automatically documented where possible. Creating new metadata fields. Add new values with metadata . new_value () : class SomeSubclass ( HasMetadata ): metadata . new_value ( name = \"example_var\" , default = [ \"some\" , \"example\" , \"value\" ], # defaults to `None` doc = \"\"\" Docstring for `example_var` \"\"\" , ) metadata . example_var = [ \"new\" , \"example\" , \"value\" ] Creating new metadata subgroups. Add new config subgroups with metadata . new_group () : class SomeSubclass ( HasMetadata ): metadata . new_group ( name = \"example_group\" , doc = \"\"\" Docstring for `example_group` \"\"\" , ) metadata . example_group . new_value ( \"example_var\" , 1234 , \"example_docstring\" ) metadata . example_group . example_var += 12 Warning Both new_value () and new_group() are unavailable at runtime, and can only be used in class definitions like the above. This keeps the documentation in sync with the available options and generally prevents bad practices. If you really must do this, the functions are moved to _hidden_new_value () and _hidden_new_group () during instance initialization. questions inherited \u00b6 settings property writable \u00b6 Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None __init__ ( self , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , parent_doc = None , template_manager = None ) inherited special \u00b6 Method generated by attrs for class Templated. Source code in exam_gen/property/has_metadata.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . __attrs_post_init__ () build_template_spec ( self , build_info = None ) \u00b6 build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/has_metadata.py def build_template_spec ( self , build_info = None ): spec = super ( HasMetadata , self ) . build_template_spec ( build_info ) spec . context = merge_dicts ( spec . context , self . metadata . value_dict ) return spec init_document ( self , doc_class , ** kwargs ) inherited \u00b6 Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/has_metadata.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj init_questions ( self ) inherited \u00b6 Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/has_metadata.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self ) lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/property/has_metadata.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) on_children ( self , fun ) inherited \u00b6 Source code in exam_gen/property/has_metadata.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log root_document ( self ) inherited \u00b6 Source code in exam_gen/property/has_metadata.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self template_spec ( self , out_file = None , build_info = None ) inherited \u00b6 Source code in exam_gen/property/has_metadata.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec MetadataVariable \u00b6 When you inherit from this superclass you get a metadata variable that allows you to register new metadata fields.","title":".property.has_metadata"},{"location":"api/property/has_metadata.html#exam_genpropertyhas_metadata-items-with-metadata-fields","text":"","title":"exam_gen.property.has_metadata: Items with Metadata Fields"},{"location":"api/property/has_metadata.html#exam_gen.property.has_metadata.HasMetadata","text":"","title":"HasMetadata"},{"location":"api/property/has_metadata.html#exam_gen.property.has_metadata.HasMetadata.metadata","text":"A group of configuration variables and their subgroups. Only to be used within `exam_gen.mixins.config` and the class shouldn't be used outside of that. Some of the instance functions will be accessible to the user however. Attributes: members (dict): A dict of values and subgroups indexed by name. doc (str): The docstring explain what's within this group of configuration settings. ctxt (class or instance): The current evaluation context for this group. It's used to update the assignment context when values are defined or modified. root (ConfigGroup): The root of the configuration tree. If it's set to self then this instance is the root. path (list[str]): The path of attrs needed to access this config group as a list of strings.","title":"metadata"},{"location":"api/property/has_metadata.html#exam_gen.property.has_metadata.HasMetadata.metadata--metadata-setup","text":"Empty configuration group variable that you can extend in subclasses as needed. These extensions will be automatically documented where possible. Creating new metadata fields. Add new values with metadata . new_value () : class SomeSubclass ( HasMetadata ): metadata . new_value ( name = \"example_var\" , default = [ \"some\" , \"example\" , \"value\" ], # defaults to `None` doc = \"\"\" Docstring for `example_var` \"\"\" , ) metadata . example_var = [ \"new\" , \"example\" , \"value\" ] Creating new metadata subgroups. Add new config subgroups with metadata . new_group () : class SomeSubclass ( HasMetadata ): metadata . new_group ( name = \"example_group\" , doc = \"\"\" Docstring for `example_group` \"\"\" , ) metadata . example_group . new_value ( \"example_var\" , 1234 , \"example_docstring\" ) metadata . example_group . example_var += 12 Warning Both new_value () and new_group() are unavailable at runtime, and can only be used in class definitions like the above. This keeps the documentation in sync with the available options and generally prevents bad practices. If you really must do this, the functions are moved to _hidden_new_value () and _hidden_new_group () during instance initialization.","title":"metadata Setup"},{"location":"api/property/has_metadata.html#exam_gen.property.has_metadata.HasMetadata.questions","text":"","title":"questions"},{"location":"api/property/has_metadata.html#exam_gen.property.has_metadata.HasMetadata.settings","text":"Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None","title":"settings"},{"location":"api/property/has_metadata.html#exam_gen.property.has_metadata.HasMetadata.__init__","text":"Method generated by attrs for class Templated. Source code in exam_gen/property/has_metadata.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/property/has_metadata.html#exam_gen.property.has_metadata.HasMetadata.build_template_spec","text":"build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/has_metadata.py def build_template_spec ( self , build_info = None ): spec = super ( HasMetadata , self ) . build_template_spec ( build_info ) spec . context = merge_dicts ( spec . context , self . metadata . value_dict ) return spec","title":"build_template_spec()"},{"location":"api/property/has_metadata.html#exam_gen.property.has_metadata.HasMetadata.init_document","text":"Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/has_metadata.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj","title":"init_document()"},{"location":"api/property/has_metadata.html#exam_gen.property.has_metadata.HasMetadata.init_questions","text":"Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/has_metadata.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self )","title":"init_questions()"},{"location":"api/property/has_metadata.html#exam_gen.property.has_metadata.HasMetadata.lookup_file","text":"Source code in exam_gen/property/has_metadata.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/property/has_metadata.html#exam_gen.property.has_metadata.HasMetadata.on_children","text":"Source code in exam_gen/property/has_metadata.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log","title":"on_children()"},{"location":"api/property/has_metadata.html#exam_gen.property.has_metadata.HasMetadata.root_document","text":"Source code in exam_gen/property/has_metadata.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self","title":"root_document()"},{"location":"api/property/has_metadata.html#exam_gen.property.has_metadata.HasMetadata.template_spec","text":"Source code in exam_gen/property/has_metadata.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec","title":"template_spec()"},{"location":"api/property/has_metadata.html#exam_gen.property.has_metadata.MetadataVariable","text":"When you inherit from this superclass you get a metadata variable that allows you to register new metadata fields.","title":"MetadataVariable"},{"location":"api/property/has_rng.html","text":"exam_gen.property.has_rng : Items With a Stable, Seeded, Random Number Generator \u00b6 HasRNG \u00b6 questions inherited \u00b6 settings property writable \u00b6 Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . assets A list of static files that should be copied into the directory where we're going build each exam. Glob patterns (e.g. assets/*.png or **/test.txt ) Note This will copy files relative to the class where it's set. If you have: An Exam in proj_dir/midterm.py asking for assets/foo.txt And Question in prod_dir/q1/timer.py asking for bar.png and assets/bar.txt Then you'll get: proj_dir/assets/foo.txt copied into build_dir/assets/foo.txt proj_dir/q1/assets/bar.txt copied into build_dir/assets/bar.txt proj_dir/q1/bar.png copied into build_dir/bar.png There is no guaranteed behavior if this would result in some file being clobbered. [] settings . build Various settings that control how exams and questions are built. __init__ ( self , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , parent_doc = None , root_seed = None ) special \u00b6 Method generated by attrs for class HasRNG. Source code in exam_gen/property/has_rng.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , root_seed = attr_dict [ 'root_seed' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . root_seed = root_seed self . _rng_source = attr_dict [ '_rng_source' ] . default self . __attrs_post_init__ () cleanup_build ( self , build_info ) inherited \u00b6 Generic cleanup task for a build. Default: deletes the build directory Source code in exam_gen/property/has_rng.py def cleanup_build ( self , build_info ): \"\"\" Generic cleanup task for a build. Default: deletes the build directory \"\"\" shutil . rmtree ( build_dir ) finalize_build ( self , build_info ) inherited \u00b6 To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: Type Description (log, success) Source code in exam_gen/property/has_rng.py def finalize_build ( self , build_info ): \"\"\" To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: (log, success) \"\"\" pass get_keyed_rng ( self , * keys ) \u00b6 Source code in exam_gen/property/has_rng.py def get_keyed_rng ( self , * keys ): if self . root_seed == None : self . root_seed = self . init_root_seed () return Random ( stable_hash ( self . root_seed , * keys )) init_document ( self , doc_class , ** kwargs ) inherited \u00b6 Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/has_rng.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj init_questions ( self ) inherited \u00b6 Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/has_rng.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self ) init_root_seed ( self ) \u00b6 Source code in exam_gen/property/has_rng.py def init_root_seed ( self ): from exam_gen.property.personalized import Personalized if isinstance ( self , Personalized ): return self . student . root_seed raise RuntimeError ( \"No method to get root seed\" ) lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/property/has_rng.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) on_children ( self , fun ) inherited \u00b6 Source code in exam_gen/property/has_rng.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log output_build ( self , build_info ) inherited \u00b6 Copies the files from the build directory to the output directory Options to rename them should be in build_settings. Source code in exam_gen/property/has_rng.py def output_build ( self , build_info ): \"\"\" Copies the files from the build directory to the output directory Options to rename them should be in build_settings. \"\"\" pass rng ( self ) \u00b6 A repeatable random number generator that will always produce the same sequence of outputs for any given student, exam pair. Source code in exam_gen/property/has_rng.py @setup_arg def rng ( self ) -> Random : \"\"\" A repeatable random number generator that will always produce the same sequence of outputs for any given student, exam pair. \"\"\" return self . get_keyed_rng ( 'user_setup' ) root_document ( self ) inherited \u00b6 Source code in exam_gen/property/has_rng.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self setup_build ( self , build_info ) \u00b6 Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. Source code in exam_gen/property/has_rng.py def setup_build ( self , build_info ): log = super ( HasRNG , self ) . setup_build ( build_info ) if self . root_seed == None : self . root_seed = self . init_root_seed () for ( name , memb ) in self . questions . items (): memb . root_seed = stable_hash ( self . root_seed , name ) log [ 'root_seed' ] = self . root_seed return log user_setup ( self , rng ) \u00b6 Override this function in your code, otherwise it won't customize stuff. Todo We need a nicer output format here, but this will do for the moment. Function Signature: py <Signature (self, rng: random.Random)> Arg Metadata: { 'rng' : { 'arg' : 'rng' , 'doc' : 'A repeatable random number generator that will always produce ' 'the same \\n ' 'sequence of outputs for any given student, exam pair.' , 'fun' : < function HasRNG . rng at 0x7fdee2fa3940 > , 'typ' : < class ' random . Random '>}}","title":".property.has_rng"},{"location":"api/property/has_rng.html#exam_genpropertyhas_rng-items-with-a-stable-seeded-random-number-generator","text":"","title":"exam_gen.property.has_rng: Items With a Stable, Seeded, Random Number Generator"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG","text":"","title":"HasRNG"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.questions","text":"","title":"questions"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.settings","text":"Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . assets A list of static files that should be copied into the directory where we're going build each exam. Glob patterns (e.g. assets/*.png or **/test.txt ) Note This will copy files relative to the class where it's set. If you have: An Exam in proj_dir/midterm.py asking for assets/foo.txt And Question in prod_dir/q1/timer.py asking for bar.png and assets/bar.txt Then you'll get: proj_dir/assets/foo.txt copied into build_dir/assets/foo.txt proj_dir/q1/assets/bar.txt copied into build_dir/assets/bar.txt proj_dir/q1/bar.png copied into build_dir/bar.png There is no guaranteed behavior if this would result in some file being clobbered. [] settings . build Various settings that control how exams and questions are built.","title":"settings"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.__init__","text":"Method generated by attrs for class HasRNG. Source code in exam_gen/property/has_rng.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , root_seed = attr_dict [ 'root_seed' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . root_seed = root_seed self . _rng_source = attr_dict [ '_rng_source' ] . default self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.cleanup_build","text":"Generic cleanup task for a build. Default: deletes the build directory Source code in exam_gen/property/has_rng.py def cleanup_build ( self , build_info ): \"\"\" Generic cleanup task for a build. Default: deletes the build directory \"\"\" shutil . rmtree ( build_dir )","title":"cleanup_build()"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.finalize_build","text":"To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: Type Description (log, success) Source code in exam_gen/property/has_rng.py def finalize_build ( self , build_info ): \"\"\" To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: (log, success) \"\"\" pass","title":"finalize_build()"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.get_keyed_rng","text":"Source code in exam_gen/property/has_rng.py def get_keyed_rng ( self , * keys ): if self . root_seed == None : self . root_seed = self . init_root_seed () return Random ( stable_hash ( self . root_seed , * keys ))","title":"get_keyed_rng()"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.init_document","text":"Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/has_rng.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj","title":"init_document()"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.init_questions","text":"Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/has_rng.py def init_questions ( self ): \"\"\" Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before `setup_build`. \"\"\" for ( name , question_class ) in self . questions . items (): log . debug ( \" %s \\n %s \" , type ( self ), self . questions . keys ()) self . questions [ name ] = self . init_document ( question_class , parent_doc = self )","title":"init_questions()"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.init_root_seed","text":"Source code in exam_gen/property/has_rng.py def init_root_seed ( self ): from exam_gen.property.personalized import Personalized if isinstance ( self , Personalized ): return self . student . root_seed raise RuntimeError ( \"No method to get root seed\" )","title":"init_root_seed()"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.lookup_file","text":"Source code in exam_gen/property/has_rng.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.on_children","text":"Source code in exam_gen/property/has_rng.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log","title":"on_children()"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.output_build","text":"Copies the files from the build directory to the output directory Options to rename them should be in build_settings. Source code in exam_gen/property/has_rng.py def output_build ( self , build_info ): \"\"\" Copies the files from the build directory to the output directory Options to rename them should be in build_settings. \"\"\" pass","title":"output_build()"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.rng","text":"A repeatable random number generator that will always produce the same sequence of outputs for any given student, exam pair. Source code in exam_gen/property/has_rng.py @setup_arg def rng ( self ) -> Random : \"\"\" A repeatable random number generator that will always produce the same sequence of outputs for any given student, exam pair. \"\"\" return self . get_keyed_rng ( 'user_setup' )","title":"rng()"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.root_document","text":"Source code in exam_gen/property/has_rng.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self","title":"root_document()"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.setup_build","text":"Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. Source code in exam_gen/property/has_rng.py def setup_build ( self , build_info ): log = super ( HasRNG , self ) . setup_build ( build_info ) if self . root_seed == None : self . root_seed = self . init_root_seed () for ( name , memb ) in self . questions . items (): memb . root_seed = stable_hash ( self . root_seed , name ) log [ 'root_seed' ] = self . root_seed return log","title":"setup_build()"},{"location":"api/property/has_rng.html#exam_gen.property.has_rng.HasRNG.user_setup","text":"Override this function in your code, otherwise it won't customize stuff. Todo We need a nicer output format here, but this will do for the moment. Function Signature: py <Signature (self, rng: random.Random)> Arg Metadata: { 'rng' : { 'arg' : 'rng' , 'doc' : 'A repeatable random number generator that will always produce ' 'the same \\n ' 'sequence of outputs for any given student, exam pair.' , 'fun' : < function HasRNG . rng at 0x7fdee2fa3940 > , 'typ' : < class ' random . Random '>}}","title":"user_setup()"},{"location":"api/property/has_settings.html","text":"exam_gen.property.has_settings : Items With Settings \u00b6 HasSettings \u00b6 When you inherit from this superclass you get a settings variable that allows you to register new settings variables and subgroups. These terms are then properly documented in the docstring for settings even for classes that inherit from yours.","title":".property.has_settings"},{"location":"api/property/has_settings.html#exam_genpropertyhas_settings-items-with-settings","text":"","title":"exam_gen.property.has_settings: Items With Settings"},{"location":"api/property/has_settings.html#exam_gen.property.has_settings.HasSettings","text":"When you inherit from this superclass you get a settings variable that allows you to register new settings variables and subgroups. These terms are then properly documented in the docstring for settings even for classes that inherit from yours.","title":"HasSettings"},{"location":"api/property/has_user_setup.html","text":"exam_gen.property.has_user_setup : Items With A User-Definable Setup Function \u00b6 HasUserSetup \u00b6 settings property writable \u00b6 Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . assets A list of static files that should be copied into the directory where we're going build each exam. Glob patterns (e.g. assets/*.png or **/test.txt ) Note This will copy files relative to the class where it's set. If you have: An Exam in proj_dir/midterm.py asking for assets/foo.txt And Question in prod_dir/q1/timer.py asking for bar.png and assets/bar.txt Then you'll get: proj_dir/assets/foo.txt copied into build_dir/assets/foo.txt proj_dir/q1/assets/bar.txt copied into build_dir/assets/bar.txt proj_dir/q1/bar.png copied into build_dir/bar.png There is no guaranteed behavior if this would result in some file being clobbered. [] settings . build Various settings that control how exams and questions are built. __init__ ( self , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None ) special \u00b6 Method generated by attrs for class HasUserSetup. Source code in exam_gen/property/has_user_setup.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . __attrs_post_init__ () cleanup_build ( self , build_info ) inherited \u00b6 Generic cleanup task for a build. Default: deletes the build directory Source code in exam_gen/property/has_user_setup.py def cleanup_build ( self , build_info ): \"\"\" Generic cleanup task for a build. Default: deletes the build directory \"\"\" shutil . rmtree ( build_dir ) finalize_build ( self , build_info ) inherited \u00b6 To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: Type Description (log, success) Source code in exam_gen/property/has_user_setup.py def finalize_build ( self , build_info ): \"\"\" To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: (log, success) \"\"\" pass lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/property/has_user_setup.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) output_build ( self , build_info ) inherited \u00b6 Copies the files from the build directory to the output directory Options to rename them should be in build_settings. Source code in exam_gen/property/has_user_setup.py def output_build ( self , build_info ): \"\"\" Copies the files from the build directory to the output directory Options to rename them should be in build_settings. \"\"\" pass setup_build ( self , build_info ) \u00b6 Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. Source code in exam_gen/property/has_user_setup.py def setup_build ( self , build_info ): log = super () . setup_build ( build_info ) log [ 'user_setup' ] = self . _run_user_setup () return log user_setup ( self ) \u00b6 Override this function in your code, otherwise it won't customize stuff. Todo We need a nicer output format here, but this will do for the moment. Function Signature: py <Signature (self)> Arg Metadata: {}","title":".property.has_user_setup"},{"location":"api/property/has_user_setup.html#exam_genpropertyhas_user_setup-items-with-a-user-definable-setup-function","text":"","title":"exam_gen.property.has_user_setup: Items With A User-Definable Setup Function"},{"location":"api/property/has_user_setup.html#exam_gen.property.has_user_setup.HasUserSetup","text":"","title":"HasUserSetup"},{"location":"api/property/has_user_setup.html#exam_gen.property.has_user_setup.HasUserSetup.settings","text":"Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . assets A list of static files that should be copied into the directory where we're going build each exam. Glob patterns (e.g. assets/*.png or **/test.txt ) Note This will copy files relative to the class where it's set. If you have: An Exam in proj_dir/midterm.py asking for assets/foo.txt And Question in prod_dir/q1/timer.py asking for bar.png and assets/bar.txt Then you'll get: proj_dir/assets/foo.txt copied into build_dir/assets/foo.txt proj_dir/q1/assets/bar.txt copied into build_dir/assets/bar.txt proj_dir/q1/bar.png copied into build_dir/bar.png There is no guaranteed behavior if this would result in some file being clobbered. [] settings . build Various settings that control how exams and questions are built.","title":"settings"},{"location":"api/property/has_user_setup.html#exam_gen.property.has_user_setup.HasUserSetup.__init__","text":"Method generated by attrs for class HasUserSetup. Source code in exam_gen/property/has_user_setup.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/property/has_user_setup.html#exam_gen.property.has_user_setup.HasUserSetup.cleanup_build","text":"Generic cleanup task for a build. Default: deletes the build directory Source code in exam_gen/property/has_user_setup.py def cleanup_build ( self , build_info ): \"\"\" Generic cleanup task for a build. Default: deletes the build directory \"\"\" shutil . rmtree ( build_dir )","title":"cleanup_build()"},{"location":"api/property/has_user_setup.html#exam_gen.property.has_user_setup.HasUserSetup.finalize_build","text":"To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: Type Description (log, success) Source code in exam_gen/property/has_user_setup.py def finalize_build ( self , build_info ): \"\"\" To be run once all the build subcommands are done, in order to generate the target file in the build directory. Note: This isn't run recursively on sub-documents by default. Returns: (log, success) \"\"\" pass","title":"finalize_build()"},{"location":"api/property/has_user_setup.html#exam_gen.property.has_user_setup.HasUserSetup.lookup_file","text":"Source code in exam_gen/property/has_user_setup.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/property/has_user_setup.html#exam_gen.property.has_user_setup.HasUserSetup.output_build","text":"Copies the files from the build directory to the output directory Options to rename them should be in build_settings. Source code in exam_gen/property/has_user_setup.py def output_build ( self , build_info ): \"\"\" Copies the files from the build directory to the output directory Options to rename them should be in build_settings. \"\"\" pass","title":"output_build()"},{"location":"api/property/has_user_setup.html#exam_gen.property.has_user_setup.HasUserSetup.setup_build","text":"Copies files from the source directory to the appropriate build directory. Note: This is a key override function for other classes. Source code in exam_gen/property/has_user_setup.py def setup_build ( self , build_info ): log = super () . setup_build ( build_info ) log [ 'user_setup' ] = self . _run_user_setup () return log","title":"setup_build()"},{"location":"api/property/has_user_setup.html#exam_gen.property.has_user_setup.HasUserSetup.user_setup","text":"Override this function in your code, otherwise it won't customize stuff. Todo We need a nicer output format here, but this will do for the moment. Function Signature: py <Signature (self)> Arg Metadata: {}","title":"user_setup()"},{"location":"api/property/numbered.html","text":"exam_gen.property.numbered : Items With A Nested Numbering Scheme \u00b6 Numbered \u00b6 questions inherited \u00b6 settings property writable \u00b6 Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . numbering_scheme The scheme for numbering child questions in the exam or document. Each char in the string represents a sequence to use for each sub-level of the document. 1 : Sequence of integers 1 , 2 , 3 , and so on. a : Sequence of lower-case letters in excel column order. a , b , c , ... , aa , ab , ac , etc.. A : as above but upper-case. Additionally . is a special character that tells when a period should be inserted as a separator. Also the sequence will repeat the For instance the default scheme 1a. would give us a tree like: - 1 - 2 - 2a - 2b - 2b.1 - 3 - 3a - 3a.1 - 3a.1a - 3a.1a.1 Note that this setting won't register any changes in user_setup '1a.' settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None __init__ ( self , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , parent_doc = None , template_manager = None , depth = 0 , numbering_depth = None , number = '' ) special \u00b6 Method generated by attrs for class Numbered. Source code in exam_gen/property/numbered.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default , depth = attr_dict [ '_depth' ] . default , numbering_depth = attr_dict [ '_numbering_depth' ] . default , number = attr_dict [ '_number' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . _depth = depth self . _numbering_depth = numbering_depth self . _number = number self . __attrs_post_init__ () build_template_spec ( self , build_info ) \u00b6 build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/numbered.py def build_template_spec ( self , build_info ): spec = super ( Numbered , self ) . build_template_spec ( build_info ) spec . context [ 'number' ] = self . _number spec . context [ 'nesting_depth' ] = self . _depth spec . context [ 'numbering_depth' ] = self . _numbering_depth spec . context [ 'numbering_scheme' ] = self . settings . numbering_scheme return spec init_document ( self , doc_class , ** kwargs ) inherited \u00b6 Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/numbered.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj init_questions ( self ) \u00b6 Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/numbered.py def init_questions ( self ): super ( Numbered , self ) . init_questions () if self . _parent_doc == None : self . push_numbering () lookup_file ( self , filename ) inherited \u00b6 Source code in exam_gen/property/numbered.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path )) on_children ( self , fun ) inherited \u00b6 Source code in exam_gen/property/numbered.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log push_numbering ( self ) \u00b6 Source code in exam_gen/property/numbered.py def push_numbering ( self ): if self . _numbering_depth == None or self . _numbering_depth == \"\" : self . _numbering_depth = self . settings . numbering_scheme for ( ind , ( name , question )) in enumerate ( self . questions . items ()): self . questions [ name ] . settings . numbering_scheme = ( self . settings . numbering_scheme ) self . questions [ name ] . _numbering_depth = self . _numbering_depth [ 1 :] self . questions [ name ] . _depth = self . _depth + 1 self . questions [ name ] . _number = self . _get_subq_number ( ind ) self . questions [ name ] . push_numbering () root_document ( self ) inherited \u00b6 Source code in exam_gen/property/numbered.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self template_spec ( self , out_file = None , build_info = None ) inherited \u00b6 Source code in exam_gen/property/numbered.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec","title":".property.numbered"},{"location":"api/property/numbered.html#exam_genpropertynumbered-items-with-a-nested-numbering-scheme","text":"","title":"exam_gen.property.numbered: Items With A Nested Numbering Scheme"},{"location":"api/property/numbered.html#exam_gen.property.numbered.Numbered","text":"","title":"Numbered"},{"location":"api/property/numbered.html#exam_gen.property.numbered.Numbered.questions","text":"","title":"questions"},{"location":"api/property/numbered.html#exam_gen.property.numbered.Numbered.settings","text":"Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . numbering_scheme The scheme for numbering child questions in the exam or document. Each char in the string represents a sequence to use for each sub-level of the document. 1 : Sequence of integers 1 , 2 , 3 , and so on. a : Sequence of lower-case letters in excel column order. a , b , c , ... , aa , ab , ac , etc.. A : as above but upper-case. Additionally . is a special character that tells when a period should be inserted as a separator. Also the sequence will repeat the For instance the default scheme 1a. would give us a tree like: - 1 - 2 - 2a - 2b - 2b.1 - 3 - 3a - 3a.1 - 3a.1a - 3a.1a.1 Note that this setting won't register any changes in user_setup '1a.' settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None","title":"settings"},{"location":"api/property/numbered.html#exam_gen.property.numbered.Numbered.__init__","text":"Method generated by attrs for class Numbered. Source code in exam_gen/property/numbered.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default , depth = attr_dict [ '_depth' ] . default , numbering_depth = attr_dict [ '_numbering_depth' ] . default , number = attr_dict [ '_number' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . _depth = depth self . _numbering_depth = numbering_depth self . _number = number self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/property/numbered.html#exam_gen.property.numbered.Numbered.build_template_spec","text":"build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/numbered.py def build_template_spec ( self , build_info ): spec = super ( Numbered , self ) . build_template_spec ( build_info ) spec . context [ 'number' ] = self . _number spec . context [ 'nesting_depth' ] = self . _depth spec . context [ 'numbering_depth' ] = self . _numbering_depth spec . context [ 'numbering_scheme' ] = self . settings . numbering_scheme return spec","title":"build_template_spec()"},{"location":"api/property/numbered.html#exam_gen.property.numbered.Numbered.init_document","text":"Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/numbered.py def init_document ( self , doc_class , ** kwargs ): \"\"\" Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use `super()` in a child class: ``` @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object ``` Done like this, `init_questions` will happily recurse down the tree of options. Note: unlike `setup_build`, `pwd` isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. \"\"\" doc_obj = doc_class ( ** kwargs ) doc_obj . init_questions () return doc_obj","title":"init_document()"},{"location":"api/property/numbered.html#exam_gen.property.numbered.Numbered.init_questions","text":"Just runs through all the questions in the document and initializes them as needed. Meant to be used sometime before setup_build . Source code in exam_gen/property/numbered.py def init_questions ( self ): super ( Numbered , self ) . init_questions () if self . _parent_doc == None : self . push_numbering ()","title":"init_questions()"},{"location":"api/property/numbered.html#exam_gen.property.numbered.Numbered.lookup_file","text":"Source code in exam_gen/property/numbered.py def lookup_file ( self , filename ): if Path ( self . root_dir , filename ) . exists (): return Path ( self . root_dir , filename ) elif ( self . parent_path != None and Path ( self . parent_path , filename ) . exists ()): return Path ( self . parent_path , filename ) elif ( self . parent_obj != None and issubclass ( type ( self . parent_obj ), HasDirPath )): return parent_obj . lookup_file ( filename ) else : raise RuntimeError (( \"Could not find file ' {} ' in either \" \" {} or {} \" ) . format ( filename , self . root_dir , self . parent_path ))","title":"lookup_file()"},{"location":"api/property/numbered.html#exam_gen.property.numbered.Numbered.on_children","text":"Source code in exam_gen/property/numbered.py def on_children ( self , fun ): log = dict () for ( name , question ) in self . questions . items (): log [ name ] = ( fun ( question ), question . on_children ( fun )) return log","title":"on_children()"},{"location":"api/property/numbered.html#exam_gen.property.numbered.Numbered.push_numbering","text":"Source code in exam_gen/property/numbered.py def push_numbering ( self ): if self . _numbering_depth == None or self . _numbering_depth == \"\" : self . _numbering_depth = self . settings . numbering_scheme for ( ind , ( name , question )) in enumerate ( self . questions . items ()): self . questions [ name ] . settings . numbering_scheme = ( self . settings . numbering_scheme ) self . questions [ name ] . _numbering_depth = self . _numbering_depth [ 1 :] self . questions [ name ] . _depth = self . _depth + 1 self . questions [ name ] . _number = self . _get_subq_number ( ind ) self . questions [ name ] . push_numbering ()","title":"push_numbering()"},{"location":"api/property/numbered.html#exam_gen.property.numbered.Numbered.root_document","text":"Source code in exam_gen/property/numbered.py def root_document ( self ): if self . _parent_doc != None : return self . _parent_doc . root_document () else : return self","title":"root_document()"},{"location":"api/property/numbered.html#exam_gen.property.numbered.Numbered.template_spec","text":"Source code in exam_gen/property/numbered.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec","title":"template_spec()"},{"location":"api/property/personalized.html","text":"exam_gen.property.personalized : Classes Whose Instances are Tied to Specific Students \u00b6 PersonalDoc \u00b6 Will initialize all the different subdocs with the student_id and classroom information. This expects that all the questions under a parent are also personalized. settings property writable \u00b6 Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None __init__ ( self , student , classroom , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , parent_doc = None , template_manager = None ) special \u00b6 Method generated by attrs for class PersonalDoc. Source code in exam_gen/property/personalized.py def __init__ ( self , student , classroom , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default ): self . student = student self . classroom = classroom self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . __attrs_post_init__ () build_template_spec ( self , build_info = None ) \u00b6 build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/personalized.py def build_template_spec ( self , build_info = None ): spec = super ( PersonalDoc , self ) . build_template_spec ( build_info ) spec . context [ 'student' ] = merge_dicts ( spec . context . get ( 'student' , dict ()), self . student . student_data , attr . asdict ( self . student )) return spec init_document ( self , doc_class , ** kwargs ) \u00b6 Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/personalized.py def init_document ( self , doc_class , ** kwargs ): return super ( PersonalDoc , self ) . init_document ( doc_class , student = self . student , classroom = self . classroom , ** kwargs ) Personalized \u00b6 Classes that are initialized with information on a specific student. __init__ ( self , student , classroom ) special \u00b6 Method generated by attrs for class Personalized. Source code in exam_gen/property/personalized.py def __init__ ( self , student , classroom ): self . student = student self . classroom = classroom","title":".property.personalized"},{"location":"api/property/personalized.html#exam_genpropertypersonalized-classes-whose-instances-are-tied-to-specific-students","text":"","title":"exam_gen.property.personalized: Classes Whose Instances are Tied to Specific Students"},{"location":"api/property/personalized.html#exam_gen.property.personalized.PersonalDoc","text":"Will initialize all the different subdocs with the student_id and classroom information. This expects that all the questions under a parent are also personalized.","title":"PersonalDoc"},{"location":"api/property/personalized.html#exam_gen.property.personalized.PersonalDoc.settings","text":"Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None","title":"settings"},{"location":"api/property/personalized.html#exam_gen.property.personalized.PersonalDoc.__init__","text":"Method generated by attrs for class PersonalDoc. Source code in exam_gen/property/personalized.py def __init__ ( self , student , classroom , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default ): self . student = student self . classroom = classroom self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/property/personalized.html#exam_gen.property.personalized.PersonalDoc.build_template_spec","text":"build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/personalized.py def build_template_spec ( self , build_info = None ): spec = super ( PersonalDoc , self ) . build_template_spec ( build_info ) spec . context [ 'student' ] = merge_dicts ( spec . context . get ( 'student' , dict ()), self . student . student_data , attr . asdict ( self . student )) return spec","title":"build_template_spec()"},{"location":"api/property/personalized.html#exam_gen.property.personalized.PersonalDoc.init_document","text":"Overloading this, with calls to super, allows for modification of the member class being initialized with new options. This shouldn't do much more than pass options needed at init through to child entities or propagate settings information down. Example of how you'd use super() in a child class: @classmethod def init_document(cls, doc_class, **kwargs): new_class = # modify doc_class / return new class doc_obj = super().init_document( new_class, added_arg = \"example\", **kwargs) return # modify doc_obj / return new object Done like this, init_questions will happily recurse down the tree of options. Note: unlike setup_build , pwd isn't guaranteed to be the same as the build directory so don't manipulate any files w/o an absolute path. Source code in exam_gen/property/personalized.py def init_document ( self , doc_class , ** kwargs ): return super ( PersonalDoc , self ) . init_document ( doc_class , student = self . student , classroom = self . classroom , ** kwargs )","title":"init_document()"},{"location":"api/property/personalized.html#exam_gen.property.personalized.Personalized","text":"Classes that are initialized with information on a specific student.","title":"Personalized"},{"location":"api/property/personalized.html#exam_gen.property.personalized.Personalized.__init__","text":"Method generated by attrs for class Personalized. Source code in exam_gen/property/personalized.py def __init__ ( self , student , classroom ): self . student = student self . classroom = classroom","title":"__init__()"},{"location":"api/property/templated.html","text":"exam_gen.property.templated : Items Which Can Be Rendered As A String Through Recursive Templating \u00b6 Templated \u00b6 This is for documents that have the ability to produce a template from user input that can be filled out by tools later on. settings property writable \u00b6 Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None __init__ ( self , * , root_dir = None , parent_obj = None , parent_path = None , use_class_root = True , root_file = None , parent_doc = None , template_manager = None ) special \u00b6 Method generated by attrs for class Templated. Source code in exam_gen/property/templated.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . __attrs_post_init__ () build_template_spec ( self , build_info = None ) \u00b6 build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/templated.py def build_template_spec ( self , build_info = None ): \"\"\" build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call `template_spec(name)` on subquestions, appropriately name them and so on. Note that `template_spec` makes sure that settings from this document are properly set in the `TemplateSpec` object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the `embedded` rather than the `standalone` template unless specified in `build_info.is_standalone` \"\"\" template = self . settings . template . embedded if (( build_info != None and build_info . is_standalone ) or template == None ): template = self . settings . template . standalone spec = TemplateSpec ( Path ( template )) if build_info != None : build_info = build_info . where ( is_standalone = False ) if build_info . exam_format != None : spec . context [ 'format' ] = build_info . exam_format spec . subtemplates [ 'questions' ] = dict () for ( ind , ( name , qn )) in enumerate ( self . questions . items ()): spec . subtemplates [ 'questions' ][ name ] = qn . template_spec ( build_info = build_info ) spec . subtemplates [ 'questions' ][ name ] . context [ 'index' ] = ind return spec template_spec ( self , out_file = None , build_info = None ) \u00b6 Source code in exam_gen/property/templated.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec TemplateSpec \u00b6 A specification for how to build a template. __init__ ( self , template , * , context = NOTHING , subtemplates = NOTHING , path = NOTHING , format_dir = None , format_ext = None , post_render_hook = None ) special \u00b6 Method generated by attrs for class TemplateSpec. Source code in exam_gen/property/templated.py def __init__ ( self , template , * , context = NOTHING , subtemplates = NOTHING , path = NOTHING , format_dir = attr_dict [ 'format_dir' ] . default , format_ext = attr_dict [ 'format_ext' ] . default , post_render_hook = attr_dict [ 'post_render_hook' ] . default ): self . template = template if context is not NOTHING : self . context = context else : self . context = __attr_factory_context () if subtemplates is not NOTHING : self . subtemplates = subtemplates else : self . subtemplates = __attr_factory_subtemplates () if path is not NOTHING : self . path = path else : self . path = __attr_factory_path () self . format_dir = format_dir self . format_ext = format_ext self . out_file = attr_dict [ 'out_file' ] . default self . jinja_opts = __attr_factory_jinja_opts () self . post_render_hook = post_render_hook add_template_var ( name , format_list = [], doc = None ) \u00b6 Source code in exam_gen/property/templated.py def add_template_var ( name , format_list = [], doc = None ): key_func = functools . partial ( exam_format_key_func , format_list = format_list ) return add_versioned_option ( name = name , option_spec = __template_versioned_opts__ , doc = doc , format_spec = [{ 'key_func' : key_func }] ) build_subtemplates ( spec , name , sub , subname , ctxt , debug ) \u00b6 Properly handle lists and dicts of subtemplates, allowing for better management of subquestions. Esp. not requiring templates to know what all the various sub-questions are called. Source code in exam_gen/property/templated.py def build_subtemplates ( spec , name , sub , subname , ctxt , debug ): \"\"\" Properly handle lists and dicts of subtemplates, allowing for better management of subquestions. Esp. not requiring templates to know what all the various sub-questions are called. \"\"\" entries = None output = None if isinstance ( sub , list ): entries = list ( enumerate ( sub )) output = [ None ] * len ( entries ) elif isinstance ( sub , dict ): entries = sub . items () output = dict () else : new_name = \" {} - {} \" . format ( name , subname ) sub . path = spec . path + sub . path if sub . format_dir == None : sub . format_dir = spec . format_dir if sub . format_ext == None : sub . format_ext = spec . format_ext # make a new outfile for the subtemplate if none exists if spec . out_file != None and sub . out_file == None : pat = Path ( spec . out_file ) ext = \"\" . join ( pat . suffixes ) suff = \".\" + sub . format_ext if sub . format_ext else ext pat = pat . with_stem ( new_name ) . with_suffix ( suff ) sub . out_file = pat return build_template_spec ( name = new_name , spec = sub , ctxt = ctxt , debug_dir = debug ) for ( keyname , subspec ) in entries : # log.warning((keyname, subspec)) output [ keyname ] = build_subtemplates ( spec = spec , name = name , sub = subspec , subname = \" {} [ {} ]\" . format ( subname , keyname ), ctxt = ctxt , debug = debug ) return output build_template_spec ( name , spec , ctxt = None , out_file = None , debug_dir = None ) \u00b6 Source code in exam_gen/property/templated.py def build_template_spec ( name , spec , ctxt = None , out_file = None , debug_dir = None ): if ctxt == None : ctxt = dict () template_file = None template_str = None # Figure out whether our template is a file or string. if spec . template == None : raise RuntimeError ( \"Template spec has no template given\" ) elif isinstance ( spec . template , Path ): template_file = spec . template else : template_str = textwrap . dedent ( spec . template ) . strip () # build out jinja template env environment = Environment ( ** spec . jinja_opts ) template = None # Retrieve the file from our loader if needed. file_name = None if template_str == None : # get our final path, after including all the format specs dir_path = list () for entry in spec . path : dir_path . append ( entry ) if spec . format_dir != None : dir_path . append ( str ( Path ( entry , spec . format_dir ))) # build our loader loader_list = [ FileSystemLoader ( dir_path )] if spec . format_dir != None : loader_list . append ( PackageLoader ( \"exam_gen\" , \"templates/ {} \" . format ( spec . format_dir ) )) loader_list . append ( PackageLoader ( \"exam_gen\" , \"templates\" )) loader = ChoiceLoader ( loader_list ) # try getting our source w/ the format ext if spec . format_ext != None : try : file_n = \" {} . {} \" . format ( str ( template_file ), spec . format_ext ) ( template_str , _ , _ ) = loader . get_source ( environment , file_n ) template = loader . load ( environment , file_n ) template_file = file_n except TemplateNotFound : pass # and just doing it normally if template_str == None : ( template_str , _ , _ ) = loader . get_source ( environment , str ( template_file )) template = loader . load ( environment , str ( template_file )) # Otherwise just get it from the string. else : template = environment . from_string ( template_str ) # Get the path we're outputting a file to out_path = out_file if out_file else spec . out_file spec . out_file = str ( out_path ) # Get the extension we use for debug output if out_path != None : out_ext = \"\" . join ( Path ( out_path ) . suffixes ) elif spec . format_ext != None : # log.warning(out_path) out_ext = \".\" + spec . format_ext else : out_ext = \"\" # TODO: Some settings that should be moved elsewhere tmpl_pat = 'template- {} .jn2 {} ' init_context_pat = 'initial-context- {} .yaml' final_context_pat = 'final-context- {} .yaml' result_pat = 'result- {}{} ' # write out the base template if debug_dir != None : dump_str ( template_str , path = ( debug_dir , tmpl_pat . format ( name , out_ext ))) # generate new context initial_ctxt = deepcopy ( ctxt | spec . context ) # and print it out if debug_dir != None : dump_yaml ( initial_ctxt , path = ( debug_dir , init_context_pat . format ( name ))) final_ctxt = deepcopy ( initial_ctxt ) # run through all subtemplates and build them too for ( subname , subtemp ) in spec . subtemplates . items (): # log.warning((name, subname, type(subtemp))) final_ctxt [ subname ] = build_subtemplates ( spec , name , subtemp , subname , initial_ctxt , debug_dir ) # dump the context post subtemplating if debug_dir != None : dump_yaml ( final_ctxt , path = ( debug_dir , final_context_pat . format ( name ))) # actually render the template result = template . render ( ** final_ctxt ) # dump the result of this template as a debug entry if debug_dir != None : dump_str ( result , path = ( debug_dir , result_pat . format ( name , out_ext ))) return_val = { k : v for ( k , v ) in final_ctxt . items () if k not in ctxt or ctxt [ k ] != final_ctxt [ k ]} return_val [ 'text' ] = result # print the out_put if out_path != None : dump_str ( result , path = out_path ) return_val [ 'file' ] = out_path if spec . post_render_hook != None : spec . post_render_hook ( return_val ) return return_val exam_format_key_func ( self , key , format_list = []) \u00b6 Source code in exam_gen/property/templated.py def exam_format_key_func ( self , key , format_list = []): if key in format_list : return key else : raise RuntimeError ( \" {} is not a valid exam format.\" . format ( key )) template_spec_from_var ( var , versions = [], empty_okay = False ) \u00b6 Create a TemplateSpec from a template var (a VersionedOpts with the fields text , file , and ctxt ) Treats text as higher priority than file Source code in exam_gen/property/templated.py def template_spec_from_var ( var , versions = [], empty_okay = False ): \"\"\" Create a TemplateSpec from a template var (a `VersionedOpts` with the fields `text`, `file`, and `ctxt`) Treats `text` as higher priority than `file` \"\"\" # Get the version of the spec we need for this task for v in versions : var = var [ v ] # get requisite template type template = None if var . text != None : template = var . text if var . file != None : log . warning (( \"Both `file` and `text` parameters are set \" \"for template ' {} '. `text` is being used by \" \"default.\" ) . format ( var . var_name )) elif var . file != None : template = Path ( var . file ) elif empty_okay : template = \"\" else : raise RuntimeError (( \"Template Var {} has neither `text` nor `file` \" \"parameter specified.\" ) . format ( var . var_name )) # log.warning(pformat((var.var_name, var.ctxt))) return TemplateSpec ( template , context = var . ctxt )","title":".property.templated"},{"location":"api/property/templated.html#exam_genpropertytemplated-items-which-can-be-rendered-as-a-string-through-recursive-templating","text":"","title":"exam_gen.property.templated: Items Which Can Be Rendered As A String Through Recursive Templating"},{"location":"api/property/templated.html#exam_gen.property.templated.Templated","text":"This is for documents that have the ability to produce a template from user input that can be filled out by tools later on.","title":"Templated"},{"location":"api/property/templated.html#exam_gen.property.templated.Templated.settings","text":"Assorted settings that are used by this class and can be set during class initialization or runtime. Available Settings Value Name Description Default settings . template Settings for how templates should be applied by this object. settings . template . embedded The base template file that's used for this document/sub-document when it's meant to be included within another document. None settings . template . format_dir The format for this document. When not null it'll be used as a sub-folder in the search path for new templates. For instance if the format is \"latex\" and base_template is \"exam.jn2\" the template engine will search in <template_dir>/latex/exam.jn2 before <template_dir>/exam.jn2 None settings . template . format_ext The extension used by this type of document, modifies the search path of the templates. If extension is 'tex' and you're trying to find 'foo.jn2', the loader will first search for a template named 'foo.jn2.tex' then 'foo.jn2'. This stacks with the format_directory and other template search options. None settings . template . jinja_opts Init parameters for a [jinja2 environment] (https://jinja.palletsprojects.com/en/3.0.x/api/#jinja2.Environment) to be used when building this document. {} settings . template . output the body of the output file's name. If you want the build directory to write out \"output.tex\" then set this to \"output\" and settings.template.format_ext to \"tex\" 'output' settings . template . search_path The directories where templates are to be located. Can be either a single path string like \"templates\" (without trailing path seperators) or a list of path strings. These paths are relative to the file in which they are defined. For example specifying settings.template_dir = \"templates\" in question1/TimerQuestion.py will make the system look for templates in the question1/templates/ directory. Any directories specified will be added to the search path for templates. Directories specified in a Classroom will be searched before those for a Question and template directories specified in an Exam will be looked at last. [] settings . template . standalone The template to use when building this file as a standalone document. None settings . template . template_dir Convenience alias for a single-entry settings.template.search_path . This directory will be the first place that the templating engine looks for templates. None","title":"settings"},{"location":"api/property/templated.html#exam_gen.property.templated.Templated.__init__","text":"Method generated by attrs for class Templated. Source code in exam_gen/property/templated.py def __init__ ( self , * , root_dir = attr_dict [ 'root_dir' ] . default , parent_obj = attr_dict [ 'parent_obj' ] . default , parent_path = attr_dict [ 'parent_path' ] . default , use_class_root = attr_dict [ 'use_class_root' ] . default , root_file = attr_dict [ 'root_file' ] . default , parent_doc = attr_dict [ '_parent_doc' ] . default , template_manager = attr_dict [ '_template_manager' ] . default ): self . root_dir = root_dir self . parent_obj = parent_obj self . parent_path = parent_path self . use_class_root = use_class_root self . root_file = root_file self . _parent_doc = parent_doc self . _template_manager = template_manager self . __attrs_post_init__ ()","title":"__init__()"},{"location":"api/property/templated.html#exam_gen.property.templated.Templated.build_template_spec","text":"build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call template_spec(name) on subquestions, appropriately name them and so on. Note that template_spec makes sure that settings from this document are properly set in the TemplateSpec object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the embedded rather than the standalone template unless specified in build_info.is_standalone Source code in exam_gen/property/templated.py def build_template_spec ( self , build_info = None ): \"\"\" build a TemplateSpec that describes how to apply all the various templates for each object. Each superclass can augment the template spec with more information It should call `template_spec(name)` on subquestions, appropriately name them and so on. Note that `template_spec` makes sure that settings from this document are properly set in the `TemplateSpec` object. The result should be a recursive TemplateSpec that can be built in one shot by whatever is managing the build process. Note: This assumes that we're using the `embedded` rather than the `standalone` template unless specified in `build_info.is_standalone` \"\"\" template = self . settings . template . embedded if (( build_info != None and build_info . is_standalone ) or template == None ): template = self . settings . template . standalone spec = TemplateSpec ( Path ( template )) if build_info != None : build_info = build_info . where ( is_standalone = False ) if build_info . exam_format != None : spec . context [ 'format' ] = build_info . exam_format spec . subtemplates [ 'questions' ] = dict () for ( ind , ( name , qn )) in enumerate ( self . questions . items ()): spec . subtemplates [ 'questions' ][ name ] = qn . template_spec ( build_info = build_info ) spec . subtemplates [ 'questions' ][ name ] . context [ 'index' ] = ind return spec","title":"build_template_spec()"},{"location":"api/property/templated.html#exam_gen.property.templated.Templated.template_spec","text":"Source code in exam_gen/property/templated.py def template_spec ( self , out_file = None , build_info = None ): spec = self . build_template_spec ( build_info ) spec . path += self . __get_search_path () spec . jinja_opts = __jinja_default_opts__ | self . __get_jinja_opts () spec . format_dir = self . settings . template . format_dir spec . format_ext = self . settings . template . format_ext return spec","title":"template_spec()"},{"location":"api/property/templated.html#exam_gen.property.templated.TemplateSpec","text":"A specification for how to build a template.","title":"TemplateSpec"},{"location":"api/property/templated.html#exam_gen.property.templated.TemplateSpec.__init__","text":"Method generated by attrs for class TemplateSpec. Source code in exam_gen/property/templated.py def __init__ ( self , template , * , context = NOTHING , subtemplates = NOTHING , path = NOTHING , format_dir = attr_dict [ 'format_dir' ] . default , format_ext = attr_dict [ 'format_ext' ] . default , post_render_hook = attr_dict [ 'post_render_hook' ] . default ): self . template = template if context is not NOTHING : self . context = context else : self . context = __attr_factory_context () if subtemplates is not NOTHING : self . subtemplates = subtemplates else : self . subtemplates = __attr_factory_subtemplates () if path is not NOTHING : self . path = path else : self . path = __attr_factory_path () self . format_dir = format_dir self . format_ext = format_ext self . out_file = attr_dict [ 'out_file' ] . default self . jinja_opts = __attr_factory_jinja_opts () self . post_render_hook = post_render_hook","title":"__init__()"},{"location":"api/property/templated.html#exam_gen.property.templated.add_template_var","text":"Source code in exam_gen/property/templated.py def add_template_var ( name , format_list = [], doc = None ): key_func = functools . partial ( exam_format_key_func , format_list = format_list ) return add_versioned_option ( name = name , option_spec = __template_versioned_opts__ , doc = doc , format_spec = [{ 'key_func' : key_func }] )","title":"add_template_var()"},{"location":"api/property/templated.html#exam_gen.property.templated.build_subtemplates","text":"Properly handle lists and dicts of subtemplates, allowing for better management of subquestions. Esp. not requiring templates to know what all the various sub-questions are called. Source code in exam_gen/property/templated.py def build_subtemplates ( spec , name , sub , subname , ctxt , debug ): \"\"\" Properly handle lists and dicts of subtemplates, allowing for better management of subquestions. Esp. not requiring templates to know what all the various sub-questions are called. \"\"\" entries = None output = None if isinstance ( sub , list ): entries = list ( enumerate ( sub )) output = [ None ] * len ( entries ) elif isinstance ( sub , dict ): entries = sub . items () output = dict () else : new_name = \" {} - {} \" . format ( name , subname ) sub . path = spec . path + sub . path if sub . format_dir == None : sub . format_dir = spec . format_dir if sub . format_ext == None : sub . format_ext = spec . format_ext # make a new outfile for the subtemplate if none exists if spec . out_file != None and sub . out_file == None : pat = Path ( spec . out_file ) ext = \"\" . join ( pat . suffixes ) suff = \".\" + sub . format_ext if sub . format_ext else ext pat = pat . with_stem ( new_name ) . with_suffix ( suff ) sub . out_file = pat return build_template_spec ( name = new_name , spec = sub , ctxt = ctxt , debug_dir = debug ) for ( keyname , subspec ) in entries : # log.warning((keyname, subspec)) output [ keyname ] = build_subtemplates ( spec = spec , name = name , sub = subspec , subname = \" {} [ {} ]\" . format ( subname , keyname ), ctxt = ctxt , debug = debug ) return output","title":"build_subtemplates()"},{"location":"api/property/templated.html#exam_gen.property.templated.build_template_spec","text":"Source code in exam_gen/property/templated.py def build_template_spec ( name , spec , ctxt = None , out_file = None , debug_dir = None ): if ctxt == None : ctxt = dict () template_file = None template_str = None # Figure out whether our template is a file or string. if spec . template == None : raise RuntimeError ( \"Template spec has no template given\" ) elif isinstance ( spec . template , Path ): template_file = spec . template else : template_str = textwrap . dedent ( spec . template ) . strip () # build out jinja template env environment = Environment ( ** spec . jinja_opts ) template = None # Retrieve the file from our loader if needed. file_name = None if template_str == None : # get our final path, after including all the format specs dir_path = list () for entry in spec . path : dir_path . append ( entry ) if spec . format_dir != None : dir_path . append ( str ( Path ( entry , spec . format_dir ))) # build our loader loader_list = [ FileSystemLoader ( dir_path )] if spec . format_dir != None : loader_list . append ( PackageLoader ( \"exam_gen\" , \"templates/ {} \" . format ( spec . format_dir ) )) loader_list . append ( PackageLoader ( \"exam_gen\" , \"templates\" )) loader = ChoiceLoader ( loader_list ) # try getting our source w/ the format ext if spec . format_ext != None : try : file_n = \" {} . {} \" . format ( str ( template_file ), spec . format_ext ) ( template_str , _ , _ ) = loader . get_source ( environment , file_n ) template = loader . load ( environment , file_n ) template_file = file_n except TemplateNotFound : pass # and just doing it normally if template_str == None : ( template_str , _ , _ ) = loader . get_source ( environment , str ( template_file )) template = loader . load ( environment , str ( template_file )) # Otherwise just get it from the string. else : template = environment . from_string ( template_str ) # Get the path we're outputting a file to out_path = out_file if out_file else spec . out_file spec . out_file = str ( out_path ) # Get the extension we use for debug output if out_path != None : out_ext = \"\" . join ( Path ( out_path ) . suffixes ) elif spec . format_ext != None : # log.warning(out_path) out_ext = \".\" + spec . format_ext else : out_ext = \"\" # TODO: Some settings that should be moved elsewhere tmpl_pat = 'template- {} .jn2 {} ' init_context_pat = 'initial-context- {} .yaml' final_context_pat = 'final-context- {} .yaml' result_pat = 'result- {}{} ' # write out the base template if debug_dir != None : dump_str ( template_str , path = ( debug_dir , tmpl_pat . format ( name , out_ext ))) # generate new context initial_ctxt = deepcopy ( ctxt | spec . context ) # and print it out if debug_dir != None : dump_yaml ( initial_ctxt , path = ( debug_dir , init_context_pat . format ( name ))) final_ctxt = deepcopy ( initial_ctxt ) # run through all subtemplates and build them too for ( subname , subtemp ) in spec . subtemplates . items (): # log.warning((name, subname, type(subtemp))) final_ctxt [ subname ] = build_subtemplates ( spec , name , subtemp , subname , initial_ctxt , debug_dir ) # dump the context post subtemplating if debug_dir != None : dump_yaml ( final_ctxt , path = ( debug_dir , final_context_pat . format ( name ))) # actually render the template result = template . render ( ** final_ctxt ) # dump the result of this template as a debug entry if debug_dir != None : dump_str ( result , path = ( debug_dir , result_pat . format ( name , out_ext ))) return_val = { k : v for ( k , v ) in final_ctxt . items () if k not in ctxt or ctxt [ k ] != final_ctxt [ k ]} return_val [ 'text' ] = result # print the out_put if out_path != None : dump_str ( result , path = out_path ) return_val [ 'file' ] = out_path if spec . post_render_hook != None : spec . post_render_hook ( return_val ) return return_val","title":"build_template_spec()"},{"location":"api/property/templated.html#exam_gen.property.templated.exam_format_key_func","text":"Source code in exam_gen/property/templated.py def exam_format_key_func ( self , key , format_list = []): if key in format_list : return key else : raise RuntimeError ( \" {} is not a valid exam format.\" . format ( key ))","title":"exam_format_key_func()"},{"location":"api/property/templated.html#exam_gen.property.templated.template_spec_from_var","text":"Create a TemplateSpec from a template var (a VersionedOpts with the fields text , file , and ctxt ) Treats text as higher priority than file Source code in exam_gen/property/templated.py def template_spec_from_var ( var , versions = [], empty_okay = False ): \"\"\" Create a TemplateSpec from a template var (a `VersionedOpts` with the fields `text`, `file`, and `ctxt`) Treats `text` as higher priority than `file` \"\"\" # Get the version of the spec we need for this task for v in versions : var = var [ v ] # get requisite template type template = None if var . text != None : template = var . text if var . file != None : log . warning (( \"Both `file` and `text` parameters are set \" \"for template ' {} '. `text` is being used by \" \"default.\" ) . format ( var . var_name )) elif var . file != None : template = Path ( var . file ) elif empty_okay : template = \"\" else : raise RuntimeError (( \"Template Var {} has neither `text` nor `file` \" \"parameter specified.\" ) . format ( var . var_name )) # log.warning(pformat((var.var_name, var.ctxt))) return TemplateSpec ( template , context = var . ctxt )","title":"template_spec_from_var()"},{"location":"api/util/selectors.html","text":"exam_gen.util.selectors : Classes to help associate record fields with students and exams. \u00b6 document \u00b6 log \u00b6 DocSelect \u00b6 Associates record fields with documents and sub-documents __attrs_init__ ( self , mapping , selector =< class ' exam_gen . util . selectors . field . FieldSelect '>, norm_field=<function DocSelect.<lambda> at 0x7fdee305f820>) special \u00b6 Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __attrs_init__ ( self , mapping , selector = attr_dict [ 'selector' ] . default , norm_field = attr_dict [ 'norm_field' ] . default ): self . mapping = mapping self . selector = selector self . norm_field = norm_field self . __attrs_post_init__ () __attrs_post_init__ ( self ) special \u00b6 Source code in exam_gen/util/selectors/document.py def __attrs_post_init__ ( self ): _mapping = dict () for ( k , v ) in self . mapping . items (): ( field , meta ) = self . norm_field ( v ) _mapping [ k ] = ( self . norm_map_entry ( field ), meta ) self . mapping = _mapping __eq__ ( self , other ) special \u00b6 Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __eq__ ( self , other ): if other . __class__ is not self . __class__ : return NotImplemented return ( self . mapping , self . selector , self . norm_field , ) == ( other . mapping , other . selector , other . norm_field , ) __ge__ ( self , other ) special \u00b6 Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __ge__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) >= attrs_to_tuple ( other ) return NotImplemented __gt__ ( self , other ) special \u00b6 Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __gt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) > attrs_to_tuple ( other ) return NotImplemented __init__ ( self , * args , ** kwargs ) special \u00b6 Sorta idempotent normalised new. Source code in exam_gen/util/selectors/document.py def __init__ ( self , * args , ** kwargs ): \"\"\" Sorta idempotent normalised new. \"\"\" if len ( args ) == 0 and len ( kwargs ) >= 0 and 'mapping' not in kwargs : _kwargs = dict () for k in [ 'selector' , 'norm_field' ]: if k in kwargs : _kwargs [ k ] = kwargs . pop ( k ) kwargs = { 'mapping' : kwargs } | _kwargs self . __attrs_init__ ( * args , ** kwargs ) __le__ ( self , other ) special \u00b6 Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __le__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) <= attrs_to_tuple ( other ) return NotImplemented __lt__ ( self , other ) special \u00b6 Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __lt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) < attrs_to_tuple ( other ) return NotImplemented __ne__ ( self , other ) special \u00b6 Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __ne__ ( self , other ): \"\"\" Check equality and either forward a NotImplemented or return the result negated. \"\"\" result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result __new__ ( cls , * args , ** kwargs ) special staticmethod \u00b6 Sorta idempotent normalised new. Source code in exam_gen/util/selectors/document.py def __new__ ( cls , * args , ** kwargs ): \"\"\" Sorta idempotent normalised new. \"\"\" if len ( args ) == 1 and len ( kwargs ) == 0 : if isinstance ( args [ 0 ], DocSelect ): return args [ 0 ] return super ( DocSelect , cls ) . __new__ ( cls ) __repr__ ( self ) special \u00b6 Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __repr__ ( self ): \"\"\" Automatically created by attrs. \"\"\" try : working_set = _already_repring . working_set except AttributeError : working_set = set () _already_repring . working_set = working_set if id ( self ) in working_set : return \"...\" real_cls = self . __class__ if ns is None : qualname = getattr ( real_cls , \"__qualname__\" , None ) if qualname is not None : class_name = qualname . rsplit ( \">.\" , 1 )[ - 1 ] else : class_name = real_cls . __name__ else : class_name = ns + \".\" + real_cls . __name__ # Since 'self' remains on the stack (i.e.: strongly referenced) for the # duration of this call, it's safe to depend on id(...) stability, and # not need to track the instance and therefore worry about properties # like weakref- or hash-ability. working_set . add ( id ( self )) try : result = [ class_name , \"(\" ] first = True for name , attr_repr in attr_names_with_reprs : if first : first = False else : result . append ( \", \" ) result . extend ( ( name , \"=\" , attr_repr ( getattr ( self , name , NOTHING ))) ) return \"\" . join ( result ) + \")\" finally : working_set . remove ( id ( self )) norm_map_entry ( self , entry ) \u00b6 Source code in exam_gen/util/selectors/document.py def norm_map_entry ( self , entry ): if isinstance ( entry , DocSelect ): return entry elif isinstance ( entry , FieldSelect ): return entry elif isinstance ( entry , dict ): return type ( self )( mapping = entry , selector = self . selector , norm_field = self . norm_field ) else : return self . selector ( entry ) select ( self , record , supress_error = False , with_meta = False ) \u00b6 Given a record produce a mapped dictionary of values. Source code in exam_gen/util/selectors/document.py def select ( self , record , supress_error = False , with_meta = False ): \"\"\" Given a record produce a mapped dictionary of values. \"\"\" result = dict () # Turn with_meta into a function that will turn the (match, meta) pair # into the result we want. if not callable ( with_meta ): as_tuple = lambda f , m : ( f , m ) only_field = lambda f , m : f with_meta = as_tuple if with_meta else only_field # Go through and grab the matching fields while assembling them # properly for ( k , ( fld , meta )) in self . mapping . items (): match = fld . select ( record , supress_error ) if match != None : result [ k ] = with_meta ( match , meta ) return result field \u00b6 log \u00b6 FieldSelect \u00b6 __attrs_init__ ( self , selector , substring = True , strip_string = True , case_sensitive = False ) special \u00b6 Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __attrs_init__ ( self , selector , substring = attr_dict [ 'substring' ] . default , strip_string = attr_dict [ 'strip_string' ] . default , case_sensitive = attr_dict [ 'case_sensitive' ] . default ): self . selector = selector self . substring = substring self . strip_string = strip_string self . case_sensitive = case_sensitive __eq__ ( self , other ) special \u00b6 Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __eq__ ( self , other ): if other . __class__ is not self . __class__ : return NotImplemented return ( self . selector , self . substring , self . strip_string , self . case_sensitive , ) == ( other . selector , other . substring , other . strip_string , other . case_sensitive , ) __ge__ ( self , other ) special \u00b6 Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __ge__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) >= attrs_to_tuple ( other ) return NotImplemented __gt__ ( self , other ) special \u00b6 Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __gt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) > attrs_to_tuple ( other ) return NotImplemented __init__ ( self , * args , ** kwargs ) special \u00b6 Sorta idempotent normalised new. Source code in exam_gen/util/selectors/field.py def __init__ ( self , * args , ** kwargs ): \"\"\" Sorta idempotent normalised new. \"\"\" if len ( args ) == 1 and len ( kwargs ) == 0 : if isinstance ( args [ 0 ], str ): pass elif isinstance ( args [ 0 ], dict ): kwargs = args [ 0 ] elif isinstance ( args [ 0 ], Iterable ): args = list ( args [ 0 ]) return self . __attrs_init__ ( * args , ** kwargs ) __le__ ( self , other ) special \u00b6 Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __le__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) <= attrs_to_tuple ( other ) return NotImplemented __lt__ ( self , other ) special \u00b6 Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __lt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) < attrs_to_tuple ( other ) return NotImplemented __ne__ ( self , other ) special \u00b6 Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __ne__ ( self , other ): \"\"\" Check equality and either forward a NotImplemented or return the result negated. \"\"\" result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result __new__ ( cls , * args , ** kwargs ) special staticmethod \u00b6 Create and return a new object. See help(type) for accurate signature. Source code in exam_gen/util/selectors/field.py def __new__ ( cls , * args , ** kwargs ): if len ( args ) == 1 and len ( kwargs ) == 0 : if isinstance ( args [ 0 ], cls ): return args [ 0 ] return super ( FieldSelect , cls ) . __new__ ( cls ) __repr__ ( self ) special \u00b6 Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __repr__ ( self ): \"\"\" Automatically created by attrs. \"\"\" try : working_set = _already_repring . working_set except AttributeError : working_set = set () _already_repring . working_set = working_set if id ( self ) in working_set : return \"...\" real_cls = self . __class__ if ns is None : qualname = getattr ( real_cls , \"__qualname__\" , None ) if qualname is not None : class_name = qualname . rsplit ( \">.\" , 1 )[ - 1 ] else : class_name = real_cls . __name__ else : class_name = ns + \".\" + real_cls . __name__ # Since 'self' remains on the stack (i.e.: strongly referenced) for the # duration of this call, it's safe to depend on id(...) stability, and # not need to track the instance and therefore worry about properties # like weakref- or hash-ability. working_set . add ( id ( self )) try : result = [ class_name , \"(\" ] first = True for name , attr_repr in attr_names_with_reprs : if first : first = False else : result . append ( \", \" ) result . extend ( ( name , \"=\" , attr_repr ( getattr ( self , name , NOTHING ))) ) return \"\" . join ( result ) + \")\" finally : working_set . remove ( id ( self )) match ( self , key ) \u00b6 Source code in exam_gen/util/selectors/field.py def match ( self , key ): selector = self . selector if not self . case_sensitive : selector = selector . lower () key = key . lower () if self . strip_string : selector = selector . strip () key = key . strip () is_match = False if self . substring : is_match = selector in key else : is_match = selector == key return is_match select ( self , record , supress_error = False ) \u00b6 Returns the value of the field which matches the selector Source code in exam_gen/util/selectors/field.py def select ( self , record , supress_error = False ): \"\"\" Returns the value of the field which matches the selector \"\"\" for ( k , v ) in record . items (): if self . match ( k ): return v if supress_error : return None raise RuntimeError ( \"No field with selector {} found in {} \" . format ( self . selector , record )) student \u00b6 log \u00b6 StudentSelect \u00b6 Associates records with students. Parameters: Name Type Description Default record_field The field of the record we're going to be using as an identifier. required student_field The field of the student we'll match it to, available options are: \"ident\": The base identifier \"name\": The student's name in \"Last, First\" format (not reccomended) \"student_id\" : The students id number (default) \"usersame\" : The student's username. Other values will default to fields in \"student_data\", taken from the roster directly. required __attrs_init__ ( self , record_field , student_field = 'student_id' ) special \u00b6 Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __attrs_init__ ( self , record_field , student_field = attr_dict [ 'student_field' ] . default ): self . record_field = record_field self . student_field = student_field self . __attrs_post_init__ () __attrs_post_init__ ( self ) special \u00b6 Source code in exam_gen/util/selectors/student.py def __attrs_post_init__ ( self ): self . record_field = FieldSelect ( self . record_field ) self . student_field = self . _init_st_fld ( self . student_field ) __eq__ ( self , other ) special \u00b6 Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __eq__ ( self , other ): if other . __class__ is not self . __class__ : return NotImplemented return ( self . record_field , self . student_field , ) == ( other . record_field , other . student_field , ) __ge__ ( self , other ) special \u00b6 Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __ge__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) >= attrs_to_tuple ( other ) return NotImplemented __gt__ ( self , other ) special \u00b6 Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __gt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) > attrs_to_tuple ( other ) return NotImplemented __init__ ( self , * args , ** kwargs ) special \u00b6 Sorta idempotent normalised new. Source code in exam_gen/util/selectors/student.py def __init__ ( self , * args , ** kwargs ): \"\"\" Sorta idempotent normalised new. \"\"\" if len ( args ) == 1 and len ( kwargs ) == 0 : if isinstance ( args [ 0 ], str ): pass elif isinstance ( args [ 0 ], Iterable ): args = args [ 0 ] elif isinstance ( args [ 0 ], dict ): args = [] kwargs |= args return self . __attrs_init__ ( * args , ** kwargs ) __le__ ( self , other ) special \u00b6 Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __le__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) <= attrs_to_tuple ( other ) return NotImplemented __lt__ ( self , other ) special \u00b6 Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __lt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) < attrs_to_tuple ( other ) return NotImplemented __ne__ ( self , other ) special \u00b6 Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __ne__ ( self , other ): \"\"\" Check equality and either forward a NotImplemented or return the result negated. \"\"\" result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result __new__ ( cls , * args , ** kwargs ) special staticmethod \u00b6 Create and return a new object. See help(type) for accurate signature. Source code in exam_gen/util/selectors/student.py def __new__ ( cls , * args , ** kwargs ): if len ( args ) == 1 and len ( kwargs ) == 0 : if isinstance ( args [ 0 ], cls ): return args [ 0 ] return super ( StudentSelect , cls ) . __new__ ( cls ) __repr__ ( self ) special \u00b6 Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __repr__ ( self ): \"\"\" Automatically created by attrs. \"\"\" try : working_set = _already_repring . working_set except AttributeError : working_set = set () _already_repring . working_set = working_set if id ( self ) in working_set : return \"...\" real_cls = self . __class__ if ns is None : qualname = getattr ( real_cls , \"__qualname__\" , None ) if qualname is not None : class_name = qualname . rsplit ( \">.\" , 1 )[ - 1 ] else : class_name = real_cls . __name__ else : class_name = ns + \".\" + real_cls . __name__ # Since 'self' remains on the stack (i.e.: strongly referenced) for the # duration of this call, it's safe to depend on id(...) stability, and # not need to track the instance and therefore worry about properties # like weakref- or hash-ability. working_set . add ( id ( self )) try : result = [ class_name , \"(\" ] first = True for name , attr_repr in attr_names_with_reprs : if first : first = False else : result . append ( \", \" ) result . extend ( ( name , \"=\" , attr_repr ( getattr ( self , name , NOTHING ))) ) return \"\" . join ( result ) + \")\" finally : working_set . remove ( id ( self )) match ( self , student , record ) \u00b6 Check whether this student matches the given record. Overload this to implement more advanced behavior. Source code in exam_gen/util/selectors/student.py def match ( self , student , record ): \"\"\" Check whether this student matches the given record. Overload this to implement more advanced behavior. \"\"\" return self . student_field ( student ) == self . record_field . select ( record ) partition ( self , students , records , student_field = None , merge_with = None ) \u00b6 Go through a set of students and associate records with them. Source code in exam_gen/util/selectors/student.py def partition ( self , students , records , student_field = None , merge_with = None ): \"\"\" Go through a set of students and associate records with them. \"\"\" student_dict = dict () student_field = ( self . _init_st_fld ( student_field ) if student_field else self . student_field ) if isinstance ( students , dict ): student_dict = students elif isinstance ( students , Iterable ): for student in student : key = student_field ( student ) student_dict [ key ] = student else : raise RuntimeError ( \"Students must be provided as dict or iterable\" ) record_dict = dict () for ( key , student ) in student_dict . items (): record_dict [ key ] = self . select_records ( student , records , merge_with = merge_with ) return record_dict select_records ( self , student , records , merge_with = None ) \u00b6 Get the set of records associated with a given student. Source code in exam_gen/util/selectors/student.py def select_records ( self , student , records , merge_with = None ): \"\"\" Get the set of records associated with a given student. \"\"\" merge_with = merge_with if merge_with else ( lambda a , b : a ) if isinstance ( records , dict ): out = dict () for ( key , record ) in records . items (): if self . match ( student , record ): out [ key ] = merge_with ( record , out . pop ( key , None )) return out elif isinstance ( records , Iterable ): out = list () for record in records : if self . match ( student , record ): out . append ( record ) return out else : raise RuntimeError ( \"Records must be list or dict.\" ) select_student ( self , students , record , supress_error = False ) \u00b6 Find a student that matches a given record. Source code in exam_gen/util/selectors/student.py def select_student ( self , students , record , supress_error = False ): \"\"\" Find a student that matches a given record. \"\"\" for ( key , student ) in students . items (): if self . match ( student , record ): return ( key , student ) if not supress_error : raise RuntimeError ( textwrap . dedent ( \"\"\" No student found matching given record: Record Field: {} Record: {} \"\"\" ) . format ( self . record_field , record )) return None filters: - \"!^_[^_]*\" - \"!log\" - \"__init__\"","title":".util.selectors"},{"location":"api/util/selectors.html#exam_genutilselectors-classes-to-help-associate-record-fields-with-students-and-exams","text":"","title":"exam_gen.util.selectors: Classes to help associate record fields with students and exams."},{"location":"api/util/selectors.html#exam_gen.util.selectors.document","text":"","title":"document"},{"location":"api/util/selectors.html#exam_gen.util.selectors.document.log","text":"","title":"log"},{"location":"api/util/selectors.html#exam_gen.util.selectors.document.DocSelect","text":"Associates record fields with documents and sub-documents","title":"DocSelect"},{"location":"api/util/selectors.html#exam_gen.util.selectors.document.DocSelect.__attrs_init__","text":"Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __attrs_init__ ( self , mapping , selector = attr_dict [ 'selector' ] . default , norm_field = attr_dict [ 'norm_field' ] . default ): self . mapping = mapping self . selector = selector self . norm_field = norm_field self . __attrs_post_init__ ()","title":"__attrs_init__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.document.DocSelect.__attrs_post_init__","text":"Source code in exam_gen/util/selectors/document.py def __attrs_post_init__ ( self ): _mapping = dict () for ( k , v ) in self . mapping . items (): ( field , meta ) = self . norm_field ( v ) _mapping [ k ] = ( self . norm_map_entry ( field ), meta ) self . mapping = _mapping","title":"__attrs_post_init__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.document.DocSelect.__eq__","text":"Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __eq__ ( self , other ): if other . __class__ is not self . __class__ : return NotImplemented return ( self . mapping , self . selector , self . norm_field , ) == ( other . mapping , other . selector , other . norm_field , )","title":"__eq__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.document.DocSelect.__ge__","text":"Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __ge__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) >= attrs_to_tuple ( other ) return NotImplemented","title":"__ge__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.document.DocSelect.__gt__","text":"Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __gt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) > attrs_to_tuple ( other ) return NotImplemented","title":"__gt__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.document.DocSelect.__init__","text":"Sorta idempotent normalised new. Source code in exam_gen/util/selectors/document.py def __init__ ( self , * args , ** kwargs ): \"\"\" Sorta idempotent normalised new. \"\"\" if len ( args ) == 0 and len ( kwargs ) >= 0 and 'mapping' not in kwargs : _kwargs = dict () for k in [ 'selector' , 'norm_field' ]: if k in kwargs : _kwargs [ k ] = kwargs . pop ( k ) kwargs = { 'mapping' : kwargs } | _kwargs self . __attrs_init__ ( * args , ** kwargs )","title":"__init__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.document.DocSelect.__le__","text":"Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __le__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) <= attrs_to_tuple ( other ) return NotImplemented","title":"__le__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.document.DocSelect.__lt__","text":"Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __lt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) < attrs_to_tuple ( other ) return NotImplemented","title":"__lt__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.document.DocSelect.__ne__","text":"Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __ne__ ( self , other ): \"\"\" Check equality and either forward a NotImplemented or return the result negated. \"\"\" result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result","title":"__ne__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.document.DocSelect.__new__","text":"Sorta idempotent normalised new. Source code in exam_gen/util/selectors/document.py def __new__ ( cls , * args , ** kwargs ): \"\"\" Sorta idempotent normalised new. \"\"\" if len ( args ) == 1 and len ( kwargs ) == 0 : if isinstance ( args [ 0 ], DocSelect ): return args [ 0 ] return super ( DocSelect , cls ) . __new__ ( cls )","title":"__new__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.document.DocSelect.__repr__","text":"Method generated by attrs for class DocSelect. Source code in exam_gen/util/selectors/document.py def __repr__ ( self ): \"\"\" Automatically created by attrs. \"\"\" try : working_set = _already_repring . working_set except AttributeError : working_set = set () _already_repring . working_set = working_set if id ( self ) in working_set : return \"...\" real_cls = self . __class__ if ns is None : qualname = getattr ( real_cls , \"__qualname__\" , None ) if qualname is not None : class_name = qualname . rsplit ( \">.\" , 1 )[ - 1 ] else : class_name = real_cls . __name__ else : class_name = ns + \".\" + real_cls . __name__ # Since 'self' remains on the stack (i.e.: strongly referenced) for the # duration of this call, it's safe to depend on id(...) stability, and # not need to track the instance and therefore worry about properties # like weakref- or hash-ability. working_set . add ( id ( self )) try : result = [ class_name , \"(\" ] first = True for name , attr_repr in attr_names_with_reprs : if first : first = False else : result . append ( \", \" ) result . extend ( ( name , \"=\" , attr_repr ( getattr ( self , name , NOTHING ))) ) return \"\" . join ( result ) + \")\" finally : working_set . remove ( id ( self ))","title":"__repr__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.document.DocSelect.norm_map_entry","text":"Source code in exam_gen/util/selectors/document.py def norm_map_entry ( self , entry ): if isinstance ( entry , DocSelect ): return entry elif isinstance ( entry , FieldSelect ): return entry elif isinstance ( entry , dict ): return type ( self )( mapping = entry , selector = self . selector , norm_field = self . norm_field ) else : return self . selector ( entry )","title":"norm_map_entry()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.document.DocSelect.select","text":"Given a record produce a mapped dictionary of values. Source code in exam_gen/util/selectors/document.py def select ( self , record , supress_error = False , with_meta = False ): \"\"\" Given a record produce a mapped dictionary of values. \"\"\" result = dict () # Turn with_meta into a function that will turn the (match, meta) pair # into the result we want. if not callable ( with_meta ): as_tuple = lambda f , m : ( f , m ) only_field = lambda f , m : f with_meta = as_tuple if with_meta else only_field # Go through and grab the matching fields while assembling them # properly for ( k , ( fld , meta )) in self . mapping . items (): match = fld . select ( record , supress_error ) if match != None : result [ k ] = with_meta ( match , meta ) return result","title":"select()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.field","text":"","title":"field"},{"location":"api/util/selectors.html#exam_gen.util.selectors.field.log","text":"","title":"log"},{"location":"api/util/selectors.html#exam_gen.util.selectors.field.FieldSelect","text":"","title":"FieldSelect"},{"location":"api/util/selectors.html#exam_gen.util.selectors.field.FieldSelect.__attrs_init__","text":"Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __attrs_init__ ( self , selector , substring = attr_dict [ 'substring' ] . default , strip_string = attr_dict [ 'strip_string' ] . default , case_sensitive = attr_dict [ 'case_sensitive' ] . default ): self . selector = selector self . substring = substring self . strip_string = strip_string self . case_sensitive = case_sensitive","title":"__attrs_init__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.field.FieldSelect.__eq__","text":"Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __eq__ ( self , other ): if other . __class__ is not self . __class__ : return NotImplemented return ( self . selector , self . substring , self . strip_string , self . case_sensitive , ) == ( other . selector , other . substring , other . strip_string , other . case_sensitive , )","title":"__eq__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.field.FieldSelect.__ge__","text":"Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __ge__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) >= attrs_to_tuple ( other ) return NotImplemented","title":"__ge__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.field.FieldSelect.__gt__","text":"Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __gt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) > attrs_to_tuple ( other ) return NotImplemented","title":"__gt__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.field.FieldSelect.__init__","text":"Sorta idempotent normalised new. Source code in exam_gen/util/selectors/field.py def __init__ ( self , * args , ** kwargs ): \"\"\" Sorta idempotent normalised new. \"\"\" if len ( args ) == 1 and len ( kwargs ) == 0 : if isinstance ( args [ 0 ], str ): pass elif isinstance ( args [ 0 ], dict ): kwargs = args [ 0 ] elif isinstance ( args [ 0 ], Iterable ): args = list ( args [ 0 ]) return self . __attrs_init__ ( * args , ** kwargs )","title":"__init__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.field.FieldSelect.__le__","text":"Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __le__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) <= attrs_to_tuple ( other ) return NotImplemented","title":"__le__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.field.FieldSelect.__lt__","text":"Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __lt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) < attrs_to_tuple ( other ) return NotImplemented","title":"__lt__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.field.FieldSelect.__ne__","text":"Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __ne__ ( self , other ): \"\"\" Check equality and either forward a NotImplemented or return the result negated. \"\"\" result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result","title":"__ne__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.field.FieldSelect.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in exam_gen/util/selectors/field.py def __new__ ( cls , * args , ** kwargs ): if len ( args ) == 1 and len ( kwargs ) == 0 : if isinstance ( args [ 0 ], cls ): return args [ 0 ] return super ( FieldSelect , cls ) . __new__ ( cls )","title":"__new__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.field.FieldSelect.__repr__","text":"Method generated by attrs for class FieldSelect. Source code in exam_gen/util/selectors/field.py def __repr__ ( self ): \"\"\" Automatically created by attrs. \"\"\" try : working_set = _already_repring . working_set except AttributeError : working_set = set () _already_repring . working_set = working_set if id ( self ) in working_set : return \"...\" real_cls = self . __class__ if ns is None : qualname = getattr ( real_cls , \"__qualname__\" , None ) if qualname is not None : class_name = qualname . rsplit ( \">.\" , 1 )[ - 1 ] else : class_name = real_cls . __name__ else : class_name = ns + \".\" + real_cls . __name__ # Since 'self' remains on the stack (i.e.: strongly referenced) for the # duration of this call, it's safe to depend on id(...) stability, and # not need to track the instance and therefore worry about properties # like weakref- or hash-ability. working_set . add ( id ( self )) try : result = [ class_name , \"(\" ] first = True for name , attr_repr in attr_names_with_reprs : if first : first = False else : result . append ( \", \" ) result . extend ( ( name , \"=\" , attr_repr ( getattr ( self , name , NOTHING ))) ) return \"\" . join ( result ) + \")\" finally : working_set . remove ( id ( self ))","title":"__repr__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.field.FieldSelect.match","text":"Source code in exam_gen/util/selectors/field.py def match ( self , key ): selector = self . selector if not self . case_sensitive : selector = selector . lower () key = key . lower () if self . strip_string : selector = selector . strip () key = key . strip () is_match = False if self . substring : is_match = selector in key else : is_match = selector == key return is_match","title":"match()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.field.FieldSelect.select","text":"Returns the value of the field which matches the selector Source code in exam_gen/util/selectors/field.py def select ( self , record , supress_error = False ): \"\"\" Returns the value of the field which matches the selector \"\"\" for ( k , v ) in record . items (): if self . match ( k ): return v if supress_error : return None raise RuntimeError ( \"No field with selector {} found in {} \" . format ( self . selector , record ))","title":"select()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student","text":"","title":"student"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.log","text":"","title":"log"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect","text":"Associates records with students. Parameters: Name Type Description Default record_field The field of the record we're going to be using as an identifier. required student_field The field of the student we'll match it to, available options are: \"ident\": The base identifier \"name\": The student's name in \"Last, First\" format (not reccomended) \"student_id\" : The students id number (default) \"usersame\" : The student's username. Other values will default to fields in \"student_data\", taken from the roster directly. required","title":"StudentSelect"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect.__attrs_init__","text":"Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __attrs_init__ ( self , record_field , student_field = attr_dict [ 'student_field' ] . default ): self . record_field = record_field self . student_field = student_field self . __attrs_post_init__ ()","title":"__attrs_init__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect.__attrs_post_init__","text":"Source code in exam_gen/util/selectors/student.py def __attrs_post_init__ ( self ): self . record_field = FieldSelect ( self . record_field ) self . student_field = self . _init_st_fld ( self . student_field )","title":"__attrs_post_init__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect.__eq__","text":"Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __eq__ ( self , other ): if other . __class__ is not self . __class__ : return NotImplemented return ( self . record_field , self . student_field , ) == ( other . record_field , other . student_field , )","title":"__eq__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect.__ge__","text":"Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __ge__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) >= attrs_to_tuple ( other ) return NotImplemented","title":"__ge__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect.__gt__","text":"Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __gt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) > attrs_to_tuple ( other ) return NotImplemented","title":"__gt__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect.__init__","text":"Sorta idempotent normalised new. Source code in exam_gen/util/selectors/student.py def __init__ ( self , * args , ** kwargs ): \"\"\" Sorta idempotent normalised new. \"\"\" if len ( args ) == 1 and len ( kwargs ) == 0 : if isinstance ( args [ 0 ], str ): pass elif isinstance ( args [ 0 ], Iterable ): args = args [ 0 ] elif isinstance ( args [ 0 ], dict ): args = [] kwargs |= args return self . __attrs_init__ ( * args , ** kwargs )","title":"__init__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect.__le__","text":"Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __le__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) <= attrs_to_tuple ( other ) return NotImplemented","title":"__le__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect.__lt__","text":"Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __lt__ ( self , other ): \"\"\" Automatically created by attrs. \"\"\" if other . __class__ is self . __class__ : return attrs_to_tuple ( self ) < attrs_to_tuple ( other ) return NotImplemented","title":"__lt__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect.__ne__","text":"Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __ne__ ( self , other ): \"\"\" Check equality and either forward a NotImplemented or return the result negated. \"\"\" result = self . __eq__ ( other ) if result is NotImplemented : return NotImplemented return not result","title":"__ne__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect.__new__","text":"Create and return a new object. See help(type) for accurate signature. Source code in exam_gen/util/selectors/student.py def __new__ ( cls , * args , ** kwargs ): if len ( args ) == 1 and len ( kwargs ) == 0 : if isinstance ( args [ 0 ], cls ): return args [ 0 ] return super ( StudentSelect , cls ) . __new__ ( cls )","title":"__new__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect.__repr__","text":"Method generated by attrs for class StudentSelect. Source code in exam_gen/util/selectors/student.py def __repr__ ( self ): \"\"\" Automatically created by attrs. \"\"\" try : working_set = _already_repring . working_set except AttributeError : working_set = set () _already_repring . working_set = working_set if id ( self ) in working_set : return \"...\" real_cls = self . __class__ if ns is None : qualname = getattr ( real_cls , \"__qualname__\" , None ) if qualname is not None : class_name = qualname . rsplit ( \">.\" , 1 )[ - 1 ] else : class_name = real_cls . __name__ else : class_name = ns + \".\" + real_cls . __name__ # Since 'self' remains on the stack (i.e.: strongly referenced) for the # duration of this call, it's safe to depend on id(...) stability, and # not need to track the instance and therefore worry about properties # like weakref- or hash-ability. working_set . add ( id ( self )) try : result = [ class_name , \"(\" ] first = True for name , attr_repr in attr_names_with_reprs : if first : first = False else : result . append ( \", \" ) result . extend ( ( name , \"=\" , attr_repr ( getattr ( self , name , NOTHING ))) ) return \"\" . join ( result ) + \")\" finally : working_set . remove ( id ( self ))","title":"__repr__()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect.match","text":"Check whether this student matches the given record. Overload this to implement more advanced behavior. Source code in exam_gen/util/selectors/student.py def match ( self , student , record ): \"\"\" Check whether this student matches the given record. Overload this to implement more advanced behavior. \"\"\" return self . student_field ( student ) == self . record_field . select ( record )","title":"match()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect.partition","text":"Go through a set of students and associate records with them. Source code in exam_gen/util/selectors/student.py def partition ( self , students , records , student_field = None , merge_with = None ): \"\"\" Go through a set of students and associate records with them. \"\"\" student_dict = dict () student_field = ( self . _init_st_fld ( student_field ) if student_field else self . student_field ) if isinstance ( students , dict ): student_dict = students elif isinstance ( students , Iterable ): for student in student : key = student_field ( student ) student_dict [ key ] = student else : raise RuntimeError ( \"Students must be provided as dict or iterable\" ) record_dict = dict () for ( key , student ) in student_dict . items (): record_dict [ key ] = self . select_records ( student , records , merge_with = merge_with ) return record_dict","title":"partition()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect.select_records","text":"Get the set of records associated with a given student. Source code in exam_gen/util/selectors/student.py def select_records ( self , student , records , merge_with = None ): \"\"\" Get the set of records associated with a given student. \"\"\" merge_with = merge_with if merge_with else ( lambda a , b : a ) if isinstance ( records , dict ): out = dict () for ( key , record ) in records . items (): if self . match ( student , record ): out [ key ] = merge_with ( record , out . pop ( key , None )) return out elif isinstance ( records , Iterable ): out = list () for record in records : if self . match ( student , record ): out . append ( record ) return out else : raise RuntimeError ( \"Records must be list or dict.\" )","title":"select_records()"},{"location":"api/util/selectors.html#exam_gen.util.selectors.student.StudentSelect.select_student","text":"Find a student that matches a given record. Source code in exam_gen/util/selectors/student.py def select_student ( self , students , record , supress_error = False ): \"\"\" Find a student that matches a given record. \"\"\" for ( key , student ) in students . items (): if self . match ( student , record ): return ( key , student ) if not supress_error : raise RuntimeError ( textwrap . dedent ( \"\"\" No student found matching given record: Record Field: {} Record: {} \"\"\" ) . format ( self . record_field , record )) return None filters: - \"!^_[^_]*\" - \"!log\" - \"__init__\"","title":"select_student()"},{"location":"exam_admin/canvas.html","text":"Administering Exams Through Canvas \u00b6 Quiz Options: Shuffle Answers: false Time Limit: as needed Allow Multiple Attempts: probably true Let students see responses: probably false Notes for Students: File submissions must be reuploaded with every submission. Grades shown by canvas are meaningless, ignore them. Actual grades will be calculated after the fact. Points associated w/ each question on canvas are meaningless, refer to exam for scoring if any. If resubmit : You can leave a non-file-upload question unanswered on a submission and the system will just use the last submitted answer. Notes for Exam Creator: Put problem name and number (or other identifer) in the problem text, the title you set (next to problem type dropdown) is invisible to students and exports. Set problem pts to 0 Mark all answers as correct. Don't use formula questions, they're broken. Numberical question, set the accepted range super wide Getting Grades: Files: quiz page \"download all files\" Grades: quiz page -> \"quiz statistics\" -> \"Student analysis\"","title":"Administering Exams Through Canvas"},{"location":"exam_admin/canvas.html#administering-exams-through-canvas","text":"Quiz Options: Shuffle Answers: false Time Limit: as needed Allow Multiple Attempts: probably true Let students see responses: probably false Notes for Students: File submissions must be reuploaded with every submission. Grades shown by canvas are meaningless, ignore them. Actual grades will be calculated after the fact. Points associated w/ each question on canvas are meaningless, refer to exam for scoring if any. If resubmit : You can leave a non-file-upload question unanswered on a submission and the system will just use the last submitted answer. Notes for Exam Creator: Put problem name and number (or other identifer) in the problem text, the title you set (next to problem type dropdown) is invisible to students and exports. Set problem pts to 0 Mark all answers as correct. Don't use formula questions, they're broken. Numberical question, set the accepted range super wide Getting Grades: Files: quiz page \"download all files\" Grades: quiz page -> \"quiz statistics\" -> \"Student analysis\"","title":"Administering Exams Through Canvas"},{"location":"tutorial/index.html","text":"","title":"Index"},{"location":"tutorial/advanced_template_use.html","text":"Advanced Template Use \u00b6 In this section of the tutorial we'll be fleshing out our implementation of SumQuestion and turning it into something that could plausibly be in an assignment. Generating Problem Parameters \u00b6 We're going to give each student a randomized addition problem where they have to sum up 5 numbers. We can start generating the variables for a problem by adding the following to addition_question.py : 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def generate_question_params ( self , rng ): result = dict () # How many numbers will the student have to sum up? num_vars = 4 # Generate each element var_list = list () for ind in range ( 0 , num_vars ): var_list . append ( rng . randint ( 0 , 20 )) # return the parameters for the problem return { 'vars' : var_list , 'num_vars' : num_vars , 'total' : sum ( var_list ) } On its own, the above does nothing so let's make sure that we get the results of generate_question_params into the context available for our template variables by adding the following to user_setup : 24 ctxt_vars [ 'problem' ] = self . generate_question_params ( rng ) Complete Current addition_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from exam_gen import * class SumQuestion ( LatexDoc , Question ): metadata . name = \"Basic Addition Question\" body . text = r ''' Hello \\texttt{ {{ student['Email Address'] }} }, Here's some test text {{ test_vars.test_str }}. \\\\ And the test integer: ${{test_vars.test_int }}$. ''' solution . text = \"Placeholder text for the solution of the question.\" def user_setup ( self , rng , ** kwargs ): ctxt_vars = dict () ctxt_vars [ 'test_vars' ] = { 'test_str' : r 'Hello, testing \\textbf {TESTING} ' , 'test_int' : rng . randint ( 0 , 1000 ) } ctxt_vars [ 'problem' ] = self . generate_question_params ( rng ) return ctxt_vars def generate_question_params ( self , rng ): result = dict () # How many numbers will the student have to sum up? num_vars = 4 # Generate each element var_list = list () for ind in range ( 0 , num_vars ): var_list . append ( rng . randint ( 0 , 20 )) # return the parameters for the problem return { 'vars' : var_list , 'num_vars' : num_vars , 'total' : sum ( var_list ) } Then we can run our usual build command: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios The new lines in final-context-output-questions[addition-question]-body.yaml show that we've managed to correctly add new variables to the template: 12 13 14 15 16 17 18 19 problem : num_vars : 4 total : 33 vars : - 1 - 14 - 6 - 12 Generating Solution Keys \u00b6 That isn't enough to actually display our problem in the test itself. For that we need to edit the templates in addition_question.py : 6 7 8 9 10 11 12 13 body . text = r ''' Solve the following equation: $${{ problem.vars[0] }} + {{ problem.vars[1] }} + {{ problem.vars[2] }} + {{ problem.vars[3] }} = \\_\\_$$ ''' solution . text = \" The total is {{ problem.total }}.\" With those changes we can run our usual build command and look at the resulting pdf: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios TODO: add images, should be assets/cust_and_rand_part5 We can also generate the solution key with the following command: $ ./exam.py build-solution:fake-class:erios And look at the result in ~out/exam_solution/class-fake-class/erios.pdf : TODO: Add image assets/aut_and_rand_part5_sols Loops in Templates \u00b6 We can have more complex operations in the templates themselves like allowing variability in the number of variables in each equation or the number of equations in total. Let's first change the number of variables in the each equation by editing the following line in generate_question_params : 33 num_vars = rng . randint ( 3 , 8 ) Now our template can't handle the full length of the problem, so let's use some of jinja2's for loops to make this work: 6 7 8 9 10 11 12 body . text = r ''' Solve the following equation: $${ % f or v in problem.vars -%}{{ v }} { %- i f not loop.last %} + { % e ndif -%} { %- e ndfor %} = \\_\\_$$ ''' Template Constructs Control flow statements like if and for are usually found within {% and %} , unlike printed statements which are found within {{ and }} Within a loop it's possible to access the loop magic variable, which can be used to determine whether you should print a separator like + here. Dashes at the beginning or end of jinja statements, like {%- or -%} are used to delete whitespace. Here we use them to prevent printing unnessesary newlines. We can then build the exam and solutions with these changes: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios $ ./exam.py build-solutions:fake-class:erios TODO: images are in assets/ Nesting and Complex Problem Structure \u00b6 We can even build a more complex problem by multiplying the number of sub-problems. You should probably not do this in an actual assignment. Generate multiple sub-problems by modifying user_setup : 20 21 22 23 24 25 26 27 28 29 30 31 def user_setup ( self , rng , ** kwargs ): ctxt_vars = dict () ctxt_vars [ 'problem' ] = list () ctxt_vars [ 'total' ] = 0 for i in range ( 0 , 10 ): sub = self . generate_question_params ( rng ) ctxt_vars [ 'problem' ] . append ( sub ) ctxt_vars [ 'total' ] += sub [ 'total' ] return ctxt_vars Then we can tweak the templates by adding another loop: 6 7 8 9 10 11 12 13 14 15 16 17 18 body . text = r ''' Solve the following equations: { % f or eq in problem %} $${ % f or v in eq.vars -%}{{ v }} { %- i f not loop.last %} + { % e ndif -%} { %- e ndfor %} = \\_\\_$$ { % e ndfor %} What is the sum of all of their answers? ''' solution . text = \" The total is {{ total }}.\" Complete Current addition_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from exam_gen import * class SumQuestion ( LatexDoc , Question ): metadata . name = \"Basic Addition Question\" body . text = r ''' Solve the following equations: { % f or eq in problem %} $${ % f or v in eq.vars -%}{{ v }} { %- i f not loop.last %} + { % e ndif -%} { %- e ndfor %} = \\_\\_$$ { % e ndfor %} What is the sum of all of their answers? ''' solution . text = \" The total is {{ total }}.\" def user_setup ( self , rng , ** kwargs ): ctxt_vars = dict () ctxt_vars [ 'problem' ] = list () ctxt_vars [ 'total' ] = 0 for i in range ( 0 , 10 ): sub = self . generate_question_params ( rng ) ctxt_vars [ 'problem' ] . append ( sub ) ctxt_vars [ 'total' ] += sub [ 'total' ] return ctxt_vars def generate_question_params ( self , rng ): result = dict () # How many numbers will the student have to sum up? num_vars = rng . randint ( 4 , 8 ) # Generate each element var_list = list () for ind in range ( 0 , num_vars ): var_list . append ( rng . randint ( 0 , 20 )) # return the parameters for the problem return { 'vars' : var_list , 'num_vars' : num_vars , 'total' : sum ( var_list ) } As usual, we can build our exams and look at the results: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios $ ./exam.py build-solutions:fake-class:erios TODO: Add images from assets/ Advanced Solution Text \u00b6 Now, the current solution key isn't as useful as it could be. In part because it doesn't tell us the different answers to each sub-problem. There are two ways to fix this, in the template itself or setting different versions of the template variable. Using Library Level Formats \u00b6 The is a library level mechanism for switching out template variables. You can index into template variables like body , solution or intro with the same syntax used for dictionaries. Each format lets you directly set the parameter for that format. For instance setting body [ 'exam' ] . text defines the template when we're building exams, and body [ 'solution' ] . text defines the template when building a solution. For example we could change body.text in addition_question.py to read: 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 body [ 'exam' ] . text = r ''' Solve the following equations: { %- f or eq in problem -%} $${ % f or v in eq.vars -%}{{ v }} { %- i f not loop.last %} + { % e ndif -%} { %- e ndfor %} = \\_\\_$$ { %- e ndfor -%} What is the sum of all of their answers? ''' body [ 'solution' ] . text = r ''' Solve the following equations: { %- f or eq in problem -%} $${ % f or v in eq.vars -%}{{ v }} { %- i f not loop.last %} + { % e ndif -%} { %- e ndfor %} = \\solution{ {{ eq.total }} }$$ { %- e ndfor -%} What is the sum of all of their answers? ''' And then build our solution key to get: $ ./exam.py build-solutions:fake-class:erios Todo: image in assets/ Detecting Exam Format in Templates \u00b6 Another way to detect whether this is a solution or not is to look at the format variable using the template itself. It will be set to 'exam' if we're building in exam form and 'solution' if we're building a solution key. For instance we could change body.text in addition_question.py to read: 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 body . text = r ''' Solve the following equations: { %- i f format == 'solution' -%} { %- f or eq in problem -%} $${ % f or v in eq.vars -%}{{ v }} { %- i f not loop.last %} + { % e ndif -%} { %- e ndfor %} = \\solution{ {{ eq.total }} }$$ { %- e ndfor -%} { %- e lse -%} { %- f or eq in problem -%} $${ % f or v in eq.vars -%}{{ v }} { %- i f not loop.last %} + { % e ndif -%} { %- e ndfor %} = \\_\\_$$ { %- e ndfor -%} { %- e ndif -%} What is the sum of all of their answers? ''' And then build our solution key to get: $ ./exam.py build-solutions:fake-class:erios Todo: image in assets/ It's also possible to use LaTeX macros to do this, \\solution {} is one such mechanism, but that's easier to mess up. Changes to the LaTeX templates being used at the document and question level are more likely to have solution information being improperly shown. Better to avoid having the solutions appearing in the raw .tex files at all.","title":"Advanced Template Use"},{"location":"tutorial/advanced_template_use.html#advanced-template-use","text":"In this section of the tutorial we'll be fleshing out our implementation of SumQuestion and turning it into something that could plausibly be in an assignment.","title":"Advanced Template Use"},{"location":"tutorial/advanced_template_use.html#generating-problem-parameters","text":"We're going to give each student a randomized addition problem where they have to sum up 5 numbers. We can start generating the variables for a problem by adding the following to addition_question.py : 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def generate_question_params ( self , rng ): result = dict () # How many numbers will the student have to sum up? num_vars = 4 # Generate each element var_list = list () for ind in range ( 0 , num_vars ): var_list . append ( rng . randint ( 0 , 20 )) # return the parameters for the problem return { 'vars' : var_list , 'num_vars' : num_vars , 'total' : sum ( var_list ) } On its own, the above does nothing so let's make sure that we get the results of generate_question_params into the context available for our template variables by adding the following to user_setup : 24 ctxt_vars [ 'problem' ] = self . generate_question_params ( rng ) Complete Current addition_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 from exam_gen import * class SumQuestion ( LatexDoc , Question ): metadata . name = \"Basic Addition Question\" body . text = r ''' Hello \\texttt{ {{ student['Email Address'] }} }, Here's some test text {{ test_vars.test_str }}. \\\\ And the test integer: ${{test_vars.test_int }}$. ''' solution . text = \"Placeholder text for the solution of the question.\" def user_setup ( self , rng , ** kwargs ): ctxt_vars = dict () ctxt_vars [ 'test_vars' ] = { 'test_str' : r 'Hello, testing \\textbf {TESTING} ' , 'test_int' : rng . randint ( 0 , 1000 ) } ctxt_vars [ 'problem' ] = self . generate_question_params ( rng ) return ctxt_vars def generate_question_params ( self , rng ): result = dict () # How many numbers will the student have to sum up? num_vars = 4 # Generate each element var_list = list () for ind in range ( 0 , num_vars ): var_list . append ( rng . randint ( 0 , 20 )) # return the parameters for the problem return { 'vars' : var_list , 'num_vars' : num_vars , 'total' : sum ( var_list ) } Then we can run our usual build command: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios The new lines in final-context-output-questions[addition-question]-body.yaml show that we've managed to correctly add new variables to the template: 12 13 14 15 16 17 18 19 problem : num_vars : 4 total : 33 vars : - 1 - 14 - 6 - 12","title":"Generating Problem Parameters"},{"location":"tutorial/advanced_template_use.html#generating-solution-keys","text":"That isn't enough to actually display our problem in the test itself. For that we need to edit the templates in addition_question.py : 6 7 8 9 10 11 12 13 body . text = r ''' Solve the following equation: $${{ problem.vars[0] }} + {{ problem.vars[1] }} + {{ problem.vars[2] }} + {{ problem.vars[3] }} = \\_\\_$$ ''' solution . text = \" The total is {{ problem.total }}.\" With those changes we can run our usual build command and look at the resulting pdf: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios TODO: add images, should be assets/cust_and_rand_part5 We can also generate the solution key with the following command: $ ./exam.py build-solution:fake-class:erios And look at the result in ~out/exam_solution/class-fake-class/erios.pdf : TODO: Add image assets/aut_and_rand_part5_sols","title":"Generating Solution Keys"},{"location":"tutorial/advanced_template_use.html#loops-in-templates","text":"We can have more complex operations in the templates themselves like allowing variability in the number of variables in each equation or the number of equations in total. Let's first change the number of variables in the each equation by editing the following line in generate_question_params : 33 num_vars = rng . randint ( 3 , 8 ) Now our template can't handle the full length of the problem, so let's use some of jinja2's for loops to make this work: 6 7 8 9 10 11 12 body . text = r ''' Solve the following equation: $${ % f or v in problem.vars -%}{{ v }} { %- i f not loop.last %} + { % e ndif -%} { %- e ndfor %} = \\_\\_$$ ''' Template Constructs Control flow statements like if and for are usually found within {% and %} , unlike printed statements which are found within {{ and }} Within a loop it's possible to access the loop magic variable, which can be used to determine whether you should print a separator like + here. Dashes at the beginning or end of jinja statements, like {%- or -%} are used to delete whitespace. Here we use them to prevent printing unnessesary newlines. We can then build the exam and solutions with these changes: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios $ ./exam.py build-solutions:fake-class:erios TODO: images are in assets/","title":"Loops in Templates"},{"location":"tutorial/advanced_template_use.html#nesting-and-complex-problem-structure","text":"We can even build a more complex problem by multiplying the number of sub-problems. You should probably not do this in an actual assignment. Generate multiple sub-problems by modifying user_setup : 20 21 22 23 24 25 26 27 28 29 30 31 def user_setup ( self , rng , ** kwargs ): ctxt_vars = dict () ctxt_vars [ 'problem' ] = list () ctxt_vars [ 'total' ] = 0 for i in range ( 0 , 10 ): sub = self . generate_question_params ( rng ) ctxt_vars [ 'problem' ] . append ( sub ) ctxt_vars [ 'total' ] += sub [ 'total' ] return ctxt_vars Then we can tweak the templates by adding another loop: 6 7 8 9 10 11 12 13 14 15 16 17 18 body . text = r ''' Solve the following equations: { % f or eq in problem %} $${ % f or v in eq.vars -%}{{ v }} { %- i f not loop.last %} + { % e ndif -%} { %- e ndfor %} = \\_\\_$$ { % e ndfor %} What is the sum of all of their answers? ''' solution . text = \" The total is {{ total }}.\" Complete Current addition_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from exam_gen import * class SumQuestion ( LatexDoc , Question ): metadata . name = \"Basic Addition Question\" body . text = r ''' Solve the following equations: { % f or eq in problem %} $${ % f or v in eq.vars -%}{{ v }} { %- i f not loop.last %} + { % e ndif -%} { %- e ndfor %} = \\_\\_$$ { % e ndfor %} What is the sum of all of their answers? ''' solution . text = \" The total is {{ total }}.\" def user_setup ( self , rng , ** kwargs ): ctxt_vars = dict () ctxt_vars [ 'problem' ] = list () ctxt_vars [ 'total' ] = 0 for i in range ( 0 , 10 ): sub = self . generate_question_params ( rng ) ctxt_vars [ 'problem' ] . append ( sub ) ctxt_vars [ 'total' ] += sub [ 'total' ] return ctxt_vars def generate_question_params ( self , rng ): result = dict () # How many numbers will the student have to sum up? num_vars = rng . randint ( 4 , 8 ) # Generate each element var_list = list () for ind in range ( 0 , num_vars ): var_list . append ( rng . randint ( 0 , 20 )) # return the parameters for the problem return { 'vars' : var_list , 'num_vars' : num_vars , 'total' : sum ( var_list ) } As usual, we can build our exams and look at the results: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios $ ./exam.py build-solutions:fake-class:erios TODO: Add images from assets/","title":"Nesting and Complex Problem Structure"},{"location":"tutorial/advanced_template_use.html#advanced-solution-text","text":"Now, the current solution key isn't as useful as it could be. In part because it doesn't tell us the different answers to each sub-problem. There are two ways to fix this, in the template itself or setting different versions of the template variable.","title":"Advanced Solution Text"},{"location":"tutorial/advanced_template_use.html#using-library-level-formats","text":"The is a library level mechanism for switching out template variables. You can index into template variables like body , solution or intro with the same syntax used for dictionaries. Each format lets you directly set the parameter for that format. For instance setting body [ 'exam' ] . text defines the template when we're building exams, and body [ 'solution' ] . text defines the template when building a solution. For example we could change body.text in addition_question.py to read: 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 body [ 'exam' ] . text = r ''' Solve the following equations: { %- f or eq in problem -%} $${ % f or v in eq.vars -%}{{ v }} { %- i f not loop.last %} + { % e ndif -%} { %- e ndfor %} = \\_\\_$$ { %- e ndfor -%} What is the sum of all of their answers? ''' body [ 'solution' ] . text = r ''' Solve the following equations: { %- f or eq in problem -%} $${ % f or v in eq.vars -%}{{ v }} { %- i f not loop.last %} + { % e ndif -%} { %- e ndfor %} = \\solution{ {{ eq.total }} }$$ { %- e ndfor -%} What is the sum of all of their answers? ''' And then build our solution key to get: $ ./exam.py build-solutions:fake-class:erios Todo: image in assets/","title":"Using Library Level Formats"},{"location":"tutorial/advanced_template_use.html#detecting-exam-format-in-templates","text":"Another way to detect whether this is a solution or not is to look at the format variable using the template itself. It will be set to 'exam' if we're building in exam form and 'solution' if we're building a solution key. For instance we could change body.text in addition_question.py to read: 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 body . text = r ''' Solve the following equations: { %- i f format == 'solution' -%} { %- f or eq in problem -%} $${ % f or v in eq.vars -%}{{ v }} { %- i f not loop.last %} + { % e ndif -%} { %- e ndfor %} = \\solution{ {{ eq.total }} }$$ { %- e ndfor -%} { %- e lse -%} { %- f or eq in problem -%} $${ % f or v in eq.vars -%}{{ v }} { %- i f not loop.last %} + { % e ndif -%} { %- e ndfor %} = \\_\\_$$ { %- e ndfor -%} { %- e ndif -%} What is the sum of all of their answers? ''' And then build our solution key to get: $ ./exam.py build-solutions:fake-class:erios Todo: image in assets/ It's also possible to use LaTeX macros to do this, \\solution {} is one such mechanism, but that's easier to mess up. Changes to the LaTeX templates being used at the document and question level are more likely to have solution information being improperly shown. Better to avoid having the solutions appearing in the raw .tex files at all.","title":"Detecting Exam Format in Templates"},{"location":"tutorial/answers_and_scoring.html","text":"Answers and Scoring \u00b6 Here we'll go over loading student answers into the system and generating grades. Class Reorganization \u00b6 First though, let's reorganize our files to better separate one class's information from everything else. Make a new directory for our fake class and move over our roster: $ mkdir fake_class $ mv class-1.csv fake_class/ We also can create a new file for this classroom's settings, instead of keeping them inline as part of exam.py : $ touch fake_class/setup.py And load the following contents into that file: Complete Current fake_class/setup.py 1 2 3 4 5 6 7 8 from exam_gen import * import attr class FakeClassroom ( Classroom ): roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) Note how we're creating a new class FakeClassroom that inherits from Classroom . This is one way to overload the same settings that one can with with_options . We also need to update exam.py appropriately: First by adding an appropriate import statement: 9 from fake_class.setup import * Then by updating the list of classes to use FakeClassroom directly instead of configuring a new classroom on the fly with with_options : 13 14 15 classes = { 'fake-class' : FakeClassroom , } Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/usr/bin/env -S pipenv run python3 from exam_gen import * from addition_question import * from poly_question.question import * from graph_question.question import * from matrix_question.question import * from csp_question.question import * from fake_class.setup import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : FakeClassroom , } questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion , 'graph-question' : GraphQuestion , 'matrix-question' : MatrixQuestion , 'csp-question' : CspQuestion } intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) Test whether this works by building an exam as usual: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios At this point nothing substantive has changed, we've just been able to move all the class specific information into a subfolder. Loading Student Answers \u00b6 For the next steps we're going to take student provided answers and import them into the tool. The user guide shows how to set up various automated testing tools for use with this library. TODO: link to the user guide From here on out we'll be assuming that you followed the guide for Canvas/BCourses and using the corresponding exported answer data. We have made an example answer sheet for use with our fake class roster. You should load it into fake_class/exam_answers.csv with the following contents: Complete Current fake_class/exam_answers.csv 1 2 3 4 5 6 7 8 9 10 11 12 13 14 name,sis_id,submitted,attempt,117606621: Problem 1: Sum of All Answers,0,\"117606759: Problem 2A: Sketch the Polynomial (This text is visible to student) \\n Note: This type of question is a bit wonky w/ multiple submissions. All files must be uploaded on your final submission of the exam, otherwise the proctors won't see them.\",0,117606898: Problem 2B: What are the factors of the polynomial?,0,117607010: Problem 3: Masks of a bipartite graph,0,117607036: Problem 4: Independent columns,0,117607116: Problem 5: Constraint Satisfaction,0,n correct,n incorrect,score \"House, Sharon\",49232926,2021-07-12 20:01:01 UTC,1,519,0,,0,,0,\"C,D,E\",0,D,0,\"B,D,F,H,I,J,N\",0,2,5,0 \"Mcfarlane, Tracey\",49232948,2021-07-12 19:59:47 UTC,1,593,0,,0,,0,\"A,B,C\",0,B,0,\"A,D,F,G,I,J\",0,2,5,0 \"Decker, Adem\",49234533,2021-07-12 19:58:33 UTC,1,623,0,,0,,0,\"A,D,E\",0,D,0,\"B,C,F,H,I,N\",0,2,5,0 \"Rios, Christine\",49232540,2021-07-12 19:57:17 UTC,1,638,0,,0,(x -1)(x +5)(x + 5)(x + 1),0,\"A,B,C\",0,D,0,\"B,C,F,H,I,J\",0,2,5,0 \"Meza, Neave\",49234574,2021-07-12 19:56:08 UTC,2,,0,,0,,0,,0,D,0,\"B,C,F,H,I,J\",0,1,6,0 \"Meza, Neave\",49234574,2021-07-12 19:55:15 UTC,1,4432,0,,0,,0,\"A,B,D\",0,,0,,0,2,5,0 \"Ahmad, Ezmae\",49234288,2021-07-12 19:54:27 UTC,1,625,0,,0,x * (x + 3) ^2 * (x - 4),0,\"B,C,D,E\",0,D,0,\"B,D,F,G,I,L,N\",0,2,5,0 \"Wilkins, Willa\",49234720,2021-07-12 19:51:25 UTC,2,508,0,,0,,0,\"B,C,E\",0,,0,\"B,C,E,G,I,J,L,N\",0,2,5,0 \"Wilkins, Willa\",49234720,2021-07-12 19:50:15 UTC,1,112,0,,0,(x -3)(x +1),0,\"B,C,E\",0,B,0,\"A,C,G,M,O\",0,2,5,0 \"Calderon, Reema\",49233588,2021-07-12 19:48:46 UTC,4,,0,,0,(x -3)^2 * x * (x + 3),0,,0,,0,\"B,C,E,H,I,N\",0,2,5,0 \"Calderon, Reema\",49233588,2021-07-12 19:47:14 UTC,3,609,0,,0,,0,\"A,B\",0,D,0,,0,2,5,0 \"Calderon, Reema\",49233588,2021-07-12 19:46:32 UTC,2,1234,0,,0,123,0,\"B,E\",0,,0,\"N,O\",0,3,4,0 \"Calderon, Reema\",49233588,2021-07-12 19:45:55 UTC,1,112,0,,0,x^2 (x+3),0,\"B,D,E\",0,,0,\"B,C,F\",0,3,4,0 We also need to specify relevant details about how to associate columns of the csy to problems in our exam. Add the following to FakeClassroom : 11 12 13 14 15 16 17 18 19 20 answers = CSVAnswers . with_options ( file_name = \"exam_answers.csv\" , ident_column = \"sis_id\" , attempt_column = \"attempt\" , mapping = { 'graph-question' : \"Problem 3\" , 'matrix-question' : \"Problem 4\" , 'csp-question' : \"Problem 5\" } ) The CSVAnswers class here is used for decoding csv files, associating submissions with students, and associating columns with problems. Let's break down the various fields we set: file_name : As expected this is the CSV with all the answers to read in. It's specified relative to where FakeClassroom is define. (i.e. in fake_class/setup.py so in the fake_class/ folder.) ident_column : This is the column with the student's unique identifier. Here's its saying that the sis_id column in the csv is how we distinguish between students. attempt_column : This is the column that determines which submission attempt corresponds to each row of the column. It ensures the latest submission for each problem is the one that's graded. mapping : This tells us how we should assign columns from the csv to specific problems. The key is the problem name and value is a unique substring of the column in the csv. We're only mapping the three multiple choice questions over since those are the only auto-gradable ones. See the user guide for details on how to map answers to nested questions and other complex cases. There's further ways to customize this mapping from csv to answers specified in the user guide. TODO: link to user guide Nothing much should change at this point but feel free to run a test build regardless. Generating Grades \u00b6 Finally we need to specify how to get our grades back out. Currently only a csv output format is supported. Add the following to FakeClassroom in fake_class/setup.py : 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 grades = CSVGrades . with_options ( file_name = \"grades.csv\" , columns = { 'Student ID' : 'student_id' , 'name' : 'name' , 'Problem 1: Answer' : 'addition-question.answer' , 'Problem 1: Correct Answer' : 'addition-question.correct' , 'Problem 1: Total Weight' : 'addition-question.total_weight' , 'Problem 1: Ungraded Points' : 'addition-question.ungraded_points' , 'Problem 1: Weighted Points' : 'addition-question.weighted_points' , 'Problem 1: Points' : 'addition-question.points' , 'Problem 2A: Points' : 'poly-question.graph.points' , 'Problem 2B: Points' : 'poly-question.factors.points' , 'Problem 3: Points' : 'graph-question.points' , 'Problem 4: Points' : 'matrix-question.points' , 'Problem 5: Points' : 'csp-question.points' , 'Total Weight' : 'total_weight' , 'Points' : 'weighted_points' , 'Percent Correct' : 'percent_grade' , 'Percent Ungraded' : 'percent_ungraded' } ) This specifies how to dump grade information into a csv file, with the following fields: file_name : The name of the file to be produced. It will end up in ~out/class-fake-class/ once it has been generated. columns : This is way to specify each column of the output grades.csv . Each key in the dictionary is the column name and the value is a string specifying what information goes in that column. There are a few key-words in the specification string: student_id : The student's identifier name : The student's name precent_grade : The percentage grade for the exam For each problem, or the test as a whole, you can specify certain information to print. <problem>.answer : The student provided answer <problem>.correct : The correct answer, if specified by the problem definition. <problem>.total_weight : The weight of the problem in the exam. <problem>.ungraded_weight : The weight of problems with no grade assigned <problem>.points : The points given for the question. Where <problem> is the name of a problem in various questions values. Nested problems are delimited with . . More details on available specifiers can be found in the users guide. TODO: link user_guide Complete Current fake_class/setup.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 from exam_gen import * import attr class FakeClassroom ( Classroom ): roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) answers = CSVAnswers . with_options ( file_name = \"exam_answers.csv\" , ident_column = \"sis_id\" , attempt_column = \"attempt\" , mapping = { 'graph-question' : \"Problem 3\" , 'matrix-question' : \"Problem 4\" , 'csp-question' : \"Problem 5\" } ) grades = CSVGrades . with_options ( file_name = \"grades.csv\" , columns = { 'Student ID' : 'student_id' , 'name' : 'name' , 'Problem 1: Answer' : 'addition-question.answer' , 'Problem 1: Correct Answer' : 'addition-question.correct' , 'Problem 1: Total Weight' : 'addition-question.total_weight' , 'Problem 1: Ungraded Points' : 'addition-question.ungraded_points' , 'Problem 1: Weighted Points' : 'addition-question.weighted_points' , 'Problem 1: Points' : 'addition-question.points' , # 'Problem 1: Percent Grade': 'addition-question.percent_grade', # 'Problem 1: Percent Ungraded': 'addition-question.percent_ungraded', # 'Problem 2A: Answer': 'poly-question.graph.answer', # 'Problem 2A: Correct Answer': 'poly-question.graph.correct', # 'Problem 2A: Total Weight': 'poly-question.graph.total_weight', # 'Problem 2A: Ungraded Points': 'poly-question.graph.ungraded_points', # 'Problem 2A: Weighted Points': 'poly-question.graph.weighted_points', 'Problem 2A: Points' : 'poly-question.graph.points' , # 'Problem 2B: Answer': 'poly-question.factors.answer', # 'Problem 2B: Correct Answer': 'poly-question.factors.correct', # 'Problem 2B: Total Weight': 'poly-question.factors.total_weight', # 'Problem 2B: Ungraded Points': 'poly-question.factors.ungraded_points', # 'Problem 2B: Weighted Points': 'poly-question.factors.weighted_points', 'Problem 2B: Points' : 'poly-question.factors.points' , # 'Problem 3: Answer': 'graph-question.answer', # 'Problem 3: Correct Answer': 'graph-question.correct', # 'Problem 3: Total Weight': 'graph-question.total_weight', # 'Problem 3: Ungraded Points': 'graph-question.ungraded_points', # 'Problem 3: Weighted Points': 'graph-question.weighted_points', 'Problem 3: Points' : 'graph-question.points' , # 'Problem 3: Percent Grade': 'graph-question.percent_grade', # 'Problem 3: Percent Ungraded': 'graph-question.percent_ungraded', # 'Problem 4: Answer': 'matrix-question.answer', # 'Problem 4: Correct Answer': 'matrix-question.correct', # 'Problem 4: Total Weight': 'matrix-question.total_weight', # 'Problem 4: Ungraded Points': 'matrix-question.ungraded_points', # 'Problem 4: Weighted Points': 'matrix-question.weighted_points', 'Problem 4: Points' : 'matrix-question.points' , # 'Problem 4: Percent Grade': 'matrix-question.percent_grade', # 'Problem 4: Percent Ungraded': 'matrix-question.percent_ungraded', # 'Problem 5: Answer': 'csp-question.answer', # 'Problem 5: Correct Answer': 'csp-question.correct', # 'Problem 5: Total Weight': 'csp-question.total_weight', # 'Problem 5: Ungraded Points': 'csp-question.ungraded_points', # 'Problem 5: Weighted Points': 'csp-question.weighted_points', 'Problem 5: Points' : 'csp-question.points' , # 'Problem 5: Percent Grade': 'csp-question.percent_grade', # 'Problem 5: Percent Ungraded': 'csp-question.percent_ungraded', 'Total Weight' : 'total_weight' , 'Points' : 'weighted_points' , 'Percent Correct' : 'percent_grade' , 'Percent Ungraded' : 'percent_ungraded' } ) # Alternate format, # # fake_classroom = Classroom.with_options( # roster = BCoursesCSVRoster.with_options( # file_name=\"class-1.csv\" # ), # root_file = __file__ # ) Test this by generating the grades for this class: $ ./exam.py cleanup $ ./exam.py calculate-grades:fake-class Contents of ~out/class-fake-class/grades.csv Student ID,name,Problem 1: Answer,Problem 1: Correct Answer,Problem 1: Total Weight,Problem 1: Ungraded Points,Problem 1: Weighted Points,Problem 1: Points,Problem 1: Percent Grade,Problem 1: Percent Ungraded,Problem 2A: Answer,Problem 2A: Correct Answer,Problem 2A: Total Weight,Problem 2A: Ungraded Points,Problem 2A: Weighted Points,Problem 2A: Points,Problem 2B: Answer,Problem 2B: Correct Answer,Problem 2B: Total Weight,Problem 2B: Ungraded Points,Problem 2B: Weighted Points,Problem 2B: Points,Problem 3: Answer,Problem 3: Correct Answer,Problem 3: Total Weight,Problem 3: Ungraded Points,Problem 3: Weighted Points,Problem 3: Points,Problem 3: Percent Grade,Problem 3: Percent Ungraded,Problem 4: Answer,Problem 4: Correct Answer,Problem 4: Total Weight,Problem 4: Ungraded Points,Problem 4: Weighted Points,Problem 4: Points,Problem 4: Percent Grade,Problem 4: Percent Ungraded,Problem 5: Answer,Problem 5: Correct Answer,Problem 5: Total Weight,Problem 5: Ungraded Points,Problem 5: Weighted Points,Problem 5: Points,Problem 5: Percent Grade,Problem 5: Percent Ungraded,Total Weight,Points,Percent Correct,Percent Ungraded 49234720,\"Wilkins, Willa\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,,,2,2,0,0,0.0,1.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,0,0.0,1.0 49232758,\"Smith, Abby\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,,,2,2,0,0,0.0,1.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,0,0.0,1.0 49233588,\"Calderon, Reema\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,,,2,2,0,0,0.0,1.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,0,0.0,1.0 49234574,\"Meza, Neave\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,,,2,2,0,0,0.0,1.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,0,0.0,1.0 49232540,\"Rios, Christine\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,\"A, B, C\",\"A, B, C\",2,0,2.0,2.0,1.0,0.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,2.0,0.4,0.6 49232926,\"House, Sharon\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,\"C, D, E\",\"B, D, E\",2,0,2.0,2.0,1.0,0.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,2.0,0.4,0.6 49234288,\"Ahmad, Ezmae\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,\"B, C, D, E\",\"C, D, E\",2,0,2.0,2.0,1.0,0.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,2.0,0.4,0.6 49233409,\"Phelps, Mehdi\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,,,2,2,0,0,0.0,1.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,0,0.0,1.0 49232948,\"Mcfarlane, Tracey\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,\"A, B, C\",\"A, C, D\",2,0,2.0,2.0,1.0,0.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,2.0,0.4,0.6 49234533,\"Decker, Adem\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,\"A, D, E\",\"A, D, E\",2,0,2.0,2.0,1.0,0.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,2.0,0.4,0.6 Good job! TODO: link final example zip file","title":"Answers and Scoring"},{"location":"tutorial/answers_and_scoring.html#answers-and-scoring","text":"Here we'll go over loading student answers into the system and generating grades.","title":"Answers and Scoring"},{"location":"tutorial/answers_and_scoring.html#class-reorganization","text":"First though, let's reorganize our files to better separate one class's information from everything else. Make a new directory for our fake class and move over our roster: $ mkdir fake_class $ mv class-1.csv fake_class/ We also can create a new file for this classroom's settings, instead of keeping them inline as part of exam.py : $ touch fake_class/setup.py And load the following contents into that file: Complete Current fake_class/setup.py 1 2 3 4 5 6 7 8 from exam_gen import * import attr class FakeClassroom ( Classroom ): roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) Note how we're creating a new class FakeClassroom that inherits from Classroom . This is one way to overload the same settings that one can with with_options . We also need to update exam.py appropriately: First by adding an appropriate import statement: 9 from fake_class.setup import * Then by updating the list of classes to use FakeClassroom directly instead of configuring a new classroom on the fly with with_options : 13 14 15 classes = { 'fake-class' : FakeClassroom , } Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #!/usr/bin/env -S pipenv run python3 from exam_gen import * from addition_question import * from poly_question.question import * from graph_question.question import * from matrix_question.question import * from csp_question.question import * from fake_class.setup import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : FakeClassroom , } questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion , 'graph-question' : GraphQuestion , 'matrix-question' : MatrixQuestion , 'csp-question' : CspQuestion } intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) Test whether this works by building an exam as usual: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios At this point nothing substantive has changed, we've just been able to move all the class specific information into a subfolder.","title":"Class Reorganization"},{"location":"tutorial/answers_and_scoring.html#loading-student-answers","text":"For the next steps we're going to take student provided answers and import them into the tool. The user guide shows how to set up various automated testing tools for use with this library. TODO: link to the user guide From here on out we'll be assuming that you followed the guide for Canvas/BCourses and using the corresponding exported answer data. We have made an example answer sheet for use with our fake class roster. You should load it into fake_class/exam_answers.csv with the following contents: Complete Current fake_class/exam_answers.csv 1 2 3 4 5 6 7 8 9 10 11 12 13 14 name,sis_id,submitted,attempt,117606621: Problem 1: Sum of All Answers,0,\"117606759: Problem 2A: Sketch the Polynomial (This text is visible to student) \\n Note: This type of question is a bit wonky w/ multiple submissions. All files must be uploaded on your final submission of the exam, otherwise the proctors won't see them.\",0,117606898: Problem 2B: What are the factors of the polynomial?,0,117607010: Problem 3: Masks of a bipartite graph,0,117607036: Problem 4: Independent columns,0,117607116: Problem 5: Constraint Satisfaction,0,n correct,n incorrect,score \"House, Sharon\",49232926,2021-07-12 20:01:01 UTC,1,519,0,,0,,0,\"C,D,E\",0,D,0,\"B,D,F,H,I,J,N\",0,2,5,0 \"Mcfarlane, Tracey\",49232948,2021-07-12 19:59:47 UTC,1,593,0,,0,,0,\"A,B,C\",0,B,0,\"A,D,F,G,I,J\",0,2,5,0 \"Decker, Adem\",49234533,2021-07-12 19:58:33 UTC,1,623,0,,0,,0,\"A,D,E\",0,D,0,\"B,C,F,H,I,N\",0,2,5,0 \"Rios, Christine\",49232540,2021-07-12 19:57:17 UTC,1,638,0,,0,(x -1)(x +5)(x + 5)(x + 1),0,\"A,B,C\",0,D,0,\"B,C,F,H,I,J\",0,2,5,0 \"Meza, Neave\",49234574,2021-07-12 19:56:08 UTC,2,,0,,0,,0,,0,D,0,\"B,C,F,H,I,J\",0,1,6,0 \"Meza, Neave\",49234574,2021-07-12 19:55:15 UTC,1,4432,0,,0,,0,\"A,B,D\",0,,0,,0,2,5,0 \"Ahmad, Ezmae\",49234288,2021-07-12 19:54:27 UTC,1,625,0,,0,x * (x + 3) ^2 * (x - 4),0,\"B,C,D,E\",0,D,0,\"B,D,F,G,I,L,N\",0,2,5,0 \"Wilkins, Willa\",49234720,2021-07-12 19:51:25 UTC,2,508,0,,0,,0,\"B,C,E\",0,,0,\"B,C,E,G,I,J,L,N\",0,2,5,0 \"Wilkins, Willa\",49234720,2021-07-12 19:50:15 UTC,1,112,0,,0,(x -3)(x +1),0,\"B,C,E\",0,B,0,\"A,C,G,M,O\",0,2,5,0 \"Calderon, Reema\",49233588,2021-07-12 19:48:46 UTC,4,,0,,0,(x -3)^2 * x * (x + 3),0,,0,,0,\"B,C,E,H,I,N\",0,2,5,0 \"Calderon, Reema\",49233588,2021-07-12 19:47:14 UTC,3,609,0,,0,,0,\"A,B\",0,D,0,,0,2,5,0 \"Calderon, Reema\",49233588,2021-07-12 19:46:32 UTC,2,1234,0,,0,123,0,\"B,E\",0,,0,\"N,O\",0,3,4,0 \"Calderon, Reema\",49233588,2021-07-12 19:45:55 UTC,1,112,0,,0,x^2 (x+3),0,\"B,D,E\",0,,0,\"B,C,F\",0,3,4,0 We also need to specify relevant details about how to associate columns of the csy to problems in our exam. Add the following to FakeClassroom : 11 12 13 14 15 16 17 18 19 20 answers = CSVAnswers . with_options ( file_name = \"exam_answers.csv\" , ident_column = \"sis_id\" , attempt_column = \"attempt\" , mapping = { 'graph-question' : \"Problem 3\" , 'matrix-question' : \"Problem 4\" , 'csp-question' : \"Problem 5\" } ) The CSVAnswers class here is used for decoding csv files, associating submissions with students, and associating columns with problems. Let's break down the various fields we set: file_name : As expected this is the CSV with all the answers to read in. It's specified relative to where FakeClassroom is define. (i.e. in fake_class/setup.py so in the fake_class/ folder.) ident_column : This is the column with the student's unique identifier. Here's its saying that the sis_id column in the csv is how we distinguish between students. attempt_column : This is the column that determines which submission attempt corresponds to each row of the column. It ensures the latest submission for each problem is the one that's graded. mapping : This tells us how we should assign columns from the csv to specific problems. The key is the problem name and value is a unique substring of the column in the csv. We're only mapping the three multiple choice questions over since those are the only auto-gradable ones. See the user guide for details on how to map answers to nested questions and other complex cases. There's further ways to customize this mapping from csv to answers specified in the user guide. TODO: link to user guide Nothing much should change at this point but feel free to run a test build regardless.","title":"Loading Student Answers"},{"location":"tutorial/answers_and_scoring.html#generating-grades","text":"Finally we need to specify how to get our grades back out. Currently only a csv output format is supported. Add the following to FakeClassroom in fake_class/setup.py : 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 grades = CSVGrades . with_options ( file_name = \"grades.csv\" , columns = { 'Student ID' : 'student_id' , 'name' : 'name' , 'Problem 1: Answer' : 'addition-question.answer' , 'Problem 1: Correct Answer' : 'addition-question.correct' , 'Problem 1: Total Weight' : 'addition-question.total_weight' , 'Problem 1: Ungraded Points' : 'addition-question.ungraded_points' , 'Problem 1: Weighted Points' : 'addition-question.weighted_points' , 'Problem 1: Points' : 'addition-question.points' , 'Problem 2A: Points' : 'poly-question.graph.points' , 'Problem 2B: Points' : 'poly-question.factors.points' , 'Problem 3: Points' : 'graph-question.points' , 'Problem 4: Points' : 'matrix-question.points' , 'Problem 5: Points' : 'csp-question.points' , 'Total Weight' : 'total_weight' , 'Points' : 'weighted_points' , 'Percent Correct' : 'percent_grade' , 'Percent Ungraded' : 'percent_ungraded' } ) This specifies how to dump grade information into a csv file, with the following fields: file_name : The name of the file to be produced. It will end up in ~out/class-fake-class/ once it has been generated. columns : This is way to specify each column of the output grades.csv . Each key in the dictionary is the column name and the value is a string specifying what information goes in that column. There are a few key-words in the specification string: student_id : The student's identifier name : The student's name precent_grade : The percentage grade for the exam For each problem, or the test as a whole, you can specify certain information to print. <problem>.answer : The student provided answer <problem>.correct : The correct answer, if specified by the problem definition. <problem>.total_weight : The weight of the problem in the exam. <problem>.ungraded_weight : The weight of problems with no grade assigned <problem>.points : The points given for the question. Where <problem> is the name of a problem in various questions values. Nested problems are delimited with . . More details on available specifiers can be found in the users guide. TODO: link user_guide Complete Current fake_class/setup.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 from exam_gen import * import attr class FakeClassroom ( Classroom ): roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) answers = CSVAnswers . with_options ( file_name = \"exam_answers.csv\" , ident_column = \"sis_id\" , attempt_column = \"attempt\" , mapping = { 'graph-question' : \"Problem 3\" , 'matrix-question' : \"Problem 4\" , 'csp-question' : \"Problem 5\" } ) grades = CSVGrades . with_options ( file_name = \"grades.csv\" , columns = { 'Student ID' : 'student_id' , 'name' : 'name' , 'Problem 1: Answer' : 'addition-question.answer' , 'Problem 1: Correct Answer' : 'addition-question.correct' , 'Problem 1: Total Weight' : 'addition-question.total_weight' , 'Problem 1: Ungraded Points' : 'addition-question.ungraded_points' , 'Problem 1: Weighted Points' : 'addition-question.weighted_points' , 'Problem 1: Points' : 'addition-question.points' , # 'Problem 1: Percent Grade': 'addition-question.percent_grade', # 'Problem 1: Percent Ungraded': 'addition-question.percent_ungraded', # 'Problem 2A: Answer': 'poly-question.graph.answer', # 'Problem 2A: Correct Answer': 'poly-question.graph.correct', # 'Problem 2A: Total Weight': 'poly-question.graph.total_weight', # 'Problem 2A: Ungraded Points': 'poly-question.graph.ungraded_points', # 'Problem 2A: Weighted Points': 'poly-question.graph.weighted_points', 'Problem 2A: Points' : 'poly-question.graph.points' , # 'Problem 2B: Answer': 'poly-question.factors.answer', # 'Problem 2B: Correct Answer': 'poly-question.factors.correct', # 'Problem 2B: Total Weight': 'poly-question.factors.total_weight', # 'Problem 2B: Ungraded Points': 'poly-question.factors.ungraded_points', # 'Problem 2B: Weighted Points': 'poly-question.factors.weighted_points', 'Problem 2B: Points' : 'poly-question.factors.points' , # 'Problem 3: Answer': 'graph-question.answer', # 'Problem 3: Correct Answer': 'graph-question.correct', # 'Problem 3: Total Weight': 'graph-question.total_weight', # 'Problem 3: Ungraded Points': 'graph-question.ungraded_points', # 'Problem 3: Weighted Points': 'graph-question.weighted_points', 'Problem 3: Points' : 'graph-question.points' , # 'Problem 3: Percent Grade': 'graph-question.percent_grade', # 'Problem 3: Percent Ungraded': 'graph-question.percent_ungraded', # 'Problem 4: Answer': 'matrix-question.answer', # 'Problem 4: Correct Answer': 'matrix-question.correct', # 'Problem 4: Total Weight': 'matrix-question.total_weight', # 'Problem 4: Ungraded Points': 'matrix-question.ungraded_points', # 'Problem 4: Weighted Points': 'matrix-question.weighted_points', 'Problem 4: Points' : 'matrix-question.points' , # 'Problem 4: Percent Grade': 'matrix-question.percent_grade', # 'Problem 4: Percent Ungraded': 'matrix-question.percent_ungraded', # 'Problem 5: Answer': 'csp-question.answer', # 'Problem 5: Correct Answer': 'csp-question.correct', # 'Problem 5: Total Weight': 'csp-question.total_weight', # 'Problem 5: Ungraded Points': 'csp-question.ungraded_points', # 'Problem 5: Weighted Points': 'csp-question.weighted_points', 'Problem 5: Points' : 'csp-question.points' , # 'Problem 5: Percent Grade': 'csp-question.percent_grade', # 'Problem 5: Percent Ungraded': 'csp-question.percent_ungraded', 'Total Weight' : 'total_weight' , 'Points' : 'weighted_points' , 'Percent Correct' : 'percent_grade' , 'Percent Ungraded' : 'percent_ungraded' } ) # Alternate format, # # fake_classroom = Classroom.with_options( # roster = BCoursesCSVRoster.with_options( # file_name=\"class-1.csv\" # ), # root_file = __file__ # ) Test this by generating the grades for this class: $ ./exam.py cleanup $ ./exam.py calculate-grades:fake-class Contents of ~out/class-fake-class/grades.csv Student ID,name,Problem 1: Answer,Problem 1: Correct Answer,Problem 1: Total Weight,Problem 1: Ungraded Points,Problem 1: Weighted Points,Problem 1: Points,Problem 1: Percent Grade,Problem 1: Percent Ungraded,Problem 2A: Answer,Problem 2A: Correct Answer,Problem 2A: Total Weight,Problem 2A: Ungraded Points,Problem 2A: Weighted Points,Problem 2A: Points,Problem 2B: Answer,Problem 2B: Correct Answer,Problem 2B: Total Weight,Problem 2B: Ungraded Points,Problem 2B: Weighted Points,Problem 2B: Points,Problem 3: Answer,Problem 3: Correct Answer,Problem 3: Total Weight,Problem 3: Ungraded Points,Problem 3: Weighted Points,Problem 3: Points,Problem 3: Percent Grade,Problem 3: Percent Ungraded,Problem 4: Answer,Problem 4: Correct Answer,Problem 4: Total Weight,Problem 4: Ungraded Points,Problem 4: Weighted Points,Problem 4: Points,Problem 4: Percent Grade,Problem 4: Percent Ungraded,Problem 5: Answer,Problem 5: Correct Answer,Problem 5: Total Weight,Problem 5: Ungraded Points,Problem 5: Weighted Points,Problem 5: Points,Problem 5: Percent Grade,Problem 5: Percent Ungraded,Total Weight,Points,Percent Correct,Percent Ungraded 49234720,\"Wilkins, Willa\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,,,2,2,0,0,0.0,1.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,0,0.0,1.0 49232758,\"Smith, Abby\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,,,2,2,0,0,0.0,1.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,0,0.0,1.0 49233588,\"Calderon, Reema\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,,,2,2,0,0,0.0,1.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,0,0.0,1.0 49234574,\"Meza, Neave\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,,,2,2,0,0,0.0,1.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,0,0.0,1.0 49232540,\"Rios, Christine\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,\"A, B, C\",\"A, B, C\",2,0,2.0,2.0,1.0,0.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,2.0,0.4,0.6 49232926,\"House, Sharon\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,\"C, D, E\",\"B, D, E\",2,0,2.0,2.0,1.0,0.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,2.0,0.4,0.6 49234288,\"Ahmad, Ezmae\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,\"B, C, D, E\",\"C, D, E\",2,0,2.0,2.0,1.0,0.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,2.0,0.4,0.6 49233409,\"Phelps, Mehdi\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,,,2,2,0,0,0.0,1.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,0,0.0,1.0 49232948,\"Mcfarlane, Tracey\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,\"A, B, C\",\"A, C, D\",2,0,2.0,2.0,1.0,0.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,2.0,0.4,0.6 49234533,\"Decker, Adem\",,,0,0,0,,0,0,,,0,0,0,,,,0,0,0,,\"A, D, E\",\"A, D, E\",2,0,2.0,2.0,1.0,0.0,,,1,1,0,0,0.0,1.0,,,2,2,0,0,0.0,1.0,5,2.0,0.4,0.6 Good job! TODO: link final example zip file","title":"Generating Grades"},{"location":"tutorial/classrooms_and_rosters.html","text":"Adding a Classroom and Roster to the Project \u00b6 Classrooms are how we manage groups of students who take an instance of the exams. The core of each classroom is a roster of students that our library can parse. Create new class-1.csv in the project directory with the following content: Name,Student ID,Email Address \"Wilkins, Willa\",49234720,awilkins@berkeley.edu \"Smith, Abby\",49232758,ysmith@berkeley.edu \"Calderon, Reema\",49233588,acalderon@berkeley.edu \"Meza, Neave\",49234574,emeza@berkeley.edu \"Rios, Christine\",49232540,erios@berkeley.edu \"House, Sharon\",49232926,nhouse@berkeley.edu \"Ahmad, Ezmae\",49234288,eahmad@berkeley.edu \"Phelps, Mehdi\",49233409,iphelps@berkeley.edu \"Mcfarlane, Tracey\",49232948,ymcfarlane@berkeley.edu \"Decker, Adem\",49234533,mdecker@berkeley.edu This is a roster of fake students in a version of the BCourses format that we'll be using for the tutorial. In exam.py change line 7 to the following: 7 8 9 classes = { 'fake-class' : Classroom } This tells our system that there's a Classroom called fake-class that we'll be building assignments for. However left as it this would throw an error as each Classroom needs a roster of students. To fix this we'll specify a roster based on class-1.csv . There are multiple ways to parse a roster so we'll be specifying the parser we'll use as well by changing line 8 to: 8 9 10 11 12 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), Note how our roster is BCoursesCSVRoster rather than some more generic class. This subclass specifically describes how to parse rosters from BCourses, other formats would require other parsers. The dev guide will cover this in more detail. Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #!/usr/bin/env -S pipenv run python3 from exam_gen import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), } questions = {} intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) Testing our Minimal Assignment \u00b6 We can run through some basic commands to test our setup. To see what new commands we have available: $ ./exam.py list Result of ./exam.py list 1 2 3 4 5 6 build-exam Build all the exams for each student. build-exam:class-1 Build the exams for class 'class-1'. build-solution Build all the answer keys for each student. build-solution:class-1 Build the answer keys for class 'class-1'. cleanup Clean all generated files. (e.g. 'rm -rf ~*') parse-roster parse the class rosters (incl. answer and score data if available) We now have build actions that cover an entire class's students. We can break this down further with: $ ./exam.py list --all Result of ./exam.py list --all 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 build-exam Build all the exams for each student. build-exam:class-1 Build the exams for class 'class-1'. build-exam:class-1:acalderon build-exam:class-1:awilkins build-exam:class-1:eahmad build-exam:class-1:emeza build-exam:class-1:erios build-exam:class-1:iphelps build-exam:class-1:mdecker build-exam:class-1:nhouse build-exam:class-1:ymcfarlane build-exam:class-1:ysmith build-solution Build all the answer keys for each student. build-solution:class-1 Build the answer keys for class 'class-1'. build-solution:class-1:acalderon build-solution:class-1:awilkins build-solution:class-1:eahmad build-solution:class-1:emeza build-solution:class-1:erios build-solution:class-1:iphelps build-solution:class-1:mdecker build-solution:class-1:nhouse build-solution:class-1:ymcfarlane build-solution:class-1:ysmith cleanup Clean all generated files. (e.g. 'rm -rf ~*') parse-roster parse the class rosters (incl. answer and score data if available) parse-roster:class-1 We even have actions to build an exam or solution key for each individual student. To test roster parsing we can run: $ ./exam.py parse-roster You should see . parse-roster:fake-class on the terminal, but more importantly, a ~data/ directory should have been created with a number of subdirectories and files. Result of tree ~data ~data/ \u2514\u2500\u2500 class-fake-class \u251c\u2500\u2500 roster.yaml \u251c\u2500\u2500 student-acalderon \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-awilkins \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-eahmad \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-emeza \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-erios \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-iphelps \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-mdecker \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-nhouse \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-ymcfarlane \u2502 \u2514\u2500\u2500 data.yaml \u2514\u2500\u2500 student-ysmith \u2514\u2500\u2500 data.yaml Looking at ~data/class-fake-class/roster.yaml and the various data.yaml files will show a somewhat pretty printed representation of the class and student information. This will be useful for debugging later on. We can clean up out previous work and build a single exam with: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios This will produce a number of files in ~data , ~build , and ~out . Result of tree ~* ~build \u2514\u2500\u2500 class-fake-class \u2514\u2500\u2500 student-erios \u2514\u2500\u2500 exam-exam \u251c\u2500\u2500 output.aux \u251c\u2500\u2500 output-intro.tex \u251c\u2500\u2500 output.log \u251c\u2500\u2500 output.out \u251c\u2500\u2500 output.pdf \u2514\u2500\u2500 output.tex ~data \u2514\u2500\u2500 class-fake-class \u251c\u2500\u2500 roster.yaml \u251c\u2500\u2500 student-acalderon \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-awilkins \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-eahmad \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-emeza \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-erios \u2502 \u251c\u2500\u2500 data.yaml \u2502 \u2514\u2500\u2500 exam-exam \u2502 \u251c\u2500\u2500 final-context-output-intro.yaml \u2502 \u251c\u2500\u2500 final-context-output.yaml \u2502 \u251c\u2500\u2500 finalize-log.yaml \u2502 \u251c\u2500\u2500 initial-context-output-intro.yaml \u2502 \u251c\u2500\u2500 initial-context-output.yaml \u2502 \u251c\u2500\u2500 output-log.yaml \u2502 \u251c\u2500\u2500 post-finalize-doc.yaml \u2502 \u251c\u2500\u2500 post-init-doc.yaml \u2502 \u251c\u2500\u2500 post-setup-doc.yaml \u2502 \u251c\u2500\u2500 post-template-doc.yaml \u2502 \u251c\u2500\u2500 pre-finalize-doc.yaml \u2502 \u251c\u2500\u2500 pre-init-doc.yaml \u2502 \u251c\u2500\u2500 pre-setup-doc.yaml \u2502 \u251c\u2500\u2500 pre-template-doc.yaml \u2502 \u251c\u2500\u2500 result-output-intro.tex \u2502 \u251c\u2500\u2500 result-output.tex \u2502 \u251c\u2500\u2500 setup-log.yaml \u2502 \u251c\u2500\u2500 template-output-intro.jn2.tex \u2502 \u251c\u2500\u2500 template-output.jn2.tex \u2502 \u251c\u2500\u2500 template-result.yaml \u2502 \u2514\u2500\u2500 template-spec.yaml \u251c\u2500\u2500 student-iphelps \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-mdecker \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-nhouse \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-ymcfarlane \u2502 \u2514\u2500\u2500 data.yaml \u2514\u2500\u2500 student-ysmith \u2514\u2500\u2500 data.yaml ~out \u2514\u2500\u2500 exam-exam \u2514\u2500\u2500 class-fake-class \u2514\u2500\u2500 erios.pdf Finally we can look at the final output in ~out/exam-exam/class-fake-class/erios.pdf there's an exam with only the title page and our introduction text. Contents of erios.pdf The logging and debug data in ~data/class-fake-class/student-erios/exam-exam/ captures a lot of the intermediate state involved in building the exam, the user guide will provide a deeper overview of this and how it can be used. There is also a build directory in ~build/class-fake-class/student-erios/exam-exam/ which is where we try to provide an isolated environment for pdflatex or other external build tool. This is also the working directory when user-provided code to generate files is run.","title":"Classrooms and Rosters"},{"location":"tutorial/classrooms_and_rosters.html#adding-a-classroom-and-roster-to-the-project","text":"Classrooms are how we manage groups of students who take an instance of the exams. The core of each classroom is a roster of students that our library can parse. Create new class-1.csv in the project directory with the following content: Name,Student ID,Email Address \"Wilkins, Willa\",49234720,awilkins@berkeley.edu \"Smith, Abby\",49232758,ysmith@berkeley.edu \"Calderon, Reema\",49233588,acalderon@berkeley.edu \"Meza, Neave\",49234574,emeza@berkeley.edu \"Rios, Christine\",49232540,erios@berkeley.edu \"House, Sharon\",49232926,nhouse@berkeley.edu \"Ahmad, Ezmae\",49234288,eahmad@berkeley.edu \"Phelps, Mehdi\",49233409,iphelps@berkeley.edu \"Mcfarlane, Tracey\",49232948,ymcfarlane@berkeley.edu \"Decker, Adem\",49234533,mdecker@berkeley.edu This is a roster of fake students in a version of the BCourses format that we'll be using for the tutorial. In exam.py change line 7 to the following: 7 8 9 classes = { 'fake-class' : Classroom } This tells our system that there's a Classroom called fake-class that we'll be building assignments for. However left as it this would throw an error as each Classroom needs a roster of students. To fix this we'll specify a roster based on class-1.csv . There are multiple ways to parse a roster so we'll be specifying the parser we'll use as well by changing line 8 to: 8 9 10 11 12 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), Note how our roster is BCoursesCSVRoster rather than some more generic class. This subclass specifically describes how to parse rosters from BCourses, other formats would require other parsers. The dev guide will cover this in more detail. Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #!/usr/bin/env -S pipenv run python3 from exam_gen import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), } questions = {} intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ())","title":"Adding a Classroom and Roster to the Project"},{"location":"tutorial/classrooms_and_rosters.html#testing-our-minimal-assignment","text":"We can run through some basic commands to test our setup. To see what new commands we have available: $ ./exam.py list Result of ./exam.py list 1 2 3 4 5 6 build-exam Build all the exams for each student. build-exam:class-1 Build the exams for class 'class-1'. build-solution Build all the answer keys for each student. build-solution:class-1 Build the answer keys for class 'class-1'. cleanup Clean all generated files. (e.g. 'rm -rf ~*') parse-roster parse the class rosters (incl. answer and score data if available) We now have build actions that cover an entire class's students. We can break this down further with: $ ./exam.py list --all Result of ./exam.py list --all 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 build-exam Build all the exams for each student. build-exam:class-1 Build the exams for class 'class-1'. build-exam:class-1:acalderon build-exam:class-1:awilkins build-exam:class-1:eahmad build-exam:class-1:emeza build-exam:class-1:erios build-exam:class-1:iphelps build-exam:class-1:mdecker build-exam:class-1:nhouse build-exam:class-1:ymcfarlane build-exam:class-1:ysmith build-solution Build all the answer keys for each student. build-solution:class-1 Build the answer keys for class 'class-1'. build-solution:class-1:acalderon build-solution:class-1:awilkins build-solution:class-1:eahmad build-solution:class-1:emeza build-solution:class-1:erios build-solution:class-1:iphelps build-solution:class-1:mdecker build-solution:class-1:nhouse build-solution:class-1:ymcfarlane build-solution:class-1:ysmith cleanup Clean all generated files. (e.g. 'rm -rf ~*') parse-roster parse the class rosters (incl. answer and score data if available) parse-roster:class-1 We even have actions to build an exam or solution key for each individual student. To test roster parsing we can run: $ ./exam.py parse-roster You should see . parse-roster:fake-class on the terminal, but more importantly, a ~data/ directory should have been created with a number of subdirectories and files. Result of tree ~data ~data/ \u2514\u2500\u2500 class-fake-class \u251c\u2500\u2500 roster.yaml \u251c\u2500\u2500 student-acalderon \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-awilkins \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-eahmad \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-emeza \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-erios \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-iphelps \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-mdecker \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-nhouse \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-ymcfarlane \u2502 \u2514\u2500\u2500 data.yaml \u2514\u2500\u2500 student-ysmith \u2514\u2500\u2500 data.yaml Looking at ~data/class-fake-class/roster.yaml and the various data.yaml files will show a somewhat pretty printed representation of the class and student information. This will be useful for debugging later on. We can clean up out previous work and build a single exam with: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios This will produce a number of files in ~data , ~build , and ~out . Result of tree ~* ~build \u2514\u2500\u2500 class-fake-class \u2514\u2500\u2500 student-erios \u2514\u2500\u2500 exam-exam \u251c\u2500\u2500 output.aux \u251c\u2500\u2500 output-intro.tex \u251c\u2500\u2500 output.log \u251c\u2500\u2500 output.out \u251c\u2500\u2500 output.pdf \u2514\u2500\u2500 output.tex ~data \u2514\u2500\u2500 class-fake-class \u251c\u2500\u2500 roster.yaml \u251c\u2500\u2500 student-acalderon \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-awilkins \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-eahmad \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-emeza \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-erios \u2502 \u251c\u2500\u2500 data.yaml \u2502 \u2514\u2500\u2500 exam-exam \u2502 \u251c\u2500\u2500 final-context-output-intro.yaml \u2502 \u251c\u2500\u2500 final-context-output.yaml \u2502 \u251c\u2500\u2500 finalize-log.yaml \u2502 \u251c\u2500\u2500 initial-context-output-intro.yaml \u2502 \u251c\u2500\u2500 initial-context-output.yaml \u2502 \u251c\u2500\u2500 output-log.yaml \u2502 \u251c\u2500\u2500 post-finalize-doc.yaml \u2502 \u251c\u2500\u2500 post-init-doc.yaml \u2502 \u251c\u2500\u2500 post-setup-doc.yaml \u2502 \u251c\u2500\u2500 post-template-doc.yaml \u2502 \u251c\u2500\u2500 pre-finalize-doc.yaml \u2502 \u251c\u2500\u2500 pre-init-doc.yaml \u2502 \u251c\u2500\u2500 pre-setup-doc.yaml \u2502 \u251c\u2500\u2500 pre-template-doc.yaml \u2502 \u251c\u2500\u2500 result-output-intro.tex \u2502 \u251c\u2500\u2500 result-output.tex \u2502 \u251c\u2500\u2500 setup-log.yaml \u2502 \u251c\u2500\u2500 template-output-intro.jn2.tex \u2502 \u251c\u2500\u2500 template-output.jn2.tex \u2502 \u251c\u2500\u2500 template-result.yaml \u2502 \u2514\u2500\u2500 template-spec.yaml \u251c\u2500\u2500 student-iphelps \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-mdecker \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-nhouse \u2502 \u2514\u2500\u2500 data.yaml \u251c\u2500\u2500 student-ymcfarlane \u2502 \u2514\u2500\u2500 data.yaml \u2514\u2500\u2500 student-ysmith \u2514\u2500\u2500 data.yaml ~out \u2514\u2500\u2500 exam-exam \u2514\u2500\u2500 class-fake-class \u2514\u2500\u2500 erios.pdf Finally we can look at the final output in ~out/exam-exam/class-fake-class/erios.pdf there's an exam with only the title page and our introduction text. Contents of erios.pdf The logging and debug data in ~data/class-fake-class/student-erios/exam-exam/ captures a lot of the intermediate state involved in building the exam, the user guide will provide a deeper overview of this and how it can be used. There is also a build directory in ~build/class-fake-class/student-erios/exam-exam/ which is where we try to provide an isolated environment for pdflatex or other external build tool. This is also the working directory when user-provided code to generate files is run.","title":"Testing our Minimal Assignment"},{"location":"tutorial/customization_and_randomization.html","text":"Customizing and Randomizing Questions \u00b6 We'll be adding some additional customization to the question itself in this section of the tutorial, starting from basic use of context variables about the exam and student, through to randomizing the question's values itself. Using Templates for Customization \u00b6 The core of exam_gen is built around the jinja2 library, a templating library designed for HTML but usable for pretty much any text. Most of the text one has to specify for a question or an exam is actually a template which can be modified at runtime. Jinja2's template format has comprehensive documentation available here We can show this by editing addition_question.py so the body will read: 6 7 8 9 10 body . text = r ''' Hello \\texttt{ {{ student['Email Address'] }} }, Welcome to question number {{ number }}. ''' Important Things to Notice Statements between {{ and }} are expressions that will be replaced with their values. student['Email Address'] and number (the question number) are variables the template will have access to when it's rendered. We need to use a space to separate LaTeX's { s from jinja's {{ as with the \\texttt{ {{ on line 7. Generate the exams for different students and see how the different exams each have the appropriate student's email address. $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios You'll find them in ~out/exam-exam/class-fake-class/ . Complete Current addition_question.py 1 2 3 4 5 6 7 8 9 10 11 12 from exam_gen import * class SumQuestion ( LatexDoc , Question ): metadata . name = \"Basic Addition Question\" body . text = r ''' Hello \\texttt{ {{ student['Email Address'] }} }, Welcome to question number {{ number }}. ''' solution . text = \"Placeholder text for the solution of the question.\" Finding Available Template Variables \u00b6 In order to assist in writing templates exam_gen dumps the available variables for each template it renders into the appropriate folder in ~data . If you look in ~data/class-fake-class/student-erios/exam-exam you'll find a number of intermediate files that we generate as a template is created. Result of tree ~data/class-fake-class/student-erios w/ explanation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ~data/class-fake-class/student-erios/ \u251c\u2500\u2500 data.yaml \u2514\u2500\u2500 exam-exam \u251c\u2500\u2500 final-context-output-intro.yaml \u251c\u2500\u2500 final-context-output-questions[addition-question]-body.yaml \u251c\u2500\u2500 final-context-output-questions[addition-question]-solution.yaml \u251c\u2500\u2500 final-context-output-questions[addition-question].yaml \u251c\u2500\u2500 final-context-output.yaml \u251c\u2500\u2500 finalize-log.yaml \u251c\u2500\u2500 initial-context-output-intro.yaml \u251c\u2500\u2500 initial-context-output-questions[addition-question]-body.yaml \u251c\u2500\u2500 initial-context-output-questions[addition-question]-solution.yaml \u251c\u2500\u2500 initial-context-output-questions[addition-question].yaml \u251c\u2500\u2500 initial-context-output.yaml \u251c\u2500\u2500 output-log.yaml \u251c\u2500\u2500 post-finalize-doc.yaml \u251c\u2500\u2500 post-init-doc.yaml \u251c\u2500\u2500 post-setup-doc.yaml \u251c\u2500\u2500 post-template-doc.yaml \u251c\u2500\u2500 pre-finalize-doc.yaml \u251c\u2500\u2500 pre-init-doc.yaml \u251c\u2500\u2500 pre-setup-doc.yaml \u251c\u2500\u2500 pre-template-doc.yaml \u251c\u2500\u2500 result-output-intro.tex \u251c\u2500\u2500 result-output-questions[addition-question]-body.tex \u251c\u2500\u2500 result-output-questions[addition-question]-solution.tex \u251c\u2500\u2500 result-output-questions[addition-question].tex \u251c\u2500\u2500 result-output.tex \u251c\u2500\u2500 setup-log.yaml \u251c\u2500\u2500 template-output-intro.jn2.tex \u251c\u2500\u2500 template-output.jn2.tex \u251c\u2500\u2500 template-output-questions[addition-question]-body.jn2.tex \u251c\u2500\u2500 template-output-questions[addition-question].jn2.tex \u251c\u2500\u2500 template-output-questions[addition-question]-solution.jn2.tex \u251c\u2500\u2500 template-result.yaml \u2514\u2500\u2500 template-spec.yaml The files relevant to template rendering are highlighted and can be split along two axes. The first axis, based on the latter half of the filename, corresponds to the template being rendered: *-output.* : The template for NewExam as a whole, the final output of the build process. *-output-intro.* : The template for NewExam.intro , the introduction text we specify on lines 2-22 of exam.py . (Starting with intro . text = r ''' ) *-output-questions[addition-question].* : The template for SumQuestion . *-output-questions[addition-question]-body.* : The template we specify for SumQuestion.body in addition_question.py in lines 6-10. *-output-questions[addition-question]-solution.* : The template we specify for SumQuestion.solution in addition_question.py in line 12. The tree structure here is intentional. Each template can access variables from its parents and the parents can use final post-rendering results from its children. The second axis, based on the prefix of the filename, tells us what actual data is in the file: template-*.jn2.tex : The raw, un-rendered template used for this portion of the assignment. initial-context-*.yaml : The initial variables available to this template before child templates are rendered. These are all made available to child templates unless they're overridden by those child templates. final-context-*.yaml : These are the variables available to each template when they're rendered. The are the variables you can use in the templates , along with their values for this particular build . We'll break this down further in a moment. result-*.tex : This is final result of each template after the variables in final-context-*.yaml are applied to template-*.jn2.tex . We can look in final-context-output-questions[addition-question]-body.yaml to see what variables we can use when setting body . text . Contents of final-context-output-questions[addition-question]-body.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 assignment : Example Assignment author : J. Doe \\& B. Smith course : TEST 101 date : 12-12-2012 format : exam index : 0 name : Basic Addition Question nesting_depth : 1 number : '1' numbering_depth : a. numbering_scheme : 1a. semester : Fall xx student : Email Address : erios@berkeley.edu Name : Rios, Christine Student ID : '49232540' answer_data : null grade_data : null ident : erios name : Rios, Christine root_seed : d6f585da score_data : null sid : '49232540' student_data : Email Address : erios@berkeley.edu Name : Rios, Christine Student ID : '49232540' name : Rios, Christine sid : '49232540' username : erios username : erios teacher : J. Doe \\& B. Smith Each of the fields above is available for use in the body.text template as part of the context dictionary passed to our templating engine. In general, you can refer to the base level variables directly. For example: {{ teacher }} will use the value on line 32 and be rendered as J. Doe \\& B. Smith . {{ name }} refers to the name of the questions and will use the value on line 7 to render as Basic Addition Question . Nested values can be referenced with both attribute notation {{ foo.bar }} or item lookup notation {{ foo [ 'bar' ] }} when applicable. For example: {{ student.ident }} and {{ student [ 'ident' ] }} both will render as erios based on line 19. On the other hand, as \"Email Address\" has a space in it, we can only use {{ student [ 'Email Address' ] }} to refer to the value on line 14. {{ student.Email Address }} is not syntactically valid. The full explanation on how to refer to context variables is found here along with a bunch of additional template formatting tools like conditionals, loops, and basic arithmetic. Using user_setup to Add New Variables \u00b6 It'll also be useful to add new variables that our templates can use. The primary way to do this is by defining a user_setup function. Add the following to the end of addition_question.py : 14 15 16 17 18 19 20 21 22 23 def user_setup ( self , ** kwargs ): ctxt_vars = dict () ctxt_vars [ 'test_vars' ] = { 'test_str' : 'Hello, testing \\t extbf {TESTING} ' , 'test_int' : 1234 } return ctxt_vars This is the user_setup function that can be defined for every Exam and Question , and is the primary way in which all of these elements can be customized. The user_setup function should always return a dictionary with values that are then added to the template context. Build a new test with these changes: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios There won't be any changes to the actual .pdf file, but we can take a look at final-context-output-questions[addition-question]-body.yaml to see a few new lines: 33 34 35 test_vars : test_int : 1234 test_str : \"Hello, testing \\textbf{TESTING}\" Meaning we can now use {{ test_vars.test_int }} and {{ text_vars.test_str }} in our body template. So let's try that, by changing our addition_question.py as follows: 6 7 8 9 10 11 body . text = r ''' Hello \\texttt{ {{ student['Email Address'] }} }, Here's some test text {{ test_vars.test_str }}. \\\\ And the test integer: ${{test_vars.test_int }}$. ''' And building a new test, as usual: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios TODO: Add image of result. Should be in assets/ already. Whoops, looks like we have some formatting issues. We're not getting proper bold text for \"TESTING\". TODO: Add image of latex error, should be in assets/ This is because of the following line: 20 'test_str' : 'Hello, testing \\t extbf {TESTING} ' , Python is interpreting \\t as a tab rather than the literal slash and t character. We can fix this by making this line a raw string: 20 'test_str' : r 'Hello, testing \\textbf {TESTING} ' , TODO: Add images of the result, should be in assets/ Complete Current addition_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from exam_gen import * class SumQuestion ( LatexDoc , Question ): metadata . name = \"Basic Addition Question\" body . text = r ''' Hello \\texttt{ {{ student['Email Address'] }} }, Here's some test text {{ test_vars.test_str }}. \\\\ And the test integer: ${{test_vars.test_int }}$. ''' solution . text = \"Placeholder text for the solution of the question.\" def user_setup ( self , ** kwargs ): ctxt_vars = dict () ctxt_vars [ 'test_vars' ] = { 'test_str' : r 'Hello, testing \\textbf {TESTING} ' , 'test_int' : 1234 } return ctxt_vars Using the student-specific RNG \u00b6 One of the key reasons to have this library at all is to allow the creation of custom exams for each student as well as custom answer keys. The main way to do this is by using the student specific rng to generate or permute problems and answers, for a quick example we'll just tweak the user setup to use the provided rng. First we need to change the definition of user_setup to pull out the provided random umber generator. 16 def user_setup ( self , rng , ** kwargs ): Note that the parameter has to be named 'rng' and the value will have type random . Random (a builtin python type with docs here ). And we can then replace our test_int variable with a new random one: 21 'test_int' : rng . randint ( 0 , 1000 ) The number generated here is unique to each student and stable through multiple runs of the build system. Any fixed sequence of calls to the rng will be always product the same outputs for each student. TODO: Insert example images, shoudl be in assets/ Complete Current addition_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from exam_gen import * class SumQuestion ( LatexDoc , Question ): metadata . name = \"Basic Addition Question\" body . text = r ''' Hello \\texttt{ {{ student['Email Address'] }} }, Here's some test text {{ test_vars.test_str }}. \\\\ And the test integer: ${{test_vars.test_int }}$. ''' solution . text = \"Placeholder text for the solution of the question.\" def user_setup ( self , rng , ** kwargs ): ctxt_vars = dict () ctxt_vars [ 'test_vars' ] = { 'test_str' : r 'Hello, testing \\textbf {TESTING} ' , 'test_int' : rng . randint ( 0 , 1000 ) } return ctxt_vars In the next section we'll turn this proof-of-concept into an actual exam question with some more advanced use of templates and user_setup .","title":"Customization and Randomization"},{"location":"tutorial/customization_and_randomization.html#customizing-and-randomizing-questions","text":"We'll be adding some additional customization to the question itself in this section of the tutorial, starting from basic use of context variables about the exam and student, through to randomizing the question's values itself.","title":"Customizing and Randomizing Questions"},{"location":"tutorial/customization_and_randomization.html#using-templates-for-customization","text":"The core of exam_gen is built around the jinja2 library, a templating library designed for HTML but usable for pretty much any text. Most of the text one has to specify for a question or an exam is actually a template which can be modified at runtime. Jinja2's template format has comprehensive documentation available here We can show this by editing addition_question.py so the body will read: 6 7 8 9 10 body . text = r ''' Hello \\texttt{ {{ student['Email Address'] }} }, Welcome to question number {{ number }}. ''' Important Things to Notice Statements between {{ and }} are expressions that will be replaced with their values. student['Email Address'] and number (the question number) are variables the template will have access to when it's rendered. We need to use a space to separate LaTeX's { s from jinja's {{ as with the \\texttt{ {{ on line 7. Generate the exams for different students and see how the different exams each have the appropriate student's email address. $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios You'll find them in ~out/exam-exam/class-fake-class/ . Complete Current addition_question.py 1 2 3 4 5 6 7 8 9 10 11 12 from exam_gen import * class SumQuestion ( LatexDoc , Question ): metadata . name = \"Basic Addition Question\" body . text = r ''' Hello \\texttt{ {{ student['Email Address'] }} }, Welcome to question number {{ number }}. ''' solution . text = \"Placeholder text for the solution of the question.\"","title":"Using Templates for Customization"},{"location":"tutorial/customization_and_randomization.html#finding-available-template-variables","text":"In order to assist in writing templates exam_gen dumps the available variables for each template it renders into the appropriate folder in ~data . If you look in ~data/class-fake-class/student-erios/exam-exam you'll find a number of intermediate files that we generate as a template is created. Result of tree ~data/class-fake-class/student-erios w/ explanation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ~data/class-fake-class/student-erios/ \u251c\u2500\u2500 data.yaml \u2514\u2500\u2500 exam-exam \u251c\u2500\u2500 final-context-output-intro.yaml \u251c\u2500\u2500 final-context-output-questions[addition-question]-body.yaml \u251c\u2500\u2500 final-context-output-questions[addition-question]-solution.yaml \u251c\u2500\u2500 final-context-output-questions[addition-question].yaml \u251c\u2500\u2500 final-context-output.yaml \u251c\u2500\u2500 finalize-log.yaml \u251c\u2500\u2500 initial-context-output-intro.yaml \u251c\u2500\u2500 initial-context-output-questions[addition-question]-body.yaml \u251c\u2500\u2500 initial-context-output-questions[addition-question]-solution.yaml \u251c\u2500\u2500 initial-context-output-questions[addition-question].yaml \u251c\u2500\u2500 initial-context-output.yaml \u251c\u2500\u2500 output-log.yaml \u251c\u2500\u2500 post-finalize-doc.yaml \u251c\u2500\u2500 post-init-doc.yaml \u251c\u2500\u2500 post-setup-doc.yaml \u251c\u2500\u2500 post-template-doc.yaml \u251c\u2500\u2500 pre-finalize-doc.yaml \u251c\u2500\u2500 pre-init-doc.yaml \u251c\u2500\u2500 pre-setup-doc.yaml \u251c\u2500\u2500 pre-template-doc.yaml \u251c\u2500\u2500 result-output-intro.tex \u251c\u2500\u2500 result-output-questions[addition-question]-body.tex \u251c\u2500\u2500 result-output-questions[addition-question]-solution.tex \u251c\u2500\u2500 result-output-questions[addition-question].tex \u251c\u2500\u2500 result-output.tex \u251c\u2500\u2500 setup-log.yaml \u251c\u2500\u2500 template-output-intro.jn2.tex \u251c\u2500\u2500 template-output.jn2.tex \u251c\u2500\u2500 template-output-questions[addition-question]-body.jn2.tex \u251c\u2500\u2500 template-output-questions[addition-question].jn2.tex \u251c\u2500\u2500 template-output-questions[addition-question]-solution.jn2.tex \u251c\u2500\u2500 template-result.yaml \u2514\u2500\u2500 template-spec.yaml The files relevant to template rendering are highlighted and can be split along two axes. The first axis, based on the latter half of the filename, corresponds to the template being rendered: *-output.* : The template for NewExam as a whole, the final output of the build process. *-output-intro.* : The template for NewExam.intro , the introduction text we specify on lines 2-22 of exam.py . (Starting with intro . text = r ''' ) *-output-questions[addition-question].* : The template for SumQuestion . *-output-questions[addition-question]-body.* : The template we specify for SumQuestion.body in addition_question.py in lines 6-10. *-output-questions[addition-question]-solution.* : The template we specify for SumQuestion.solution in addition_question.py in line 12. The tree structure here is intentional. Each template can access variables from its parents and the parents can use final post-rendering results from its children. The second axis, based on the prefix of the filename, tells us what actual data is in the file: template-*.jn2.tex : The raw, un-rendered template used for this portion of the assignment. initial-context-*.yaml : The initial variables available to this template before child templates are rendered. These are all made available to child templates unless they're overridden by those child templates. final-context-*.yaml : These are the variables available to each template when they're rendered. The are the variables you can use in the templates , along with their values for this particular build . We'll break this down further in a moment. result-*.tex : This is final result of each template after the variables in final-context-*.yaml are applied to template-*.jn2.tex . We can look in final-context-output-questions[addition-question]-body.yaml to see what variables we can use when setting body . text . Contents of final-context-output-questions[addition-question]-body.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 assignment : Example Assignment author : J. Doe \\& B. Smith course : TEST 101 date : 12-12-2012 format : exam index : 0 name : Basic Addition Question nesting_depth : 1 number : '1' numbering_depth : a. numbering_scheme : 1a. semester : Fall xx student : Email Address : erios@berkeley.edu Name : Rios, Christine Student ID : '49232540' answer_data : null grade_data : null ident : erios name : Rios, Christine root_seed : d6f585da score_data : null sid : '49232540' student_data : Email Address : erios@berkeley.edu Name : Rios, Christine Student ID : '49232540' name : Rios, Christine sid : '49232540' username : erios username : erios teacher : J. Doe \\& B. Smith Each of the fields above is available for use in the body.text template as part of the context dictionary passed to our templating engine. In general, you can refer to the base level variables directly. For example: {{ teacher }} will use the value on line 32 and be rendered as J. Doe \\& B. Smith . {{ name }} refers to the name of the questions and will use the value on line 7 to render as Basic Addition Question . Nested values can be referenced with both attribute notation {{ foo.bar }} or item lookup notation {{ foo [ 'bar' ] }} when applicable. For example: {{ student.ident }} and {{ student [ 'ident' ] }} both will render as erios based on line 19. On the other hand, as \"Email Address\" has a space in it, we can only use {{ student [ 'Email Address' ] }} to refer to the value on line 14. {{ student.Email Address }} is not syntactically valid. The full explanation on how to refer to context variables is found here along with a bunch of additional template formatting tools like conditionals, loops, and basic arithmetic.","title":"Finding Available Template Variables"},{"location":"tutorial/customization_and_randomization.html#using-user_setup-to-add-new-variables","text":"It'll also be useful to add new variables that our templates can use. The primary way to do this is by defining a user_setup function. Add the following to the end of addition_question.py : 14 15 16 17 18 19 20 21 22 23 def user_setup ( self , ** kwargs ): ctxt_vars = dict () ctxt_vars [ 'test_vars' ] = { 'test_str' : 'Hello, testing \\t extbf {TESTING} ' , 'test_int' : 1234 } return ctxt_vars This is the user_setup function that can be defined for every Exam and Question , and is the primary way in which all of these elements can be customized. The user_setup function should always return a dictionary with values that are then added to the template context. Build a new test with these changes: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios There won't be any changes to the actual .pdf file, but we can take a look at final-context-output-questions[addition-question]-body.yaml to see a few new lines: 33 34 35 test_vars : test_int : 1234 test_str : \"Hello, testing \\textbf{TESTING}\" Meaning we can now use {{ test_vars.test_int }} and {{ text_vars.test_str }} in our body template. So let's try that, by changing our addition_question.py as follows: 6 7 8 9 10 11 body . text = r ''' Hello \\texttt{ {{ student['Email Address'] }} }, Here's some test text {{ test_vars.test_str }}. \\\\ And the test integer: ${{test_vars.test_int }}$. ''' And building a new test, as usual: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios TODO: Add image of result. Should be in assets/ already. Whoops, looks like we have some formatting issues. We're not getting proper bold text for \"TESTING\". TODO: Add image of latex error, should be in assets/ This is because of the following line: 20 'test_str' : 'Hello, testing \\t extbf {TESTING} ' , Python is interpreting \\t as a tab rather than the literal slash and t character. We can fix this by making this line a raw string: 20 'test_str' : r 'Hello, testing \\textbf {TESTING} ' , TODO: Add images of the result, should be in assets/ Complete Current addition_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from exam_gen import * class SumQuestion ( LatexDoc , Question ): metadata . name = \"Basic Addition Question\" body . text = r ''' Hello \\texttt{ {{ student['Email Address'] }} }, Here's some test text {{ test_vars.test_str }}. \\\\ And the test integer: ${{test_vars.test_int }}$. ''' solution . text = \"Placeholder text for the solution of the question.\" def user_setup ( self , ** kwargs ): ctxt_vars = dict () ctxt_vars [ 'test_vars' ] = { 'test_str' : r 'Hello, testing \\textbf {TESTING} ' , 'test_int' : 1234 } return ctxt_vars","title":"Using user_setup to Add New Variables"},{"location":"tutorial/customization_and_randomization.html#using-the-student-specific-rng","text":"One of the key reasons to have this library at all is to allow the creation of custom exams for each student as well as custom answer keys. The main way to do this is by using the student specific rng to generate or permute problems and answers, for a quick example we'll just tweak the user setup to use the provided rng. First we need to change the definition of user_setup to pull out the provided random umber generator. 16 def user_setup ( self , rng , ** kwargs ): Note that the parameter has to be named 'rng' and the value will have type random . Random (a builtin python type with docs here ). And we can then replace our test_int variable with a new random one: 21 'test_int' : rng . randint ( 0 , 1000 ) The number generated here is unique to each student and stable through multiple runs of the build system. Any fixed sequence of calls to the rng will be always product the same outputs for each student. TODO: Insert example images, shoudl be in assets/ Complete Current addition_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from exam_gen import * class SumQuestion ( LatexDoc , Question ): metadata . name = \"Basic Addition Question\" body . text = r ''' Hello \\texttt{ {{ student['Email Address'] }} }, Here's some test text {{ test_vars.test_str }}. \\\\ And the test integer: ${{test_vars.test_int }}$. ''' solution . text = \"Placeholder text for the solution of the question.\" def user_setup ( self , rng , ** kwargs ): ctxt_vars = dict () ctxt_vars [ 'test_vars' ] = { 'test_str' : r 'Hello, testing \\textbf {TESTING} ' , 'test_int' : rng . randint ( 0 , 1000 ) } return ctxt_vars In the next section we'll turn this proof-of-concept into an actual exam question with some more advanced use of templates and user_setup .","title":"Using the student-specific RNG"},{"location":"tutorial/env_setup.html","text":"","title":"Env setup"},{"location":"tutorial/external_and_generated_assets.html","text":"External and Generated Assets \u00b6 With the project reorganized we can start adding external assets to our assignment, as well as generating new assets on the fly with python libraries we import. Adding an External File \u00b6 GraphQuestion needs an empty graph for the students to use, so let's add one. Copy the image below into poly_question/empty_grid.png : TODO: image in assets/ Change the template for GraphQuestion to read as follows: 7 8 9 10 11 body . text = r ''' Sketch the polynomial on this graph: \\includegraphics[width=\\textwidth] {empty_grid.png} \\\\ ~ \\\\ ''' Add empty_grid.png to the list of assets used by this sub-question: 13 settings . assets = [ \"empty_grid.png\" ] Complete Current poly_question/graph_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from exam_gen import * from .functions import * class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body . text = r ''' Sketch the polynomial on this graph: \\includegraphics[width=\\textwidth] {empty_grid.png} \\\\ ~ \\\\ ''' settings . assets = [ \"empty_grid.png\" ] def user_setup ( self , rng , ** kwargs ): pass We can now build the exam to see the grid: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios TODO: image in assets/ Files specified in settings.assets will be copied into the build directory of the exam. This can include glob patterns, though the library will throw an error if there's not at least one valid file per glob pattern. Result of tree ~build/class-fake-class/student-erios/exam-exam/ ~build/class-fake-class/student-erios/exam-exam/ \u251c\u2500\u2500 empty_grid.png \u251c\u2500\u2500 output.aux \u251c\u2500\u2500 output-intro.tex \u251c\u2500\u2500 output.log \u251c\u2500\u2500 output.out \u251c\u2500\u2500 output.pdf \u251c\u2500\u2500 output-questions[addition-question]-body.tex \u251c\u2500\u2500 output-questions[addition-question]-solution.tex \u251c\u2500\u2500 output-questions[addition-question].tex \u251c\u2500\u2500 output-questions[poly-question]-body.tex \u251c\u2500\u2500 output-questions[poly-question]-questions[factors]-body.tex \u251c\u2500\u2500 output-questions[poly-question]-questions[factors]-solution.tex \u251c\u2500\u2500 output-questions[poly-question]-questions[factors].tex \u251c\u2500\u2500 output-questions[poly-question]-questions[graph]-body.tex \u251c\u2500\u2500 output-questions[poly-question]-questions[graph]-solution.tex \u251c\u2500\u2500 output-questions[poly-question]-questions[graph].tex \u251c\u2500\u2500 output-questions[poly-question]-solution.tex \u251c\u2500\u2500 output-questions[poly-question].tex \u2514\u2500\u2500 output.tex Generating Student-Specific Files \u00b6 It would be nice to have the expected graph appear in the solution key, but in order to do that we have to dynamically generate the image for each student. The Python standard libraries and exam_gen don't have the facilities for generating new graphs. Instead we'll need to use the matplotlib and numpy libraries. Run the following commands to add them to the project: $ pipenv install matplotlib numpy Result of pipenv install matplotlib numpy Note that your exact output may differ slightly. $ pipenv install matplotlib numpy Installing matplotlib... Adding matplotlib to Pipfile's [packages]... \u2714 Installation Succeeded Installing numpy... Adding numpy to Pipfile's [packages]... \u2714 Installation Succeeded Installing dependencies from Pipfile.lock (c46356)... running exam_gen setup.py \ud83d\udc0d \u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589 0/0 \u2014 00:00:00 To activate this project's virtualenv, run pipenv shell. Alternatively, run a command inside the virtualenv with pipenv run. Now it's possible to import matplotlib and numpy anywhere in our project. Let's do just that in poly_question/functions.py by adding: 19 20 import numpy as np import matplotlib.pyplot as plt We can then use these libraries in a function to generate a new plot of our function. Add the following to poly_question/functions.py : 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def make_poly_graph ( polynomial , out_file , bound = 8 , ticks = 2 ): fig = plt . figure () ax = fig . subplots () x = np . linspace ( bound , - bound , 100 ) y = sum ([ c * ( x ** i ) for ( i , c ) in enumerate ( polynomial )]) ax . plot ( x , y ) ax . set_xlim ( - bound , bound ) ax . set_ylim ( - bound , bound ) ax . set_xticks ( range ( - bound + ticks , bound , ticks )) ax . set_yticks ( range ( - bound + ticks , bound , ticks )) ax . spines . left . set_position ( 'center' ) ax . spines . right . set_color ( 'none' ) ax . spines . bottom . set_position ( 'center' ) ax . spines . top . set_color ( 'none' ) ax . xaxis . set_ticks_position ( 'bottom' ) ax . yaxis . set_ticks_position ( 'left' ) ax . grid ( linestyle = '--' ) ax . minorticks_on () fig . savefig ( out_file ) Don't worry about the contents of this function, all that's important is that it will print a graph of the provided polynomial to out_file . Complete Current poly_question/functions.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from functools import reduce from itertools import zip_longest , dropwhile # multiplies a polynomial by x^n mul_x = lambda p , n : ([ 0 ] * n ) + p # multiples a polynomial by a constant mul_c = lambda p , c : [ c * i for i in p ] # sums two polynomials together sum_p = lambda a , b : [ i + j for ( i , j ) in zip_longest ( a , b , fillvalue = 0 )] # trims a polynomial of extraneous zeroes trim_p = lambda l : reversed ( list ( dropwhile ( lambda x : x == 0 , reversed ( l )))) # multiply polynomials together mul_p = lambda a , b : reduce ( sum_p ,[ mul_x ( mul_c ( a , c ), d ) for ( d , c ) in enumerate ( b )]) # take a zero and give us the corresponding polynomial factor fact_z = lambda z : [ - z , 1 ] # take a list of zeros and produce the polynomial prod_z = lambda zs : list ( trim_p ( reduce ( mul_p , map ( fact_z , zs )))) import numpy as np import matplotlib.pyplot as plt def make_poly_graph ( polynomial , out_file , bound = 8 , ticks = 2 ): fig = plt . figure () ax = fig . subplots () x = np . linspace ( bound , - bound , 100 ) y = sum ([ c * ( x ** i ) for ( i , c ) in enumerate ( polynomial )]) ax . plot ( x , y ) ax . set_xlim ( - bound , bound ) ax . set_ylim ( - bound , bound ) ax . set_xticks ( range ( - bound + ticks , bound , ticks )) ax . set_yticks ( range ( - bound + ticks , bound , ticks )) ax . spines . left . set_position ( 'center' ) ax . spines . right . set_color ( 'none' ) ax . spines . bottom . set_position ( 'center' ) ax . spines . top . set_color ( 'none' ) ax . xaxis . set_ticks_position ( 'bottom' ) ax . yaxis . set_ticks_position ( 'left' ) ax . grid ( linestyle = '--' ) ax . minorticks_on () fig . savefig ( out_file ) Finally we can change poly_question\\graph_question.py to the following in order to generate and display the graph: Complete Current poly_question\\graph_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from exam_gen import * from .functions import * class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body [ 'exam' ] . text = r ''' Sketch the polynomial on this graph: \\includegraphics[width=\\textwidth] {empty_grid.png} \\\\ ~ \\\\ ''' body [ 'solution' ] . text = r ''' Sketch the polynomial on this graph: \\includegraphics[width=\\textwidth] {solution.png} \\\\ ~ \\\\ ''' lw settings . assets = [ \"empty_grid.png\" ] def user_setup ( self , ctxt , rng , ** kwargs ): # Recalculates the polynomial from the zeros in `ctxt` and plots it make_poly_graph ( prod_z ( ctxt [ 'zeros' ]), \"solution.png\" ) user_setup is always run in the build directory associated with the particular student and document. The current directory in user_setup is the same directory where the final .tex files will end up and things you place there will be available to pdflatex and whatever other tools you need. Lastly we can run our build commands and see what is produced: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios TODO: Image in assets/ Fixing the Scaling \u00b6 This doesn't matter much since future steps will be using new problems anyway but right now the graphs given to the students can swerve in and out of the available drawing space. The following edits fix this: Complete Current poly_question/graph_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from functools import reduce from itertools import zip_longest , dropwhile # multiplies a polynomial by x^n mul_x = lambda p , n : ([ 0 ] * n ) + p # multiples a polynomial by a constant mul_c = lambda p , c : [ c * i for i in p ] # sums two polynomials together sum_p = lambda a , b : [ i + j for ( i , j ) in zip_longest ( a , b , fillvalue = 0 )] # trims a polynomial of extraneous zeroes trim_p = lambda l : reversed ( list ( dropwhile ( lambda x : x == 0 , reversed ( l )))) # multiply polynomials together mul_p = lambda a , b : reduce ( sum_p ,[ mul_x ( mul_c ( a , c ), d ) for ( d , c ) in enumerate ( b )]) # take a zero and give us the corresponding polynomial factor fact_z = lambda z : [ - z , 1 ] # take a list of zeros and produce the polynomial prod_z = lambda zs : list ( trim_p ( reduce ( mul_p , map ( fact_z , zs )))) # find the derivative of a polynomial deriv_p = lambda p : list ( map ( lambda e : e [ 0 ] * e [ 1 ], enumerate ( p )))[ 1 :] # evaluate a polynomial at a point eval_p = lambda p , x : sum ( map ( lambda e : e [ 1 ] * ( x ** e [ 0 ]), enumerate ( p ))) import numpy as np import matplotlib.pyplot as plt def make_poly_graph ( out_file , * polys , bound = 8 , ticks = 2 ): fig = plt . figure () ax = fig . subplots () x = np . linspace ( bound , - bound , 100 ) for poly in polys : y = eval_p ( poly , x ) ax . plot ( x , y ) ax . set_xlim ( - bound , bound ) ax . set_ylim ( - bound , bound ) ax . set_xticks ( range ( - bound + ticks , bound , ticks )) ax . set_yticks ( range ( - bound + ticks , bound , ticks )) ax . spines . left . set_position ( 'center' ) ax . spines . right . set_color ( 'none' ) ax . spines . bottom . set_position ( 'center' ) ax . spines . top . set_color ( 'none' ) ax . xaxis . set_ticks_position ( 'bottom' ) ax . yaxis . set_ticks_position ( 'left' ) ax . grid ( linestyle = '--' ) ax . minorticks_on () fig . savefig ( out_file ) Complete Current poly_question/question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 from exam_gen import * from .functions import * from .graph_question import * from .factor_question import * from fractions import Fraction from math import floor import numpy class PolyQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Question\" body . text = r ''' For the following polynomial: $$ { %- f or term in poly -%} { %- i f not loop.first -%}{{term.sign}}{ %- e ndif -%} { {{term.num}}{ %- i f term.degree != 0 -%}x{ %- e ndif -%} } { %- i f term.degree > 1 -%}^{ {{term.degree}} }{ %- e ndif -%} { %- e ndfor -%} $$ ''' questions = { 'graph' : GraphQuestion , 'factors' : FactorQuestion } def user_setup ( self , ctxt , rng , ** kwargs ): # Make a list of 4 random integers, the zeros of our polynomial zeros = list ( map ( lambda _ : rng . randint ( - 5 , 5 ), range ( 0 , 4 ))) # The polynomial such that each index is the coefficient of the # corresponding term. # (i.e. the polynomial is `poly[0] + poly[1]x + poly[2]x^2 ...` for a # given list `poly`) base_poly = prod_z ( zeros ) # get the highest magnitude term between the zeroes by going through # the different points in the base poly samples = numpy . linspace ( min ( zeros ), max ( zeros ), 100 ) max_val = max ( map ( lambda n : abs ( eval_p ( base_poly , n )), samples )) # Find a scaling factor that both looks nice and isn't a pain to use d_limit = 4 scale = 0 while scale == 0 : scale = Fraction ( 7 / max_val ) . limit_denominator ( d_limit ) if scale * max_val > 7.5 : scale = Fraction ( scale . numerator - 1 , scale . denominator ) d_limit += 2 print ( scale ) # scale the polynomial appropriately poly = mul_c ( base_poly , scale ) # Reorder the terms so the highest degree is first, and split it out # to make the templates easier to write. print_poly = list () for ( degree , coeff ) in reversed ( list ( enumerate ( poly ))): if coeff != 0 : print_poly . append ({ 'degree' : degree , 'coefficient' : coeff , 'sign' : \"-\" if coeff < 0 else \"+\" , 'num' : abs ( coeff ) }) return { 'poly' : print_poly , 'raw_poly' : poly , # using the worse name here because the templates # don't need more clutter 'zeros' : zeros } Complete Current poly_question/graph_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from exam_gen import * from .functions import * class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body [ 'exam' ] . text = r ''' Sketch the polynomial on this graph: \\includegraphics[width=\\textwidth] {empty_grid.png} \\\\ ~ \\\\ ''' body [ 'solution' ] . text = r ''' Sketch the polynomial on this graph: \\includegraphics[width=\\textwidth] {solution.png} \\\\ ~ \\\\ ''' settings . assets = [ \"empty_grid.png\" ] def user_setup ( self , ctxt , rng , ** kwargs ): # Grabs the polynomial from `ctxt` and plots it make_poly_graph ( \"solution.png\" , ctxt [ 'raw_poly' ]) They're not critical if you're following the tutorial since we're going to move onto other questions. However, they should probably be incorporated more directly into the tutorial at some point.","title":"External and Generated Assets"},{"location":"tutorial/external_and_generated_assets.html#external-and-generated-assets","text":"With the project reorganized we can start adding external assets to our assignment, as well as generating new assets on the fly with python libraries we import.","title":"External and Generated Assets"},{"location":"tutorial/external_and_generated_assets.html#adding-an-external-file","text":"GraphQuestion needs an empty graph for the students to use, so let's add one. Copy the image below into poly_question/empty_grid.png : TODO: image in assets/ Change the template for GraphQuestion to read as follows: 7 8 9 10 11 body . text = r ''' Sketch the polynomial on this graph: \\includegraphics[width=\\textwidth] {empty_grid.png} \\\\ ~ \\\\ ''' Add empty_grid.png to the list of assets used by this sub-question: 13 settings . assets = [ \"empty_grid.png\" ] Complete Current poly_question/graph_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from exam_gen import * from .functions import * class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body . text = r ''' Sketch the polynomial on this graph: \\includegraphics[width=\\textwidth] {empty_grid.png} \\\\ ~ \\\\ ''' settings . assets = [ \"empty_grid.png\" ] def user_setup ( self , rng , ** kwargs ): pass We can now build the exam to see the grid: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios TODO: image in assets/ Files specified in settings.assets will be copied into the build directory of the exam. This can include glob patterns, though the library will throw an error if there's not at least one valid file per glob pattern. Result of tree ~build/class-fake-class/student-erios/exam-exam/ ~build/class-fake-class/student-erios/exam-exam/ \u251c\u2500\u2500 empty_grid.png \u251c\u2500\u2500 output.aux \u251c\u2500\u2500 output-intro.tex \u251c\u2500\u2500 output.log \u251c\u2500\u2500 output.out \u251c\u2500\u2500 output.pdf \u251c\u2500\u2500 output-questions[addition-question]-body.tex \u251c\u2500\u2500 output-questions[addition-question]-solution.tex \u251c\u2500\u2500 output-questions[addition-question].tex \u251c\u2500\u2500 output-questions[poly-question]-body.tex \u251c\u2500\u2500 output-questions[poly-question]-questions[factors]-body.tex \u251c\u2500\u2500 output-questions[poly-question]-questions[factors]-solution.tex \u251c\u2500\u2500 output-questions[poly-question]-questions[factors].tex \u251c\u2500\u2500 output-questions[poly-question]-questions[graph]-body.tex \u251c\u2500\u2500 output-questions[poly-question]-questions[graph]-solution.tex \u251c\u2500\u2500 output-questions[poly-question]-questions[graph].tex \u251c\u2500\u2500 output-questions[poly-question]-solution.tex \u251c\u2500\u2500 output-questions[poly-question].tex \u2514\u2500\u2500 output.tex","title":"Adding an External File"},{"location":"tutorial/external_and_generated_assets.html#generating-student-specific-files","text":"It would be nice to have the expected graph appear in the solution key, but in order to do that we have to dynamically generate the image for each student. The Python standard libraries and exam_gen don't have the facilities for generating new graphs. Instead we'll need to use the matplotlib and numpy libraries. Run the following commands to add them to the project: $ pipenv install matplotlib numpy Result of pipenv install matplotlib numpy Note that your exact output may differ slightly. $ pipenv install matplotlib numpy Installing matplotlib... Adding matplotlib to Pipfile's [packages]... \u2714 Installation Succeeded Installing numpy... Adding numpy to Pipfile's [packages]... \u2714 Installation Succeeded Installing dependencies from Pipfile.lock (c46356)... running exam_gen setup.py \ud83d\udc0d \u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589\u2589 0/0 \u2014 00:00:00 To activate this project's virtualenv, run pipenv shell. Alternatively, run a command inside the virtualenv with pipenv run. Now it's possible to import matplotlib and numpy anywhere in our project. Let's do just that in poly_question/functions.py by adding: 19 20 import numpy as np import matplotlib.pyplot as plt We can then use these libraries in a function to generate a new plot of our function. Add the following to poly_question/functions.py : 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def make_poly_graph ( polynomial , out_file , bound = 8 , ticks = 2 ): fig = plt . figure () ax = fig . subplots () x = np . linspace ( bound , - bound , 100 ) y = sum ([ c * ( x ** i ) for ( i , c ) in enumerate ( polynomial )]) ax . plot ( x , y ) ax . set_xlim ( - bound , bound ) ax . set_ylim ( - bound , bound ) ax . set_xticks ( range ( - bound + ticks , bound , ticks )) ax . set_yticks ( range ( - bound + ticks , bound , ticks )) ax . spines . left . set_position ( 'center' ) ax . spines . right . set_color ( 'none' ) ax . spines . bottom . set_position ( 'center' ) ax . spines . top . set_color ( 'none' ) ax . xaxis . set_ticks_position ( 'bottom' ) ax . yaxis . set_ticks_position ( 'left' ) ax . grid ( linestyle = '--' ) ax . minorticks_on () fig . savefig ( out_file ) Don't worry about the contents of this function, all that's important is that it will print a graph of the provided polynomial to out_file . Complete Current poly_question/functions.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 from functools import reduce from itertools import zip_longest , dropwhile # multiplies a polynomial by x^n mul_x = lambda p , n : ([ 0 ] * n ) + p # multiples a polynomial by a constant mul_c = lambda p , c : [ c * i for i in p ] # sums two polynomials together sum_p = lambda a , b : [ i + j for ( i , j ) in zip_longest ( a , b , fillvalue = 0 )] # trims a polynomial of extraneous zeroes trim_p = lambda l : reversed ( list ( dropwhile ( lambda x : x == 0 , reversed ( l )))) # multiply polynomials together mul_p = lambda a , b : reduce ( sum_p ,[ mul_x ( mul_c ( a , c ), d ) for ( d , c ) in enumerate ( b )]) # take a zero and give us the corresponding polynomial factor fact_z = lambda z : [ - z , 1 ] # take a list of zeros and produce the polynomial prod_z = lambda zs : list ( trim_p ( reduce ( mul_p , map ( fact_z , zs )))) import numpy as np import matplotlib.pyplot as plt def make_poly_graph ( polynomial , out_file , bound = 8 , ticks = 2 ): fig = plt . figure () ax = fig . subplots () x = np . linspace ( bound , - bound , 100 ) y = sum ([ c * ( x ** i ) for ( i , c ) in enumerate ( polynomial )]) ax . plot ( x , y ) ax . set_xlim ( - bound , bound ) ax . set_ylim ( - bound , bound ) ax . set_xticks ( range ( - bound + ticks , bound , ticks )) ax . set_yticks ( range ( - bound + ticks , bound , ticks )) ax . spines . left . set_position ( 'center' ) ax . spines . right . set_color ( 'none' ) ax . spines . bottom . set_position ( 'center' ) ax . spines . top . set_color ( 'none' ) ax . xaxis . set_ticks_position ( 'bottom' ) ax . yaxis . set_ticks_position ( 'left' ) ax . grid ( linestyle = '--' ) ax . minorticks_on () fig . savefig ( out_file ) Finally we can change poly_question\\graph_question.py to the following in order to generate and display the graph: Complete Current poly_question\\graph_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from exam_gen import * from .functions import * class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body [ 'exam' ] . text = r ''' Sketch the polynomial on this graph: \\includegraphics[width=\\textwidth] {empty_grid.png} \\\\ ~ \\\\ ''' body [ 'solution' ] . text = r ''' Sketch the polynomial on this graph: \\includegraphics[width=\\textwidth] {solution.png} \\\\ ~ \\\\ ''' lw settings . assets = [ \"empty_grid.png\" ] def user_setup ( self , ctxt , rng , ** kwargs ): # Recalculates the polynomial from the zeros in `ctxt` and plots it make_poly_graph ( prod_z ( ctxt [ 'zeros' ]), \"solution.png\" ) user_setup is always run in the build directory associated with the particular student and document. The current directory in user_setup is the same directory where the final .tex files will end up and things you place there will be available to pdflatex and whatever other tools you need. Lastly we can run our build commands and see what is produced: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios TODO: Image in assets/","title":"Generating Student-Specific Files"},{"location":"tutorial/external_and_generated_assets.html#fixing-the-scaling","text":"This doesn't matter much since future steps will be using new problems anyway but right now the graphs given to the students can swerve in and out of the available drawing space. The following edits fix this: Complete Current poly_question/graph_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 from functools import reduce from itertools import zip_longest , dropwhile # multiplies a polynomial by x^n mul_x = lambda p , n : ([ 0 ] * n ) + p # multiples a polynomial by a constant mul_c = lambda p , c : [ c * i for i in p ] # sums two polynomials together sum_p = lambda a , b : [ i + j for ( i , j ) in zip_longest ( a , b , fillvalue = 0 )] # trims a polynomial of extraneous zeroes trim_p = lambda l : reversed ( list ( dropwhile ( lambda x : x == 0 , reversed ( l )))) # multiply polynomials together mul_p = lambda a , b : reduce ( sum_p ,[ mul_x ( mul_c ( a , c ), d ) for ( d , c ) in enumerate ( b )]) # take a zero and give us the corresponding polynomial factor fact_z = lambda z : [ - z , 1 ] # take a list of zeros and produce the polynomial prod_z = lambda zs : list ( trim_p ( reduce ( mul_p , map ( fact_z , zs )))) # find the derivative of a polynomial deriv_p = lambda p : list ( map ( lambda e : e [ 0 ] * e [ 1 ], enumerate ( p )))[ 1 :] # evaluate a polynomial at a point eval_p = lambda p , x : sum ( map ( lambda e : e [ 1 ] * ( x ** e [ 0 ]), enumerate ( p ))) import numpy as np import matplotlib.pyplot as plt def make_poly_graph ( out_file , * polys , bound = 8 , ticks = 2 ): fig = plt . figure () ax = fig . subplots () x = np . linspace ( bound , - bound , 100 ) for poly in polys : y = eval_p ( poly , x ) ax . plot ( x , y ) ax . set_xlim ( - bound , bound ) ax . set_ylim ( - bound , bound ) ax . set_xticks ( range ( - bound + ticks , bound , ticks )) ax . set_yticks ( range ( - bound + ticks , bound , ticks )) ax . spines . left . set_position ( 'center' ) ax . spines . right . set_color ( 'none' ) ax . spines . bottom . set_position ( 'center' ) ax . spines . top . set_color ( 'none' ) ax . xaxis . set_ticks_position ( 'bottom' ) ax . yaxis . set_ticks_position ( 'left' ) ax . grid ( linestyle = '--' ) ax . minorticks_on () fig . savefig ( out_file ) Complete Current poly_question/question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 from exam_gen import * from .functions import * from .graph_question import * from .factor_question import * from fractions import Fraction from math import floor import numpy class PolyQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Question\" body . text = r ''' For the following polynomial: $$ { %- f or term in poly -%} { %- i f not loop.first -%}{{term.sign}}{ %- e ndif -%} { {{term.num}}{ %- i f term.degree != 0 -%}x{ %- e ndif -%} } { %- i f term.degree > 1 -%}^{ {{term.degree}} }{ %- e ndif -%} { %- e ndfor -%} $$ ''' questions = { 'graph' : GraphQuestion , 'factors' : FactorQuestion } def user_setup ( self , ctxt , rng , ** kwargs ): # Make a list of 4 random integers, the zeros of our polynomial zeros = list ( map ( lambda _ : rng . randint ( - 5 , 5 ), range ( 0 , 4 ))) # The polynomial such that each index is the coefficient of the # corresponding term. # (i.e. the polynomial is `poly[0] + poly[1]x + poly[2]x^2 ...` for a # given list `poly`) base_poly = prod_z ( zeros ) # get the highest magnitude term between the zeroes by going through # the different points in the base poly samples = numpy . linspace ( min ( zeros ), max ( zeros ), 100 ) max_val = max ( map ( lambda n : abs ( eval_p ( base_poly , n )), samples )) # Find a scaling factor that both looks nice and isn't a pain to use d_limit = 4 scale = 0 while scale == 0 : scale = Fraction ( 7 / max_val ) . limit_denominator ( d_limit ) if scale * max_val > 7.5 : scale = Fraction ( scale . numerator - 1 , scale . denominator ) d_limit += 2 print ( scale ) # scale the polynomial appropriately poly = mul_c ( base_poly , scale ) # Reorder the terms so the highest degree is first, and split it out # to make the templates easier to write. print_poly = list () for ( degree , coeff ) in reversed ( list ( enumerate ( poly ))): if coeff != 0 : print_poly . append ({ 'degree' : degree , 'coefficient' : coeff , 'sign' : \"-\" if coeff < 0 else \"+\" , 'num' : abs ( coeff ) }) return { 'poly' : print_poly , 'raw_poly' : poly , # using the worse name here because the templates # don't need more clutter 'zeros' : zeros } Complete Current poly_question/graph_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from exam_gen import * from .functions import * class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body [ 'exam' ] . text = r ''' Sketch the polynomial on this graph: \\includegraphics[width=\\textwidth] {empty_grid.png} \\\\ ~ \\\\ ''' body [ 'solution' ] . text = r ''' Sketch the polynomial on this graph: \\includegraphics[width=\\textwidth] {solution.png} \\\\ ~ \\\\ ''' settings . assets = [ \"empty_grid.png\" ] def user_setup ( self , ctxt , rng , ** kwargs ): # Grabs the polynomial from `ctxt` and plots it make_poly_graph ( \"solution.png\" , ctxt [ 'raw_poly' ]) They're not critical if you're following the tutorial since we're going to move onto other questions. However, they should probably be incorporated more directly into the tutorial at some point.","title":"Fixing the Scaling"},{"location":"tutorial/first_assignment.html","text":"Your First Assignment \u00b6 We'll be walking through the creation of a simple randomized assignment with some multiple-choice questions, as well as importing student answers and assigning grades. Setting up Your Development Environment \u00b6 There are two main requirements to run exam_gen : LaTeX and pipenv . Set each up on your machine as appropriate. TeX Live : Is needed to actually build the exams. Installing the full version (usually texlive-full ) is recommended. Ubuntu: sudo apt install texlive-full Other Linux: Check your distro's package manager or see here . Mac: MacTeX or install via homebrew. Windows: Follow the instructions here Pipenv : Hides a lot of python packing and dependency issues by creating a nice stable wrapper environment for our work. Installation instructions are here . With both of those ready to go, we can move on to making an assignment. Windows Users From here on out we'll be tailoring our instructions to unix-like systems. Windows users might need to edit the commands provided to make things work, but the library itself should be OS independent. Setting up the Project \u00b6 We'll create a new project directory called new_exam and move into it with: $ mkdir new_exam $ cd new_exam This would also be a good time to set up version control (with git init or similar). Then we can add the exam_gen library to our project using pipenv: $ pipenv install <repo_url> Right now <repo_url> would be https://github.com/rohit507/exam_gen.git but the project should probably be somewhere different soon. Once it's moved, that link should be directly embedded above. Finally we need to create exam.py , which is the most important file in any new project. We'll start by just creating a new file and making it executable. $ touch exam.py $ chmod +x exam.py exam.py will contain a full description of our assignment. We'll describe how to create it in the next section. Creating an Initial exam.py \u00b6 Open the editor of your choice and paste the following into exam.py : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/usr/bin/env -S pipenv run python3 from exam_gen import * class NewExam ( LatexDoc , Exam ): classes = {} questions = {} intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) Once you save, this constitutes a minimal description of an assignment. One with no content and a tiny snippet of text as an introduction. Line-by-Line Breakdown of exam.py 3 from exam_gen import * Importing our library. Simple enough, we can't get anything else done without this. 5 class NewExam ( LatexDoc , Exam ): Then we initialize our new assignment as a python class. This library uses classes to represents assignments (i.e. Exam ) and questions within those assignments. Individual versions of those assignments (which are student specific) will be objects initialized from these classes. It's also worth noting what classes NewExam inherits from. LatexDoc tells our backend that we're working in LaTeX and describes how to build new .pdf files from the text that's generated. Exam , on the other hand, describes various elements of the structure of an assignment which we'll go over later. 7 classes = {} The Exam class pulls double duty in this system. It acts as the definition of a single exam's contents, but it also captures some grading and student-roster management info. Most of that roster-management is delegated to Classrooms , which we'll look at in more detail soon, but we need to store the set of classrooms we are going to use somewhere. For now we leave this list empty. 9 questions = {} Each exam has to have some list of questions. It's empty for now, but we'll be adding to it later. 11 12 13 intro . text = r ''' \\emph{Example Exam Introduction} ''' The biggest content element of an Exam is the introduction, which tends to have the rules, instructions, honor-code, etc.. This is how we specify what text should appear in that intro. Note how we're using the r''' ... ''' string notation. This allows for multi-line strings where '\\' and other special characters don't need to be escaped. Given how TeX has a truly painful number of stupid syntax quirks this is very useful. 15 16 def user_setup ( self , ** kwargs ): pass This function can be filled in later to provide customization to each version of the exam. For now we leave it empty. 18 if __name__ == \"__main__\" : run_cli ( globals ()) This is an archaic python incantation. In short, one should read if __name__ == \"__main__\" : as \"Do this if we're running this file as a script\". Likewise globals () is a function that returns all the variables in scope where it was called, including classes like NewExam . run_cli () then searches through that list for a subclass of Exam to build assignments with. 1 #!/usr/bin/env -S pipenv run python3 This is a unix hashbang, when an executable text file is run and starts with #!some_command then the file's contents will be passed to some_command as an argument. Since we use pipenv for build isolation this will automatically wrap any invocation of ./exam.py with the appropriate environment. All together, this just lets us call exam_gen 's command line interface when we run the file as a script. Along with the chmod +x exam.py from earlier, this lets us run ./exam.py <arguments> instead of having to manually call pipenv and python. We can quickly test our setup by running the following in our terminal: $ ./exam.py You should see a result like this: exam_gen build tool Available Commands: <cmd_name> list List major available build actions. <cmd_name> list --all List all available build actions. Replace <cmd_name> with however you invoke this tool. (usually `./exam.py`,`pipenv run ./exam.py`,or `pipenv run python3 exam.py`) We can also take a look at the various possible build commands available to us by following the above instructions: $ ./exam.py list --all Which should produce a result like: build-exam Build all the exams for each student. build-solution Build all the answer keys for each student. cleanup Clean all generated files. (e.g. 'rm -rf ~*') parse-roster parse the class rosters (incl. answer and score data if available) None of those command do anything right now as they all depend on having a roster of students available to parse and build exams for. So let's add that. The next section adds a roster of students that we'll be building exams for.","title":"Your First Assignment"},{"location":"tutorial/first_assignment.html#your-first-assignment","text":"We'll be walking through the creation of a simple randomized assignment with some multiple-choice questions, as well as importing student answers and assigning grades.","title":"Your First Assignment"},{"location":"tutorial/first_assignment.html#setting-up-your-development-environment","text":"There are two main requirements to run exam_gen : LaTeX and pipenv . Set each up on your machine as appropriate. TeX Live : Is needed to actually build the exams. Installing the full version (usually texlive-full ) is recommended. Ubuntu: sudo apt install texlive-full Other Linux: Check your distro's package manager or see here . Mac: MacTeX or install via homebrew. Windows: Follow the instructions here Pipenv : Hides a lot of python packing and dependency issues by creating a nice stable wrapper environment for our work. Installation instructions are here . With both of those ready to go, we can move on to making an assignment. Windows Users From here on out we'll be tailoring our instructions to unix-like systems. Windows users might need to edit the commands provided to make things work, but the library itself should be OS independent.","title":"Setting up Your Development Environment"},{"location":"tutorial/first_assignment.html#setting-up-the-project","text":"We'll create a new project directory called new_exam and move into it with: $ mkdir new_exam $ cd new_exam This would also be a good time to set up version control (with git init or similar). Then we can add the exam_gen library to our project using pipenv: $ pipenv install <repo_url> Right now <repo_url> would be https://github.com/rohit507/exam_gen.git but the project should probably be somewhere different soon. Once it's moved, that link should be directly embedded above. Finally we need to create exam.py , which is the most important file in any new project. We'll start by just creating a new file and making it executable. $ touch exam.py $ chmod +x exam.py exam.py will contain a full description of our assignment. We'll describe how to create it in the next section.","title":"Setting up the Project"},{"location":"tutorial/first_assignment.html#creating-an-initial-exampy","text":"Open the editor of your choice and paste the following into exam.py : 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/usr/bin/env -S pipenv run python3 from exam_gen import * class NewExam ( LatexDoc , Exam ): classes = {} questions = {} intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) Once you save, this constitutes a minimal description of an assignment. One with no content and a tiny snippet of text as an introduction. Line-by-Line Breakdown of exam.py 3 from exam_gen import * Importing our library. Simple enough, we can't get anything else done without this. 5 class NewExam ( LatexDoc , Exam ): Then we initialize our new assignment as a python class. This library uses classes to represents assignments (i.e. Exam ) and questions within those assignments. Individual versions of those assignments (which are student specific) will be objects initialized from these classes. It's also worth noting what classes NewExam inherits from. LatexDoc tells our backend that we're working in LaTeX and describes how to build new .pdf files from the text that's generated. Exam , on the other hand, describes various elements of the structure of an assignment which we'll go over later. 7 classes = {} The Exam class pulls double duty in this system. It acts as the definition of a single exam's contents, but it also captures some grading and student-roster management info. Most of that roster-management is delegated to Classrooms , which we'll look at in more detail soon, but we need to store the set of classrooms we are going to use somewhere. For now we leave this list empty. 9 questions = {} Each exam has to have some list of questions. It's empty for now, but we'll be adding to it later. 11 12 13 intro . text = r ''' \\emph{Example Exam Introduction} ''' The biggest content element of an Exam is the introduction, which tends to have the rules, instructions, honor-code, etc.. This is how we specify what text should appear in that intro. Note how we're using the r''' ... ''' string notation. This allows for multi-line strings where '\\' and other special characters don't need to be escaped. Given how TeX has a truly painful number of stupid syntax quirks this is very useful. 15 16 def user_setup ( self , ** kwargs ): pass This function can be filled in later to provide customization to each version of the exam. For now we leave it empty. 18 if __name__ == \"__main__\" : run_cli ( globals ()) This is an archaic python incantation. In short, one should read if __name__ == \"__main__\" : as \"Do this if we're running this file as a script\". Likewise globals () is a function that returns all the variables in scope where it was called, including classes like NewExam . run_cli () then searches through that list for a subclass of Exam to build assignments with. 1 #!/usr/bin/env -S pipenv run python3 This is a unix hashbang, when an executable text file is run and starts with #!some_command then the file's contents will be passed to some_command as an argument. Since we use pipenv for build isolation this will automatically wrap any invocation of ./exam.py with the appropriate environment. All together, this just lets us call exam_gen 's command line interface when we run the file as a script. Along with the chmod +x exam.py from earlier, this lets us run ./exam.py <arguments> instead of having to manually call pipenv and python. We can quickly test our setup by running the following in our terminal: $ ./exam.py You should see a result like this: exam_gen build tool Available Commands: <cmd_name> list List major available build actions. <cmd_name> list --all List all available build actions. Replace <cmd_name> with however you invoke this tool. (usually `./exam.py`,`pipenv run ./exam.py`,or `pipenv run python3 exam.py`) We can also take a look at the various possible build commands available to us by following the above instructions: $ ./exam.py list --all Which should produce a result like: build-exam Build all the exams for each student. build-solution Build all the answer keys for each student. cleanup Clean all generated files. (e.g. 'rm -rf ~*') parse-roster parse the class rosters (incl. answer and score data if available) None of those command do anything right now as they all depend on having a roster of students available to parse and build exams for. So let's add that. The next section adds a roster of students that we'll be building exams for.","title":"Creating an Initial exam.py"},{"location":"tutorial/multi_part_questions.html","text":"Multi-Part Questions \u00b6 Now we'll take a look at multi-part questions as well as some advanced features of the exam_gen library. Initial Setup \u00b6 Let's first set up a new question for this section of the tutorial. Create a new file polynomial_question.py with the following contents: 1 2 3 4 5 6 7 8 9 10 11 from exam_gen import * class PolyQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Question\" body . text = r ''' For this polynomial: Placeholder Text ''' def user_setup ( self , rng , ** kwargs ): pass And edit the questions variable in exam.py so that it reads as follows: 17 18 19 20 questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion } Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/env -S pipenv run python3 from exam_gen import * from addition_question import * from polynomial_question import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), } questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion } intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) From there we can build the exam and see the new question: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios Todo: image in assets/ Adding Sub-Questions \u00b6 Now we can add some placeholders for the subquestions as well. Edit polynomial_question.py by adding the following before the declaration of PolyQuestion : 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body . text = r ''' Sketch the polynomial on this graph: Placeholder ''' def user_setup ( self , rng , ** kwargs ): pass class FactorQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Factors\" body . text = r ''' What are its factors? ''' def user_setup ( self , rng , ** kwargs ): pass This has to come before the line with class PolyQuestion ( .. ): due to how python loads classes. Both GraphQuestion and FactorQuestion need to already exist before we define PolyQuestion . As well as adding a questions variables (just like in exam.py ) to PolyQuestion as follows: 31 32 33 34 questions = { 'graph' : GraphQuestion , 'factors' : FactorQuestion } Complete Current polynomial_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from exam_gen import * class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body . text = r ''' Sketch the polynomial on this graph: Placeholder ''' def user_setup ( self , rng , ** kwargs ): pass class FactorQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Factors\" body . text = r ''' What are its factors? ''' def user_setup ( self , rng , ** kwargs ): pass class PolyQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Question\" body . text = r ''' For the following polynomial: Placeholder Text ''' questions = { 'graph' : GraphQuestion , 'factors' : FactorQuestion } def user_setup ( self , rng , ** kwargs ): pass From there we can build the exam and see the new question: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios Todo: image in assets/ Generating Problem Data in the Parent \u00b6 For this question to work, both the subquestions need to refer to the same polynomial. We can't generate a new one for each section. This is where the other use of user_setup comes in. In addition to providing variables to templates those variables are made available to child problems as well. To start, we're just going to add some imports and a few functions that let us manipulate polynomials. The exact contents aren't particularly important for this tutorial, so don't worry too much about them. For now add the following to the start of polynomial_question.py : Support Code 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from functools import reduce from itertools import zip_longest , dropwhile # multiplies a polynomial by x^n mul_x = lambda p , n : ([ 0 ] * n ) + p # multiples a polynomial by a constant mul_c = lambda p , c : [ c * i for i in p ] # sums two polynomials together sum_p = lambda a , b : [ i + j for ( i , j ) in zip_longest ( a , b , fillvalue = 0 )] # trims a polynomial of extraneous zeroes trim_p = lambda l : reversed ( list ( dropwhile ( lambda x : x == 0 , reversed ( l )))) # multiply polynomials together mul_p = lambda a , b : reduce ( sum_p ,[ mul_x ( mul_c ( a , c ), d ) for ( d , c ) in enumerate ( b )]) # take a zero and give us the corresponding polynomial factor fact_z = lambda z : [ - z , 1 ] # take a list of zeros and produce the polynomial prod_z = lambda zs : list ( trim_p ( reduce ( mul_p , map ( fact_z , zs )))) Using those helpers we can then write the start of our user_setup for the problem as a whole. So add the following to polynomial_question.py : 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def user_setup ( self , rng , ** kwargs ): # Make a list of 4 random integers, the zeros of our polynomial zeros = list ( map ( lambda _ : rng . randint ( - 5 , 5 ), range ( 0 , 4 ))) # The polynomial such that each index is the coefficient of the # corresponding term. # (i.e. the polynomial is `poly[0] + poly[1]x + poly[2]x^2 ...` for a # given list `poly`) poly = prod_z ( zeros ) # Reorder the terms so the highest degree is first, and split it out # to make the templates easier to write. print_poly = list () for ( degree , coeff ) in reversed ( list ( enumerate ( poly ))): if coeff != 0 : print_poly . append ({ 'degree' : degree , 'coefficient' : coeff , 'sign' : \"-\" if coeff < 0 else \"+\" , 'num' : abs ( coeff ) }) return { 'poly' : print_poly , 'zeros' : zeros } The latter half of that code just unpacks the terms of the polynomial so that the template can access them under the poly variable. Also important is the highlighted line, where we add the list of zeroes to the context. Our child questions will be able to access the full context we return here (just as the template can) so anything they need to know should be stuffed in there as well. Finally, we can make use of those reformatted polynomial variables in our template by changing body.text : 44 45 46 47 48 49 50 51 52 53 54 body . text = r ''' For the following polynomial: $$ { %- f or term in poly -%} { %- i f not loop.first -%}{{term.sign}}{ %- e ndif -%} { {{term.num}}{ %- i f term.degree != 0 -%}x{ %- e ndif -%} } { %- i f term.degree > 1 -%}^{ {{term.degree}} }{ %- e ndif -%} { %- e ndfor -%} $$ ''' Complete Current polynomial_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 from exam_gen import * from functools import reduce from itertools import zip_longest , dropwhile # multiplies a polynomial by x^n mul_x = lambda p , n : ([ 0 ] * n ) + p # multiples a polynomial by a constant mul_c = lambda p , c : [ c * i for i in p ] # sums two polynomials together sum_p = lambda a , b : [ i + j for ( i , j ) in zip_longest ( a , b , fillvalue = 0 )] # trims a polynomial of extraneous zeroes trim_p = lambda l : reversed ( list ( dropwhile ( lambda x : x == 0 , reversed ( l )))) # multiply polynomials together mul_p = lambda a , b : reduce ( sum_p ,[ mul_x ( mul_c ( a , c ), d ) for ( d , c ) in enumerate ( b )]) # take a zero and give us the corresponding polynomial factor fact_z = lambda z : [ - z , 1 ] # take a list of zeros and produce the polynomial prod_z = lambda zs : list ( trim_p ( reduce ( mul_p , map ( fact_z , zs )))) class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body . text = r ''' Sketch the polynomial on this graph: Placeholder ''' def user_setup ( self , rng , ** kwargs ): pass class FactorQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Factors\" body . text = r ''' What are its factors? ''' def user_setup ( self , rng , ** kwargs ): pass class PolyQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Question\" body . text = r ''' For the following polynomial: $$ { %- f or term in poly -%} { %- i f not loop.first -%}{{term.sign}}{ %- e ndif -%} { {{term.num}}{ %- i f term.degree != 0 -%}x{ %- e ndif -%} } { %- i f term.degree > 1 -%}^{ {{term.degree}} }{ %- e ndif -%} { %- e ndfor -%} $$ ''' questions = { 'graph' : GraphQuestion , 'factors' : FactorQuestion } def user_setup ( self , rng , ** kwargs ): # Make a list of 4 random integers, the zeros of our polynomial zeros = list ( map ( lambda _ : rng . randint ( - 5 , 5 ), range ( 0 , 4 ))) # The polynomial such that each index is the coefficient of the # corresponding term. # (i.e. the polynomial is `poly[0] + poly[1]x + poly[2]x^2 ...` for a # given list `poly`) poly = prod_z ( zeros ) # Reorder the terms so the highest degree is first, and split it out # to make the templates easier to write. print_poly = list () for ( degree , coeff ) in reversed ( list ( enumerate ( poly ))): if coeff != 0 : print_poly . append ({ 'degree' : degree , 'coefficient' : coeff , 'sign' : \"-\" if coeff < 0 else \"+\" , 'num' : abs ( coeff ) }) return { 'poly' : print_poly , 'zeros' : zeros } Build the current version of exam with: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios TODO: immage in assets/ Using Problem Data in the Children \u00b6 This gives us the setup of the problem but the sub-problems, especially FactorQuestion , need to know information generated in the parent in order to render. In this case, there's a ctxt parameter made available to user_setup that contains all the data returned by the user_setup of the parent. We will need to print a nicer form of the factored polynomial based on the zeroes of that polynomial. Edit the user_setup of FactorQuestion as follows: 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def user_setup ( self , ctxt , rng , ** kwargs ): # Format the factors so that they're also easier to print print_factors = dict () # the `zeros` value returned by the parent question is found here # in the `ctxt` parameter under `ctxt['zeroes']` for z in ctxt [ 'zeros' ]: if z not in print_factors : print_factors [ z ] = { 'zero' : z , 'degree' : 1 , 'has_term' : z != 0 , # do we even print a constant term? 'sign' : \"+\" if z < 0 else \"-\" , 'num' : abs ( z ) } else : print_factors [ z ][ 'degree' ] += 1 return { \"factors\" : print_factors } Now how in the declaration for user_setup we have an additional parameter ctxt . That we can use to get values from the parent question. We also need to change the solution template to use the newly generated values by editing polynomial_question.py : 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 solution . text = r ''' The factors are: $${ %- f or factor in factors.values() -%} { { %- i f factor.has_term -%} \\left( x {{ factor.sign }} {{ factor.num }} \\right) { %- e lse -%} x { %- e ndif -%} } { %- i f factor.degree != 1 -%} ^{ {{factor.degree}} } { %- e ndif -%} { %- e ndfor -%} $$ ''' Complete Current polynomial_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 from exam_gen import * from functools import reduce from itertools import zip_longest , dropwhile # multiplies a polynomial by x^n mul_x = lambda p , n : ([ 0 ] * n ) + p # multiples a polynomial by a constant mul_c = lambda p , c : [ c * i for i in p ] # sums two polynomials together sum_p = lambda a , b : [ i + j for ( i , j ) in zip_longest ( a , b , fillvalue = 0 )] # trims a polynomial of extraneous zeroes trim_p = lambda l : reversed ( list ( dropwhile ( lambda x : x == 0 , reversed ( l )))) # multiply polynomials together mul_p = lambda a , b : reduce ( sum_p ,[ mul_x ( mul_c ( a , c ), d ) for ( d , c ) in enumerate ( b )]) # take a zero and give us the corresponding polynomial factor fact_z = lambda z : [ - z , 1 ] # take a list of zeros and produce the polynomial prod_z = lambda zs : list ( trim_p ( reduce ( mul_p , map ( fact_z , zs )))) class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body . text = r ''' Sketch the polynomial on this graph: Placeholder ''' def user_setup ( self , rng , ** kwargs ): pass class FactorQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Factors\" body . text = r ''' What are its factors? ''' solution . text = r ''' The factors are: $${ %- f or factor in factors.values() -%} { { %- i f factor.has_term -%} \\left( x {{ factor.sign }} {{ factor.num }} \\right) { %- e lse -%} x { %- e ndif -%} } { %- i f factor.degree != 1 -%} ^{ {{factor.degree}} } { %- e ndif -%} { %- e ndfor -%} $$ ''' def user_setup ( self , ctxt , rng , ** kwargs ): # Format the factors so that they're also easier to print print_factors = dict () # the `zeros` value returned by the parent question is found here # in the `ctxt` parameter under `ctxt['zeroes']` for z in ctxt [ 'zeros' ]: if z not in print_factors : print_factors [ z ] = { 'zero' : z , 'degree' : 1 , 'has_term' : z != 0 , # do we even print a constant term? 'sign' : \"+\" if z < 0 else \"-\" , 'num' : abs ( z ) } else : print_factors [ z ][ 'degree' ] += 1 return { \"factors\" : print_factors } class PolyQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Question\" body . text = r ''' For the following polynomial: $$ { %- f or term in poly -%} { %- i f not loop.first -%}{{term.sign}}{ %- e ndif -%} { {{term.num}}{ %- i f term.degree != 0 -%}x{ %- e ndif -%} } { %- i f term.degree > 1 -%}^{ {{term.degree}} }{ %- e ndif -%} { %- e ndfor -%} $$ ''' questions = { 'graph' : GraphQuestion , 'factors' : FactorQuestion } def user_setup ( self , rng , ** kwargs ): # Make a list of 4 random integers, the zeros of our polynomial zeros = list ( map ( lambda _ : rng . randint ( - 5 , 5 ), range ( 0 , 4 ))) # The polynomial such that each index is the coefficient of the # corresponding term. # (i.e. the polynomial is `poly[0] + poly[1]x + poly[2]x^2 ...` for a # given list `poly`) poly = prod_z ( zeros ) # Reorder the terms so the highest degree is first, and split it out # to make the templates easier to write. print_poly = list () for ( degree , coeff ) in reversed ( list ( enumerate ( poly ))): if coeff != 0 : print_poly . append ({ 'degree' : degree , 'coefficient' : coeff , 'sign' : \"-\" if coeff < 0 else \"+\" , 'num' : abs ( coeff ) }) return { 'poly' : print_poly , 'zeros' : zeros } We can then generate the new solution key with the following commands: $ ./exam.py cleanup $ ./exam.py build-solution:fake-class:erios !!! error \"TODO: image in assets/ \" In the next section we'll see how problems can use images and graphs, as well as external files and libraries in general.","title":"Multi-Part Questions"},{"location":"tutorial/multi_part_questions.html#multi-part-questions","text":"Now we'll take a look at multi-part questions as well as some advanced features of the exam_gen library.","title":"Multi-Part Questions"},{"location":"tutorial/multi_part_questions.html#initial-setup","text":"Let's first set up a new question for this section of the tutorial. Create a new file polynomial_question.py with the following contents: 1 2 3 4 5 6 7 8 9 10 11 from exam_gen import * class PolyQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Question\" body . text = r ''' For this polynomial: Placeholder Text ''' def user_setup ( self , rng , ** kwargs ): pass And edit the questions variable in exam.py so that it reads as follows: 17 18 19 20 questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion } Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/env -S pipenv run python3 from exam_gen import * from addition_question import * from polynomial_question import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), } questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion } intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) From there we can build the exam and see the new question: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios Todo: image in assets/","title":"Initial Setup"},{"location":"tutorial/multi_part_questions.html#adding-sub-questions","text":"Now we can add some placeholders for the subquestions as well. Edit polynomial_question.py by adding the following before the declaration of PolyQuestion : 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body . text = r ''' Sketch the polynomial on this graph: Placeholder ''' def user_setup ( self , rng , ** kwargs ): pass class FactorQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Factors\" body . text = r ''' What are its factors? ''' def user_setup ( self , rng , ** kwargs ): pass This has to come before the line with class PolyQuestion ( .. ): due to how python loads classes. Both GraphQuestion and FactorQuestion need to already exist before we define PolyQuestion . As well as adding a questions variables (just like in exam.py ) to PolyQuestion as follows: 31 32 33 34 questions = { 'graph' : GraphQuestion , 'factors' : FactorQuestion } Complete Current polynomial_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 from exam_gen import * class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body . text = r ''' Sketch the polynomial on this graph: Placeholder ''' def user_setup ( self , rng , ** kwargs ): pass class FactorQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Factors\" body . text = r ''' What are its factors? ''' def user_setup ( self , rng , ** kwargs ): pass class PolyQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Question\" body . text = r ''' For the following polynomial: Placeholder Text ''' questions = { 'graph' : GraphQuestion , 'factors' : FactorQuestion } def user_setup ( self , rng , ** kwargs ): pass From there we can build the exam and see the new question: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios Todo: image in assets/","title":"Adding Sub-Questions"},{"location":"tutorial/multi_part_questions.html#generating-problem-data-in-the-parent","text":"For this question to work, both the subquestions need to refer to the same polynomial. We can't generate a new one for each section. This is where the other use of user_setup comes in. In addition to providing variables to templates those variables are made available to child problems as well. To start, we're just going to add some imports and a few functions that let us manipulate polynomials. The exact contents aren't particularly important for this tutorial, so don't worry too much about them. For now add the following to the start of polynomial_question.py : Support Code 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from functools import reduce from itertools import zip_longest , dropwhile # multiplies a polynomial by x^n mul_x = lambda p , n : ([ 0 ] * n ) + p # multiples a polynomial by a constant mul_c = lambda p , c : [ c * i for i in p ] # sums two polynomials together sum_p = lambda a , b : [ i + j for ( i , j ) in zip_longest ( a , b , fillvalue = 0 )] # trims a polynomial of extraneous zeroes trim_p = lambda l : reversed ( list ( dropwhile ( lambda x : x == 0 , reversed ( l )))) # multiply polynomials together mul_p = lambda a , b : reduce ( sum_p ,[ mul_x ( mul_c ( a , c ), d ) for ( d , c ) in enumerate ( b )]) # take a zero and give us the corresponding polynomial factor fact_z = lambda z : [ - z , 1 ] # take a list of zeros and produce the polynomial prod_z = lambda zs : list ( trim_p ( reduce ( mul_p , map ( fact_z , zs )))) Using those helpers we can then write the start of our user_setup for the problem as a whole. So add the following to polynomial_question.py : 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def user_setup ( self , rng , ** kwargs ): # Make a list of 4 random integers, the zeros of our polynomial zeros = list ( map ( lambda _ : rng . randint ( - 5 , 5 ), range ( 0 , 4 ))) # The polynomial such that each index is the coefficient of the # corresponding term. # (i.e. the polynomial is `poly[0] + poly[1]x + poly[2]x^2 ...` for a # given list `poly`) poly = prod_z ( zeros ) # Reorder the terms so the highest degree is first, and split it out # to make the templates easier to write. print_poly = list () for ( degree , coeff ) in reversed ( list ( enumerate ( poly ))): if coeff != 0 : print_poly . append ({ 'degree' : degree , 'coefficient' : coeff , 'sign' : \"-\" if coeff < 0 else \"+\" , 'num' : abs ( coeff ) }) return { 'poly' : print_poly , 'zeros' : zeros } The latter half of that code just unpacks the terms of the polynomial so that the template can access them under the poly variable. Also important is the highlighted line, where we add the list of zeroes to the context. Our child questions will be able to access the full context we return here (just as the template can) so anything they need to know should be stuffed in there as well. Finally, we can make use of those reformatted polynomial variables in our template by changing body.text : 44 45 46 47 48 49 50 51 52 53 54 body . text = r ''' For the following polynomial: $$ { %- f or term in poly -%} { %- i f not loop.first -%}{{term.sign}}{ %- e ndif -%} { {{term.num}}{ %- i f term.degree != 0 -%}x{ %- e ndif -%} } { %- i f term.degree > 1 -%}^{ {{term.degree}} }{ %- e ndif -%} { %- e ndfor -%} $$ ''' Complete Current polynomial_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 from exam_gen import * from functools import reduce from itertools import zip_longest , dropwhile # multiplies a polynomial by x^n mul_x = lambda p , n : ([ 0 ] * n ) + p # multiples a polynomial by a constant mul_c = lambda p , c : [ c * i for i in p ] # sums two polynomials together sum_p = lambda a , b : [ i + j for ( i , j ) in zip_longest ( a , b , fillvalue = 0 )] # trims a polynomial of extraneous zeroes trim_p = lambda l : reversed ( list ( dropwhile ( lambda x : x == 0 , reversed ( l )))) # multiply polynomials together mul_p = lambda a , b : reduce ( sum_p ,[ mul_x ( mul_c ( a , c ), d ) for ( d , c ) in enumerate ( b )]) # take a zero and give us the corresponding polynomial factor fact_z = lambda z : [ - z , 1 ] # take a list of zeros and produce the polynomial prod_z = lambda zs : list ( trim_p ( reduce ( mul_p , map ( fact_z , zs )))) class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body . text = r ''' Sketch the polynomial on this graph: Placeholder ''' def user_setup ( self , rng , ** kwargs ): pass class FactorQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Factors\" body . text = r ''' What are its factors? ''' def user_setup ( self , rng , ** kwargs ): pass class PolyQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Question\" body . text = r ''' For the following polynomial: $$ { %- f or term in poly -%} { %- i f not loop.first -%}{{term.sign}}{ %- e ndif -%} { {{term.num}}{ %- i f term.degree != 0 -%}x{ %- e ndif -%} } { %- i f term.degree > 1 -%}^{ {{term.degree}} }{ %- e ndif -%} { %- e ndfor -%} $$ ''' questions = { 'graph' : GraphQuestion , 'factors' : FactorQuestion } def user_setup ( self , rng , ** kwargs ): # Make a list of 4 random integers, the zeros of our polynomial zeros = list ( map ( lambda _ : rng . randint ( - 5 , 5 ), range ( 0 , 4 ))) # The polynomial such that each index is the coefficient of the # corresponding term. # (i.e. the polynomial is `poly[0] + poly[1]x + poly[2]x^2 ...` for a # given list `poly`) poly = prod_z ( zeros ) # Reorder the terms so the highest degree is first, and split it out # to make the templates easier to write. print_poly = list () for ( degree , coeff ) in reversed ( list ( enumerate ( poly ))): if coeff != 0 : print_poly . append ({ 'degree' : degree , 'coefficient' : coeff , 'sign' : \"-\" if coeff < 0 else \"+\" , 'num' : abs ( coeff ) }) return { 'poly' : print_poly , 'zeros' : zeros } Build the current version of exam with: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios TODO: immage in assets/","title":"Generating Problem Data in the Parent"},{"location":"tutorial/multi_part_questions.html#using-problem-data-in-the-children","text":"This gives us the setup of the problem but the sub-problems, especially FactorQuestion , need to know information generated in the parent in order to render. In this case, there's a ctxt parameter made available to user_setup that contains all the data returned by the user_setup of the parent. We will need to print a nicer form of the factored polynomial based on the zeroes of that polynomial. Edit the user_setup of FactorQuestion as follows: 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def user_setup ( self , ctxt , rng , ** kwargs ): # Format the factors so that they're also easier to print print_factors = dict () # the `zeros` value returned by the parent question is found here # in the `ctxt` parameter under `ctxt['zeroes']` for z in ctxt [ 'zeros' ]: if z not in print_factors : print_factors [ z ] = { 'zero' : z , 'degree' : 1 , 'has_term' : z != 0 , # do we even print a constant term? 'sign' : \"+\" if z < 0 else \"-\" , 'num' : abs ( z ) } else : print_factors [ z ][ 'degree' ] += 1 return { \"factors\" : print_factors } Now how in the declaration for user_setup we have an additional parameter ctxt . That we can use to get values from the parent question. We also need to change the solution template to use the newly generated values by editing polynomial_question.py : 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 solution . text = r ''' The factors are: $${ %- f or factor in factors.values() -%} { { %- i f factor.has_term -%} \\left( x {{ factor.sign }} {{ factor.num }} \\right) { %- e lse -%} x { %- e ndif -%} } { %- i f factor.degree != 1 -%} ^{ {{factor.degree}} } { %- e ndif -%} { %- e ndfor -%} $$ ''' Complete Current polynomial_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 from exam_gen import * from functools import reduce from itertools import zip_longest , dropwhile # multiplies a polynomial by x^n mul_x = lambda p , n : ([ 0 ] * n ) + p # multiples a polynomial by a constant mul_c = lambda p , c : [ c * i for i in p ] # sums two polynomials together sum_p = lambda a , b : [ i + j for ( i , j ) in zip_longest ( a , b , fillvalue = 0 )] # trims a polynomial of extraneous zeroes trim_p = lambda l : reversed ( list ( dropwhile ( lambda x : x == 0 , reversed ( l )))) # multiply polynomials together mul_p = lambda a , b : reduce ( sum_p ,[ mul_x ( mul_c ( a , c ), d ) for ( d , c ) in enumerate ( b )]) # take a zero and give us the corresponding polynomial factor fact_z = lambda z : [ - z , 1 ] # take a list of zeros and produce the polynomial prod_z = lambda zs : list ( trim_p ( reduce ( mul_p , map ( fact_z , zs )))) class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body . text = r ''' Sketch the polynomial on this graph: Placeholder ''' def user_setup ( self , rng , ** kwargs ): pass class FactorQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Factors\" body . text = r ''' What are its factors? ''' solution . text = r ''' The factors are: $${ %- f or factor in factors.values() -%} { { %- i f factor.has_term -%} \\left( x {{ factor.sign }} {{ factor.num }} \\right) { %- e lse -%} x { %- e ndif -%} } { %- i f factor.degree != 1 -%} ^{ {{factor.degree}} } { %- e ndif -%} { %- e ndfor -%} $$ ''' def user_setup ( self , ctxt , rng , ** kwargs ): # Format the factors so that they're also easier to print print_factors = dict () # the `zeros` value returned by the parent question is found here # in the `ctxt` parameter under `ctxt['zeroes']` for z in ctxt [ 'zeros' ]: if z not in print_factors : print_factors [ z ] = { 'zero' : z , 'degree' : 1 , 'has_term' : z != 0 , # do we even print a constant term? 'sign' : \"+\" if z < 0 else \"-\" , 'num' : abs ( z ) } else : print_factors [ z ][ 'degree' ] += 1 return { \"factors\" : print_factors } class PolyQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Question\" body . text = r ''' For the following polynomial: $$ { %- f or term in poly -%} { %- i f not loop.first -%}{{term.sign}}{ %- e ndif -%} { {{term.num}}{ %- i f term.degree != 0 -%}x{ %- e ndif -%} } { %- i f term.degree > 1 -%}^{ {{term.degree}} }{ %- e ndif -%} { %- e ndfor -%} $$ ''' questions = { 'graph' : GraphQuestion , 'factors' : FactorQuestion } def user_setup ( self , rng , ** kwargs ): # Make a list of 4 random integers, the zeros of our polynomial zeros = list ( map ( lambda _ : rng . randint ( - 5 , 5 ), range ( 0 , 4 ))) # The polynomial such that each index is the coefficient of the # corresponding term. # (i.e. the polynomial is `poly[0] + poly[1]x + poly[2]x^2 ...` for a # given list `poly`) poly = prod_z ( zeros ) # Reorder the terms so the highest degree is first, and split it out # to make the templates easier to write. print_poly = list () for ( degree , coeff ) in reversed ( list ( enumerate ( poly ))): if coeff != 0 : print_poly . append ({ 'degree' : degree , 'coefficient' : coeff , 'sign' : \"-\" if coeff < 0 else \"+\" , 'num' : abs ( coeff ) }) return { 'poly' : print_poly , 'zeros' : zeros } We can then generate the new solution key with the following commands: $ ./exam.py cleanup $ ./exam.py build-solution:fake-class:erios !!! error \"TODO: image in assets/ \" In the next section we'll see how problems can use images and graphs, as well as external files and libraries in general.","title":"Using Problem Data in the Children"},{"location":"tutorial/multiple_choice_questions.html","text":"Multiple Choice Questions \u00b6 In addition to \"bare\" questions with no inherent structure, exam_gen also supports multiple choice questions with randomization, auto-grading, and all the features supported by the generic questions. Writing questions Choices Setting the number Marking correct and incorrect Shuffling (\"A and B, all of the above\") Errors -","title":"Multiple Choice Questions"},{"location":"tutorial/multiple_choice_questions.html#multiple-choice-questions","text":"In addition to \"bare\" questions with no inherent structure, exam_gen also supports multiple choice questions with randomization, auto-grading, and all the features supported by the generic questions. Writing questions Choices Setting the number Marking correct and incorrect Shuffling (\"A and B, all of the above\") Errors -","title":"Multiple Choice Questions"},{"location":"tutorial/project_organization.html","text":"Project Organization \u00b6 Right now polynomial_question.py is getting messy and needs to be cleaned up and split into more reasonable pieces. Future steps of the tutorial will also be easier if the project is set up in a more reasonable way. Moving polynomial_question.py into a Sub-Directory \u00b6 First we'll create a new subdirectory for the problem: $ mkdir poly_question And then move our current polynomial_question.py into it: $ mv polynomial_question.py poly_question/question.py Finally we'll change the import statement in exam.py to reflect the new location of the question: 5 from poly_question.question import * Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/env -S pipenv run python3 from exam_gen import * from addition_question import * from poly_question.question import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), } questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion } intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) This would be a good time to run the various build commands and ensure nothing has changed: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios $ ./exam.py build-solution:fake-class:erios Splitting poly_question/question.py into Multiple Files \u00b6 Even with the creation of a new directory our primary source file is still cluttered. Let's split it into multiple files for ease of use. Create a new poly_question/functions.py with the following contents: Complete Current poly_question/functions.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from functools import reduce from itertools import zip_longest , dropwhile # multiplies a polynomial by x^n mul_x = lambda p , n : ([ 0 ] * n ) + p # multiples a polynomial by a constant mul_c = lambda p , c : [ c * i for i in p ] # sums two polynomials together sum_p = lambda a , b : [ i + j for ( i , j ) in zip_longest ( a , b , fillvalue = 0 )] # trims a polynomial of extraneous zeroes trim_p = lambda l : reversed ( list ( dropwhile ( lambda x : x == 0 , reversed ( l )))) # multiply polynomials together mul_p = lambda a , b : reduce ( sum_p ,[ mul_x ( mul_c ( a , c ), d ) for ( d , c ) in enumerate ( b )]) # take a zero and give us the corresponding polynomial factor fact_z = lambda z : [ - z , 1 ] # take a list of zeros and produce the polynomial prod_z = lambda zs : list ( trim_p ( reduce ( mul_p , map ( fact_z , zs )))) Likewise a new poly_question/graph_question.py with the following: Complete Current poly_question/graph_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 from exam_gen import * from .functions import * class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body . text = r ''' Sketch the polynomial on this graph: Placeholder ''' def user_setup ( self , rng , ** kwargs ): pass Note how we use a python relative import on line 2, since functions.py is in the same sub-directory as this file. from poly_question.functions import * would also work, as it's an absolute import specified relative to the root of the assignment. We can similarly split off poly_question/factor_question.py with the following: Complete Current poly_question/factor_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from exam_gen import * from .functions import * class FactorQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Factors\" body . text = r ''' What are its factors? ''' solution . text = r ''' The factors are: $${ %- f or factor in factors.values() -%} { { %- i f factor.has_term -%} \\left( x {{ factor.sign }} {{ factor.num }} \\right) { %- e lse -%} x { %- e ndif -%} } { %- i f factor.degree != 1 -%} ^{ {{factor.degree}} } { %- e ndif -%} { %- e ndfor -%} $$ ''' def user_setup ( self , ctxt , rng , ** kwargs ): # Format the factors so that they're also easier to print print_factors = dict () # the `zeros` value returned by the parent question is found here # in the `ctxt` parameter under `ctxt['zeroes']` for z in ctxt [ 'zeros' ]: if z not in print_factors : print_factors [ z ] = { 'zero' : z , 'degree' : 1 , 'has_term' : z != 0 , # do we even print a constant term? 'sign' : \"+\" if z < 0 else \"-\" , 'num' : abs ( z ) } else : print_factors [ z ][ 'degree' ] += 1 return { \"factors\" : print_factors } Next remove GraphQuestion and PolyQuestion from poly_question/question.py . Instead we will import them from their new locations, with the following: 1 2 3 4 from exam_gen import * from .functions import * from .graph_question import * from .factor_question import * Complete Current poly_question/question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from exam_gen import * from .functions import * from .graph_question import * from .factor_question import * class PolyQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Question\" body . text = r ''' For the following polynomial: $$ { %- f or term in poly -%} { %- i f not loop.first -%}{{term.sign}}{ %- e ndif -%} { {{term.num}}{ %- i f term.degree != 0 -%}x{ %- e ndif -%} } { %- i f term.degree > 1 -%}^{ {{term.degree}} }{ %- e ndif -%} { %- e ndfor -%} $$ ''' questions = { 'graph' : GraphQuestion , 'factors' : FactorQuestion } def user_setup ( self , rng , ** kwargs ): # Make a list of 4 random integers, the zeros of our polynomial zeros = list ( map ( lambda _ : rng . randint ( - 5 , 5 ), range ( 0 , 4 ))) # The polynomial such that each index is the coefficient of the # corresponding term. # (i.e. the polynomial is `poly[0] + poly[1]x + poly[2]x^2 ...` for a # given list `poly`) poly = prod_z ( zeros ) # Reorder the terms so the highest degree is first, and split it out # to make the templates easier to write. print_poly = list () for ( degree , coeff ) in reversed ( list ( enumerate ( poly ))): if coeff != 0 : print_poly . append ({ 'degree' : degree , 'coefficient' : coeff , 'sign' : \"-\" if coeff < 0 else \"+\" , 'num' : abs ( coeff ) }) return { 'poly' : print_poly , 'zeros' : zeros } Again, this would be a good time to run the various build commands and ensure nothing has changed: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios $ ./exam.py build-solution:fake-class:erios Using File Templates \u00b6 Some of the templates we use in the questions are also proving unwieldy, so we can move them into files. Create a file for the FactorQuestion 's solution variable by placing the following into poly_question/factor_solution.jn2.tex : Complete Current poly_question/factor_solution.jn2.tex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 The factors are: $$ { %- for factor in factors.values() -%} { { %- if factor.has_term -%} \\left ( x {{ factor.sign }} {{ factor.num }} \\right ) { %- else -%} x { %- endif -%} } { %- if factor.degree != 1 -%} ^{ {{factor.degree}} } { %- endif -%} { %- endfor -%} $$ We can then edit factor_question.py to make it use the template file rather than the inline code by removing the assignment to solution.text and replacing it with the following: 11 solution . file = \"factor_solution.jn2.tex\" Complete Current poly_question/factor_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from exam_gen import * from .functions import * class FactorQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Factors\" body . text = r ''' What are its factors? ''' solution . file = \"factor_solution.jn2.tex\" def user_setup ( self , ctxt , rng , ** kwargs ): # Format the factors so that they're also easier to print print_factors = dict () # the `zeros` value returned by the parent question is found here # in the `ctxt` parameter under `ctxt['zeroes']` for z in ctxt [ 'zeros' ]: if z not in print_factors : print_factors [ z ] = { 'zero' : z , 'degree' : 1 , 'has_term' : z != 0 , # do we even print a constant term? 'sign' : \"+\" if z < 0 else \"-\" , 'num' : abs ( z ) } else : print_factors [ z ][ 'degree' ] += 1 return { \"factors\" : print_factors } As usual, none of the actual contents of the assignment have changed so we can run the build commands to verify things still work: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios $ ./exam.py build-solution:fake-class:erios Notes on Template Files You can use *.file anywhere you can use *.text to define the text of a template field. This includes intro and body , as well as any other similar variables. The library will search for the template file in the following order: The directory with the question/exam where it's specified. The directories of each parent question or exam, until it reaches the root of project. The set of templates provided with the exam_gen library. TODO: link to detailed search path description in user guide","title":"Project Organization"},{"location":"tutorial/project_organization.html#project-organization","text":"Right now polynomial_question.py is getting messy and needs to be cleaned up and split into more reasonable pieces. Future steps of the tutorial will also be easier if the project is set up in a more reasonable way.","title":"Project Organization"},{"location":"tutorial/project_organization.html#moving-polynomial_questionpy-into-a-sub-directory","text":"First we'll create a new subdirectory for the problem: $ mkdir poly_question And then move our current polynomial_question.py into it: $ mv polynomial_question.py poly_question/question.py Finally we'll change the import statement in exam.py to reflect the new location of the question: 5 from poly_question.question import * Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #!/usr/bin/env -S pipenv run python3 from exam_gen import * from addition_question import * from poly_question.question import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), } questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion } intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) This would be a good time to run the various build commands and ensure nothing has changed: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios $ ./exam.py build-solution:fake-class:erios","title":"Moving polynomial_question.py into a Sub-Directory"},{"location":"tutorial/project_organization.html#splitting-poly_questionquestionpy-into-multiple-files","text":"Even with the creation of a new directory our primary source file is still cluttered. Let's split it into multiple files for ease of use. Create a new poly_question/functions.py with the following contents: Complete Current poly_question/functions.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from functools import reduce from itertools import zip_longest , dropwhile # multiplies a polynomial by x^n mul_x = lambda p , n : ([ 0 ] * n ) + p # multiples a polynomial by a constant mul_c = lambda p , c : [ c * i for i in p ] # sums two polynomials together sum_p = lambda a , b : [ i + j for ( i , j ) in zip_longest ( a , b , fillvalue = 0 )] # trims a polynomial of extraneous zeroes trim_p = lambda l : reversed ( list ( dropwhile ( lambda x : x == 0 , reversed ( l )))) # multiply polynomials together mul_p = lambda a , b : reduce ( sum_p ,[ mul_x ( mul_c ( a , c ), d ) for ( d , c ) in enumerate ( b )]) # take a zero and give us the corresponding polynomial factor fact_z = lambda z : [ - z , 1 ] # take a list of zeros and produce the polynomial prod_z = lambda zs : list ( trim_p ( reduce ( mul_p , map ( fact_z , zs )))) Likewise a new poly_question/graph_question.py with the following: Complete Current poly_question/graph_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 from exam_gen import * from .functions import * class GraphQuestion ( LatexDoc , Question ): metadata . name = \"Graph Question\" body . text = r ''' Sketch the polynomial on this graph: Placeholder ''' def user_setup ( self , rng , ** kwargs ): pass Note how we use a python relative import on line 2, since functions.py is in the same sub-directory as this file. from poly_question.functions import * would also work, as it's an absolute import specified relative to the root of the assignment. We can similarly split off poly_question/factor_question.py with the following: Complete Current poly_question/factor_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from exam_gen import * from .functions import * class FactorQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Factors\" body . text = r ''' What are its factors? ''' solution . text = r ''' The factors are: $${ %- f or factor in factors.values() -%} { { %- i f factor.has_term -%} \\left( x {{ factor.sign }} {{ factor.num }} \\right) { %- e lse -%} x { %- e ndif -%} } { %- i f factor.degree != 1 -%} ^{ {{factor.degree}} } { %- e ndif -%} { %- e ndfor -%} $$ ''' def user_setup ( self , ctxt , rng , ** kwargs ): # Format the factors so that they're also easier to print print_factors = dict () # the `zeros` value returned by the parent question is found here # in the `ctxt` parameter under `ctxt['zeroes']` for z in ctxt [ 'zeros' ]: if z not in print_factors : print_factors [ z ] = { 'zero' : z , 'degree' : 1 , 'has_term' : z != 0 , # do we even print a constant term? 'sign' : \"+\" if z < 0 else \"-\" , 'num' : abs ( z ) } else : print_factors [ z ][ 'degree' ] += 1 return { \"factors\" : print_factors } Next remove GraphQuestion and PolyQuestion from poly_question/question.py . Instead we will import them from their new locations, with the following: 1 2 3 4 from exam_gen import * from .functions import * from .graph_question import * from .factor_question import * Complete Current poly_question/question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from exam_gen import * from .functions import * from .graph_question import * from .factor_question import * class PolyQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Question\" body . text = r ''' For the following polynomial: $$ { %- f or term in poly -%} { %- i f not loop.first -%}{{term.sign}}{ %- e ndif -%} { {{term.num}}{ %- i f term.degree != 0 -%}x{ %- e ndif -%} } { %- i f term.degree > 1 -%}^{ {{term.degree}} }{ %- e ndif -%} { %- e ndfor -%} $$ ''' questions = { 'graph' : GraphQuestion , 'factors' : FactorQuestion } def user_setup ( self , rng , ** kwargs ): # Make a list of 4 random integers, the zeros of our polynomial zeros = list ( map ( lambda _ : rng . randint ( - 5 , 5 ), range ( 0 , 4 ))) # The polynomial such that each index is the coefficient of the # corresponding term. # (i.e. the polynomial is `poly[0] + poly[1]x + poly[2]x^2 ...` for a # given list `poly`) poly = prod_z ( zeros ) # Reorder the terms so the highest degree is first, and split it out # to make the templates easier to write. print_poly = list () for ( degree , coeff ) in reversed ( list ( enumerate ( poly ))): if coeff != 0 : print_poly . append ({ 'degree' : degree , 'coefficient' : coeff , 'sign' : \"-\" if coeff < 0 else \"+\" , 'num' : abs ( coeff ) }) return { 'poly' : print_poly , 'zeros' : zeros } Again, this would be a good time to run the various build commands and ensure nothing has changed: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios $ ./exam.py build-solution:fake-class:erios","title":"Splitting poly_question/question.py into Multiple Files"},{"location":"tutorial/project_organization.html#using-file-templates","text":"Some of the templates we use in the questions are also proving unwieldy, so we can move them into files. Create a file for the FactorQuestion 's solution variable by placing the following into poly_question/factor_solution.jn2.tex : Complete Current poly_question/factor_solution.jn2.tex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 The factors are: $$ { %- for factor in factors.values() -%} { { %- if factor.has_term -%} \\left ( x {{ factor.sign }} {{ factor.num }} \\right ) { %- else -%} x { %- endif -%} } { %- if factor.degree != 1 -%} ^{ {{factor.degree}} } { %- endif -%} { %- endfor -%} $$ We can then edit factor_question.py to make it use the template file rather than the inline code by removing the assignment to solution.text and replacing it with the following: 11 solution . file = \"factor_solution.jn2.tex\" Complete Current poly_question/factor_question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 from exam_gen import * from .functions import * class FactorQuestion ( LatexDoc , Question ): metadata . name = \"Polynomial Factors\" body . text = r ''' What are its factors? ''' solution . file = \"factor_solution.jn2.tex\" def user_setup ( self , ctxt , rng , ** kwargs ): # Format the factors so that they're also easier to print print_factors = dict () # the `zeros` value returned by the parent question is found here # in the `ctxt` parameter under `ctxt['zeroes']` for z in ctxt [ 'zeros' ]: if z not in print_factors : print_factors [ z ] = { 'zero' : z , 'degree' : 1 , 'has_term' : z != 0 , # do we even print a constant term? 'sign' : \"+\" if z < 0 else \"-\" , 'num' : abs ( z ) } else : print_factors [ z ][ 'degree' ] += 1 return { \"factors\" : print_factors } As usual, none of the actual contents of the assignment have changed so we can run the build commands to verify things still work: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios $ ./exam.py build-solution:fake-class:erios Notes on Template Files You can use *.file anywhere you can use *.text to define the text of a template field. This includes intro and body , as well as any other similar variables. The library will search for the template file in the following order: The directory with the question/exam where it's specified. The directories of each parent question or exam, until it reaches the root of project. The set of templates provided with the exam_gen library. TODO: link to detailed search path description in user guide","title":"Using File Templates"},{"location":"tutorial/writing_questions.html","text":"Writing Questions \u00b6 Any actual assignment requires at least one question for students to answer, so let's add one. First we create the file: $ touch addition_question.py Then in a text editor we add the following content to addition_question.py : 1 2 3 4 5 6 7 8 from exam_gen import * class SumQuestion ( LatexDoc , Question ): metadata . name = \"Basic Addition Question\" body . text = \"Placeholder text for the body of the question.\" solution . text = \"Placeholder text for the solution of the question.\" We then need to make sure that exam.py knows to include this question. First part of that is adding the appropriate import statement to exam.py on line 4: 4 from addition_question import * Note that addition_question here is taken from the addition_question.py filename. This is a standard python import statement. Next we need to register the question with NewExam by editing the questions variable to read: 16 17 18 questions = { 'addition-question' : SumQuestion } Note that SumQuestion here is the new question's class. Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/env -S pipenv run python3 from exam_gen import * from addition_question import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), } questions = { 'addition-question' : SumQuestion } intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) We can now generate a test exam with this question: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios The output in ~/out/exam-exam/class-fake-class/erios.pdf should look as follows: Contents of erios.pdf In the next section of the tutorial we'll flesh out the question and add some student specific customization.","title":"Writing Questions"},{"location":"tutorial/writing_questions.html#writing-questions","text":"Any actual assignment requires at least one question for students to answer, so let's add one. First we create the file: $ touch addition_question.py Then in a text editor we add the following content to addition_question.py : 1 2 3 4 5 6 7 8 from exam_gen import * class SumQuestion ( LatexDoc , Question ): metadata . name = \"Basic Addition Question\" body . text = \"Placeholder text for the body of the question.\" solution . text = \"Placeholder text for the solution of the question.\" We then need to make sure that exam.py knows to include this question. First part of that is adding the appropriate import statement to exam.py on line 4: 4 from addition_question import * Note that addition_question here is taken from the addition_question.py filename. This is a standard python import statement. Next we need to register the question with NewExam by editing the questions variable to read: 16 17 18 questions = { 'addition-question' : SumQuestion } Note that SumQuestion here is the new question's class. Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #!/usr/bin/env -S pipenv run python3 from exam_gen import * from addition_question import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), } questions = { 'addition-question' : SumQuestion } intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) We can now generate a test exam with this question: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios The output in ~/out/exam-exam/class-fake-class/erios.pdf should look as follows: Contents of erios.pdf In the next section of the tutorial we'll flesh out the question and add some student specific customization.","title":"Writing Questions"},{"location":"tutorial/multiple_choice/choices_and_shuffling.html","text":"Shuffling Question Choices \u00b6 This time we'll be examining a slightly more complex question where we want finer grained control of the options presented to the student. TODO: image in assets/ Initial Setup \u00b6 First we can create a new file and folder for our question: $ mkdir matrix_question $ touch matrix_question/question.py Then, as before, add a basic stub we can expand later. Start by writing the following into matrix_question/question.py : Complete Current graph_question/question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from exam_gen import * class MatrixQuestion ( LatexDoc , MultipleChoiceQuestion ): # We're using the nicematrix package to add column labels to our matrix. settings . latex . header_includes = r ''' \\usepackage {nicematrix} ''' # Core problem text body . text = r ''' Which pairs of columns on the following matrix are \\emph {not} independent? \\NiceMatrixOptions{code-for-first-row= \\color {blue} } $$\\begin {bNiceMatrix} [first-row] C_0 & C_1 & C_2 & C_3 & C_4 \\\\ { % f or r in range(0,4) -%} { %- f or c in range(0,5) -%}{{ matrix[c][r] }} { %- i f not loop.last %} & { % e ndif %}{ % e ndfor %} \\\\ { % e ndfor %} \\end {bNiceMatrix} $$ Choose the single best option. ''' def user_setup ( self , rng , ctxt ): return self . gen_matrix_data ( rng ) def gen_matrix_data ( self , rng ): # Generate some independent cols i_cols = [[ rng . randint ( - 20 , 20 ) for _ in range ( 0 , 4 )] for _ in range ( 0 , 3 )] # Pick a few columns for our output matrix o_base = rng . sample ([ 0 , 0 , 1 , 1 , 2 ], k = 5 ) mults = list ( range ( - 3 , 4 )) mults . remove ( 0 ) const_mul = lambda : rng . sample ( mults , k = 1 ) o_cols = [[ c * j for j in i_cols [ i ]] for i in o_base for c in const_mul ()] # Get our two pairs of dependent columns c_ans = [[ c for c in range ( 0 , 5 ) if o_base [ c ] == i ] for i in [ 0 , 1 ]] # Make an incorrect answer i_ans = rng . sample ( range ( 0 , 5 ), 2 ) while ( i_ans in c_ans ): i_ans = rng . sample ( range ( 0 , 5 ), 2 ) # return all that info return { 'matrix' : o_cols , 'dependent_cols' : c_ans , 'independent_col' : i_ans } This time we're providing some of the setup code as it's not too relevant to the point of this example. As before, change exam.py to include our new question by importing the correct file and updating our question list, as follows: To add the new import: 7 from matrix_question.question import * To add our new question to the question list: 11 12 13 14 15 16 questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion , 'graph-question' : GraphQuestion , 'matrix-question' : MatrixQuestion , } Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/env -S pipenv run python3 from exam_gen import * from addition_question import * from poly_question.question import * from graph_question.question import * from matrix_question.question import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), } questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion , 'graph-question' : GraphQuestion , 'matrix-question' : MatrixQuestion , } intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) Basic Setup \u00b6 We can start first by setting an alternate style of grading for this question. Add the following to MatrixQuestion : 52 53 # Set the style of grade appropriately settings . grade . style = \"all_correct\" The \"all_correct\" option will only give a student points for this question if the select all of the correct choices and none of the incorrect ones. In this case we're only going to mark a single option as correct, so everything functions like a normal multiple choice problem with a single answer. As before, we're going to stick with 5 total choices. So add: 55 choice . total_number = 5 Differentiating Answer Choices \u00b6 Before move on, it's worth examining what context we return from user_setup so that we can know what variables are accessible from the choice templates: matrix : This is just the base matrix for the problem in matrix [ col ][ row ] form. depdendent_cols : This is a list of pairs of depdendent columns, such that for any i , dependent_cols[i][0] and dependent_cols[i][1] are two columns who are dependent on each other. independent_cols : Is a single pair of columns which aren't dependent on on each other. With what we can set each of the choices. We'll start by setting a default template for all of the choices, basically setting the .text property for all the options. Add the following: 57 58 59 60 # Set the default text for all choices choice . text = r ''' $C_{{ dependent_cols[index][0] }}$ and $C_{{ dependent_cols[index][1] }}$ ''' As with the previous problem, we're using index here to differentiate between each of the available options. For choice [ 0 ] the index is set to 0 , for choice [ 1 ] it's set to 1 , and so on. With the default taken care of, we can set an option for the independent column. So set choice [ 2 ] by adding: 62 63 64 65 # Set individual choices that the default isn't good for choice [ 2 ] . text = r ''' $C_{{ independent_col[0] }}$ and $C_{{ independent_col[1] }}$ ''' At this point, we know choice 0 and 1 are correct and 2 is incorrect. Here's where we'll set up a combined option. Add the following: 67 68 69 70 71 # We can use the `choice_letters` variable to refer to other choices choice [ 3 ] . text = r ''' Both {{ choice_letters[0] }} and {{ choice_letters[1] }}. ''' choice [ 3 ] . is_correct = True Notice how we use the choice_letters variables to turn the choice numbers we work with ( 0 and 1 ) into the letters that students taking the exam will see. Importantly this works even with shuffling. If you examine multiple student exams the letters in this option will be different as the options get shuffled around. Now we can add the obligatory last option: 73 74 75 choice [ 4 ] . text = r ''' All of the above ''' Finally we can specify that we should only shuffle the first three options with the following: 77 78 # Chose which options to shuffle, leave others in their place settings . grade . shuffle = [ 0 , 1 , 2 ] While True and False turn shuffling on and off globally, you can also specify a list of options to shuffle. In this case just the first three. Complete Current matrix_question/question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 from exam_gen import * class MatrixQuestion ( LatexDoc , MultipleChoiceQuestion ): # We're using the nicematrix package to add column labels to our matrix. settings . latex . header_includes = r ''' \\usepackage {nicematrix} ''' # Core problem text body . text = r ''' Which pairs of columns on the following matrix are \\emph {not} independent? \\NiceMatrixOptions{code-for-first-row= \\color {blue} } $$\\begin {bNiceMatrix} [first-row] C_0 & C_1 & C_2 & C_3 & C_4 \\\\ { % f or r in range(0,4) -%} { %- f or c in range(0,5) -%}{{ matrix[c][r] }} { %- i f not loop.last %} & { % e ndif %}{ % e ndfor %} \\\\ { % e ndfor %} \\end {bNiceMatrix} $$ Choose the single best option. ''' def user_setup ( self , rng , ctxt ): return self . gen_matrix_data ( rng ) def gen_matrix_data ( self , rng ): # Generate some independent cols i_cols = [[ rng . randint ( - 20 , 20 ) for _ in range ( 0 , 4 )] for _ in range ( 0 , 3 )] # Pick a few columns for our output matrix o_base = rng . sample ([ 0 , 0 , 1 , 1 , 2 ], k = 5 ) mults = list ( range ( - 3 , 4 )) mults . remove ( 0 ) const_mul = lambda : rng . sample ( mults , k = 1 ) o_cols = [[ c * j for j in i_cols [ i ]] for i in o_base for c in const_mul ()] # Get our two pairs of dependent columns c_ans = [[ c for c in range ( 0 , 5 ) if o_base [ c ] == i ] for i in [ 0 , 1 ]] # Make an incorrect answer i_ans = rng . sample ( range ( 0 , 5 ), 2 ) while ( i_ans in c_ans ): i_ans = rng . sample ( range ( 0 , 5 ), 2 ) # return all that info return { 'matrix' : o_cols , 'dependent_cols' : c_ans , 'independent_col' : i_ans } # Set the style of grade appropriately settings . grade . style = \"all_correct\" choice . total_number = 5 # Set the default text for all choices choice . text = r ''' $C_{{ dependent_cols[index][0] }}$ and $C_{{ dependent_cols[index][1] }}$ ''' # Set individual choices that the default isn't good for choice [ 2 ] . text = r ''' $C_{{ independent_col[0] }}$ and $C_{{ independent_col[1] }}$ ''' # We can use the `choice_letters` variable to refer to other choices choice [ 3 ] . text = r ''' Both {{ choice_letters[0] }} and {{ choice_letters[1] }}. ''' choice [ 3 ] . is_correct = True choice [ 4 ] . text = r ''' All of the above ''' # Chose which options to shuffle, leave others in their place settings . grade . shuffle = [ 0 , 1 , 2 ] Finishing Up \u00b6 Finally generate the new solution key with the following commands: $ ./exam.py cleanup $ ./exam.py build-solution:fake-class:erios TODO: image in assets/","title":"Choices and Shuffling"},{"location":"tutorial/multiple_choice/choices_and_shuffling.html#shuffling-question-choices","text":"This time we'll be examining a slightly more complex question where we want finer grained control of the options presented to the student. TODO: image in assets/","title":"Shuffling Question Choices"},{"location":"tutorial/multiple_choice/choices_and_shuffling.html#initial-setup","text":"First we can create a new file and folder for our question: $ mkdir matrix_question $ touch matrix_question/question.py Then, as before, add a basic stub we can expand later. Start by writing the following into matrix_question/question.py : Complete Current graph_question/question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 from exam_gen import * class MatrixQuestion ( LatexDoc , MultipleChoiceQuestion ): # We're using the nicematrix package to add column labels to our matrix. settings . latex . header_includes = r ''' \\usepackage {nicematrix} ''' # Core problem text body . text = r ''' Which pairs of columns on the following matrix are \\emph {not} independent? \\NiceMatrixOptions{code-for-first-row= \\color {blue} } $$\\begin {bNiceMatrix} [first-row] C_0 & C_1 & C_2 & C_3 & C_4 \\\\ { % f or r in range(0,4) -%} { %- f or c in range(0,5) -%}{{ matrix[c][r] }} { %- i f not loop.last %} & { % e ndif %}{ % e ndfor %} \\\\ { % e ndfor %} \\end {bNiceMatrix} $$ Choose the single best option. ''' def user_setup ( self , rng , ctxt ): return self . gen_matrix_data ( rng ) def gen_matrix_data ( self , rng ): # Generate some independent cols i_cols = [[ rng . randint ( - 20 , 20 ) for _ in range ( 0 , 4 )] for _ in range ( 0 , 3 )] # Pick a few columns for our output matrix o_base = rng . sample ([ 0 , 0 , 1 , 1 , 2 ], k = 5 ) mults = list ( range ( - 3 , 4 )) mults . remove ( 0 ) const_mul = lambda : rng . sample ( mults , k = 1 ) o_cols = [[ c * j for j in i_cols [ i ]] for i in o_base for c in const_mul ()] # Get our two pairs of dependent columns c_ans = [[ c for c in range ( 0 , 5 ) if o_base [ c ] == i ] for i in [ 0 , 1 ]] # Make an incorrect answer i_ans = rng . sample ( range ( 0 , 5 ), 2 ) while ( i_ans in c_ans ): i_ans = rng . sample ( range ( 0 , 5 ), 2 ) # return all that info return { 'matrix' : o_cols , 'dependent_cols' : c_ans , 'independent_col' : i_ans } This time we're providing some of the setup code as it's not too relevant to the point of this example. As before, change exam.py to include our new question by importing the correct file and updating our question list, as follows: To add the new import: 7 from matrix_question.question import * To add our new question to the question list: 11 12 13 14 15 16 questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion , 'graph-question' : GraphQuestion , 'matrix-question' : MatrixQuestion , } Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #!/usr/bin/env -S pipenv run python3 from exam_gen import * from addition_question import * from poly_question.question import * from graph_question.question import * from matrix_question.question import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), } questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion , 'graph-question' : GraphQuestion , 'matrix-question' : MatrixQuestion , } intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ())","title":"Initial Setup"},{"location":"tutorial/multiple_choice/choices_and_shuffling.html#basic-setup","text":"We can start first by setting an alternate style of grading for this question. Add the following to MatrixQuestion : 52 53 # Set the style of grade appropriately settings . grade . style = \"all_correct\" The \"all_correct\" option will only give a student points for this question if the select all of the correct choices and none of the incorrect ones. In this case we're only going to mark a single option as correct, so everything functions like a normal multiple choice problem with a single answer. As before, we're going to stick with 5 total choices. So add: 55 choice . total_number = 5","title":"Basic Setup"},{"location":"tutorial/multiple_choice/choices_and_shuffling.html#differentiating-answer-choices","text":"Before move on, it's worth examining what context we return from user_setup so that we can know what variables are accessible from the choice templates: matrix : This is just the base matrix for the problem in matrix [ col ][ row ] form. depdendent_cols : This is a list of pairs of depdendent columns, such that for any i , dependent_cols[i][0] and dependent_cols[i][1] are two columns who are dependent on each other. independent_cols : Is a single pair of columns which aren't dependent on on each other. With what we can set each of the choices. We'll start by setting a default template for all of the choices, basically setting the .text property for all the options. Add the following: 57 58 59 60 # Set the default text for all choices choice . text = r ''' $C_{{ dependent_cols[index][0] }}$ and $C_{{ dependent_cols[index][1] }}$ ''' As with the previous problem, we're using index here to differentiate between each of the available options. For choice [ 0 ] the index is set to 0 , for choice [ 1 ] it's set to 1 , and so on. With the default taken care of, we can set an option for the independent column. So set choice [ 2 ] by adding: 62 63 64 65 # Set individual choices that the default isn't good for choice [ 2 ] . text = r ''' $C_{{ independent_col[0] }}$ and $C_{{ independent_col[1] }}$ ''' At this point, we know choice 0 and 1 are correct and 2 is incorrect. Here's where we'll set up a combined option. Add the following: 67 68 69 70 71 # We can use the `choice_letters` variable to refer to other choices choice [ 3 ] . text = r ''' Both {{ choice_letters[0] }} and {{ choice_letters[1] }}. ''' choice [ 3 ] . is_correct = True Notice how we use the choice_letters variables to turn the choice numbers we work with ( 0 and 1 ) into the letters that students taking the exam will see. Importantly this works even with shuffling. If you examine multiple student exams the letters in this option will be different as the options get shuffled around. Now we can add the obligatory last option: 73 74 75 choice [ 4 ] . text = r ''' All of the above ''' Finally we can specify that we should only shuffle the first three options with the following: 77 78 # Chose which options to shuffle, leave others in their place settings . grade . shuffle = [ 0 , 1 , 2 ] While True and False turn shuffling on and off globally, you can also specify a list of options to shuffle. In this case just the first three. Complete Current matrix_question/question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 from exam_gen import * class MatrixQuestion ( LatexDoc , MultipleChoiceQuestion ): # We're using the nicematrix package to add column labels to our matrix. settings . latex . header_includes = r ''' \\usepackage {nicematrix} ''' # Core problem text body . text = r ''' Which pairs of columns on the following matrix are \\emph {not} independent? \\NiceMatrixOptions{code-for-first-row= \\color {blue} } $$\\begin {bNiceMatrix} [first-row] C_0 & C_1 & C_2 & C_3 & C_4 \\\\ { % f or r in range(0,4) -%} { %- f or c in range(0,5) -%}{{ matrix[c][r] }} { %- i f not loop.last %} & { % e ndif %}{ % e ndfor %} \\\\ { % e ndfor %} \\end {bNiceMatrix} $$ Choose the single best option. ''' def user_setup ( self , rng , ctxt ): return self . gen_matrix_data ( rng ) def gen_matrix_data ( self , rng ): # Generate some independent cols i_cols = [[ rng . randint ( - 20 , 20 ) for _ in range ( 0 , 4 )] for _ in range ( 0 , 3 )] # Pick a few columns for our output matrix o_base = rng . sample ([ 0 , 0 , 1 , 1 , 2 ], k = 5 ) mults = list ( range ( - 3 , 4 )) mults . remove ( 0 ) const_mul = lambda : rng . sample ( mults , k = 1 ) o_cols = [[ c * j for j in i_cols [ i ]] for i in o_base for c in const_mul ()] # Get our two pairs of dependent columns c_ans = [[ c for c in range ( 0 , 5 ) if o_base [ c ] == i ] for i in [ 0 , 1 ]] # Make an incorrect answer i_ans = rng . sample ( range ( 0 , 5 ), 2 ) while ( i_ans in c_ans ): i_ans = rng . sample ( range ( 0 , 5 ), 2 ) # return all that info return { 'matrix' : o_cols , 'dependent_cols' : c_ans , 'independent_col' : i_ans } # Set the style of grade appropriately settings . grade . style = \"all_correct\" choice . total_number = 5 # Set the default text for all choices choice . text = r ''' $C_{{ dependent_cols[index][0] }}$ and $C_{{ dependent_cols[index][1] }}$ ''' # Set individual choices that the default isn't good for choice [ 2 ] . text = r ''' $C_{{ independent_col[0] }}$ and $C_{{ independent_col[1] }}$ ''' # We can use the `choice_letters` variable to refer to other choices choice [ 3 ] . text = r ''' Both {{ choice_letters[0] }} and {{ choice_letters[1] }}. ''' choice [ 3 ] . is_correct = True choice [ 4 ] . text = r ''' All of the above ''' # Chose which options to shuffle, leave others in their place settings . grade . shuffle = [ 0 , 1 , 2 ]","title":"Differentiating Answer Choices"},{"location":"tutorial/multiple_choice/choices_and_shuffling.html#finishing-up","text":"Finally generate the new solution key with the following commands: $ ./exam.py cleanup $ ./exam.py build-solution:fake-class:erios TODO: image in assets/","title":"Finishing Up"},{"location":"tutorial/multiple_choice/custom_grading_and_setup.html","text":"Custom Setup and Grading \u00b6 Here we'll be adding a needlessly complicated problem that shows off a number of advanced features and ways to interact with the exam_gen library. Students will have to choose an assignment of variables and some constraints to create a constraint satisfaction problem that meets various conditions. TODO: image in assets/ Initial Setup \u00b6 First we can create a new folder for our question and some initial files: $ mkdir csp_question $ touch csp_question/question.py $ touch csp_question/exp.py $ touch csp_question/small_text.jn2.tex exp.py will contain some code for manipulating and printing boolean formulas. Put the following in csp_question/exp.py : Complete Current csp_question/exp.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 import attr @attr . s class Var (): name = attr . ib () def eval ( self , vars ): return _eval_exp ( vars . get ( self . name , self ), vars ) def print_tex ( self ): return r '\\mathit{\\mathsf{ %s }}' % self . name def is_complex ( self ): return False @attr . s class Not (): exp = attr . ib () def __init__ ( self , e ): self . __attrs_init__ ( e ) def eval ( self , vars ): val = _eval_exp ( self . exp , vars ) if isinstance ( val , bool ): return not val elif isinstance ( val , Not ): return val . exp else : return val def print_tex ( self ): return r '\\neg{ %s }' % _print_wrap_tex ( self . exp ) def is_complex ( self ): return False @attr . s ( init = False ) class And (): exps = attr . ib () def __init__ ( self , * cmpnts ): self . __attrs_init__ ( cmpnts ) def eval ( self , vars ): result = list () for exp in self . exps : val = _eval_exp ( exp , vars ) if isinstance ( val , bool ): if val == False : return False elif isinstance ( val , And ): result += val . exps else : result . append ( val ) return result if len ( self . exps ) != 0 else True def is_complex ( self ): return len ( self . exps ) > 1 def print_tex ( self ): if len ( self . exps ) == 0 : return _print_tex ( True ) elif len ( self . exps ) == 1 : return _print_tex ( self . exps [ 0 ]) else : return r ' \\wedge ' . join ( map ( _print_wrap_tex , self . exps )) @attr . s ( init = False ) class Or (): exps = attr . ib () def __init__ ( self , * cmpnts ): self . __attrs_init__ ( cmpnts ) def eval ( self , vars ): result = list () for exp in self . exps : val = _eval_exp ( exp , vars ) if isinstance ( val , bool ): if val == True : return True elif isinstance ( val , Or ): result += val . exps else : result . append ( val ) return result if len ( self . exps ) != 0 else False def is_complex ( self ): return len ( self . exps ) > 1 def print_tex ( self ): if len ( self . exps ) == 0 : return _print_tex ( False ) elif len ( self . exps ) == 1 : return _print_tex ( self . exps [ 0 ]) else : return r ' \\vee ' . join ( map ( _print_wrap_tex , self . exps )) def _eval_exp ( exp , vars ): if isinstance ( exp , bool ): return exp else : exp . eval ( vars ) def _print_tex ( exp ): if isinstance ( exp , bool ): return r '\\mathsf{\\mathit{ %s }}' % ( \"True\" if exp else \"False\" ) else : return exp . print_tex () def _print_wrap_tex ( exp ): if isinstance ( exp , bool ): return _print_tex ( exp ) elif exp . is_complex (): return r '\\left( %s \\right)' % _print_tex ( exp ) else : return _print_tex ( exp ) Next we can initialize csp_question/question.py with: Complete Current csp_question/question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from exam_gen import * from .exp import * # Problem Variables w = Var ( \"w\" ) x = Var ( \"x\" ) y = Var ( \"y\" ) z = Var ( \"z\" ) vars = [ w , x , y , z ] # Problem Constraints exps = [ Not ( w ), Or ( x , Not ( w )), And ( w , Not ( Or ( x , Not ( z ))), Or ( y , z )), Or ( And ( x , Not ( w ), y , Not ( z )), And ( Not ( x ), Not ( y ))), And ( Or ( x , w , Not ( y ), Not ( z )), Or ( Not ( w ), z , y ), Or ( Not ( x ), w , y )), Or ( Not ( w ), x , And ( z , Not ( w ))), Or ( y , Not ( x )) ] class CspQuestion ( LatexDoc , MultipleChoiceQuestion ): body . text = r ''' From the options below choose: \\begin {itemize} \\item An assignment for \\emph {every} variable \\item At least two constraints \\end {itemize} Such that all chosen constraints are satisfied. Extra credit points will be awarded for every constraint above 2 that is chosen, but no points will be awarded if even a single chosen constraint is not satisfied by the given assignment. ''' # No need to shuffle this problem settings . grade . shuffle = False Then we can edit exam.py to import and use the new question. To add the new import: 8 from csp_question.question import * To add our new question to the question list: 20 21 22 23 24 25 26 questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion , 'graph-question' : GraphQuestion , 'matrix-question' : MatrixQuestion , 'csp-question' : CspQuestion , } Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/usr/bin/env -S pipenv run python3 from exam_gen import * from addition_question import * from poly_question.question import * from graph_question.question import * from matrix_question.question import * from csp_question.question import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), } questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion , 'graph-question' : GraphQuestion , 'matrix-question' : MatrixQuestion , 'csp-question' : CspQuestion , } intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) Using Custom Question Templates \u00b6 This question has a lot of options and spills over to multiple pages. To fix this we'll overload the basic question template with one that has smaller text. First we can fill csp_question/small_text.jn2.tex with the following: Complete Current csp_question/small_text.jn2.tex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { % if nesting_depth == 1 %} { \\large { Problem: {{ number }} } } \\\\ { % elif nesting_depth == 2 %} { \\large { Sub-problem: {{ number }} } } \\\\ { % elif nesting_depth == 3 %} { \\large { Sub-sub-problem: {{ number }} } } \\\\ { % else %} { \\large { Part: {{ number }} } } \\\\ { % endif %} { \\small {{ body.text }} \\\\ { % if format == 'solution' %} \\solution { {{ solution.text }} } \\\\ { % endif %} \\begin { enumerate } [label=( \\alph* )] { % for choice in choices %} \\item {{ choice.text }} { %- if format == 'solution' %} \\\\ \\solution { {{ \"correct\" if choice.is _ correct else \"incorrect\" }} { %- if choice.solution -%} {{ choice.solution }} {%- endif -%} } { %- endif -%} { %- endfor %} \\end { enumerate } } And then override the default template by adding the following to csp_question/question.py : 41 42 # Alternate template so question will render on a single page. settings . template . embedded = \"small_text.jn2.tex\" The settings.template.embedded option controls which template is used when a question or exam is being rendered within another document. If we wanted to change the template being used when something is being rendered as a separate, standalone document we'd edit settings.template.standalone . Setting Up Choices at Runtime (in user_setup ) \u00b6 In order to get more control over the printing of choices, or to change them based on the rng and ctxt , we will want to manipulate them within the user_setup functions or other functions it calls. First let's make sure that no error is thrown when we make a number of choices and don't mark any as correct. Add the following to CspQuestion : 44 45 46 47 # Due to our custom grading function we won't mark any choices as # correct, so we need to supress the check to ensure at least one # correct choice settings . grade . supress_correct_choice_error = True Then we can add a new user_setup function to CspQuestion : 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def user_setup ( self , rng , ctxt ): # When working with a question's choices or settings at runtime # (inside the `user_setup` or other funtions) you can't refer to # them directly, instead they're all properties of `self`. # See how we use `self.choice` here instead of just `choice`. self . choice . total_number = 2 * len ( vars ) + len ( exps ) choice_exps = dict () # Generate choices for each variable assignment for ( i , v ) in enumerate ( vars ): self . choice [ 2 * i ] . text = r 'Variable: $ %s $' % ( v . print_tex ()) self . choice [ 2 * i + 1 ] . text = r 'Variable: $ %s $' % ( Not ( v ) . print_tex ()) choice_exps |= { 2 * i : v , 2 * i + 1 : Not ( v )} exp_start = 2 * len ( vars ) # Generate choices for each boolean expression for ( i , e ) in enumerate ( exps ): self . choice [ exp_start + i ] . text = r ' Constraint: $ %s $' % ( e . print_tex ()) choice_exps [ exp_start + i ] = e # Return the expressions (for use in `calculate_grade`) return { 'choice_exps' : choice_exps } Note how we use self to refer to choice and settings (like in line 55). This is standard python-ism, the variables you have access to when defining a class are associated with the class as a whole. Inside functions you must refer to properties of a specific instance of that class via self , as functions operate on instances instead of classes. Otherwise things work as usual, as with line 61 setting self . choice [ n ] . text just as we set choice [ n ] . text in earlier examples. exam_gen is designed so that while a class represents the general template for an exam or question, each instance is the version of that exam or question that is generated for a specific student . So when some aspect of your question depends on information that is unique to each student, like the student's unique rng , that needs to be set inside a function by way of self . In general the library is designed to allow the separation of student specific information from properties of the question itself (the heavy use of templating is a big part of this) but that's not always feasible, hence being able to set properties directly. Defining a Custom Grading Function \u00b6 While we'll discuss the autograding feature in more detail in another section, this is a good place to show how custom grading works for multiple-choice-questions. TODO: link to section. Initialize some settings by adding the following: 76 77 78 79 80 # Specify that we'll be using a custom grading function settings . grade . style = \"custom\" # We will award between 0 and 2 points for this problem settings . grade . max_points = 2 Define a calculate_grade function as follows: 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def calculate_grade ( self , ctxt , is_selected ): # Extract assignments from student choices assignments = dict () for i in range ( 0 , 2 * len ( vars )): assignment = ctxt [ 'choice_exps' ][ i ] if is_selected [ i ] and isinstance ( assignment , Var ): assignments [ assignment . name ] = True elif is_selcted [ i ] and isinstance ( assignment , Not ): assignments [ assignment . exp . name ] = False # Extract Constraints that students chose constraints = list () for i in range ( 2 * len ( vars ), 2 * len ( vars ) + len ( exps )): if is_selected [ i ]: constraints . append ( ctxt [ 'choice_exps' ][ i ]) # Calculate and return score if len ( constraints ) <= 2 : return 0 # Not enough contraints chosen else : score = 0 for c in constraints : if c . eval ( assignments ) == True : score += 1 # Point per Satisfied Constraint else : return 0 # Unsatisfied Constraint = 0 Points return score This function is given the user context ( ctxt ) that user_setup returned earlier and an array ( is_selected ) that tells you whether the student selected the corresponding entry in ( choice ). is_selected is unshuffled before being given to you so each is_selected[n] corresponds directly to choice[n] . calculate_grade should return the number of points to be given to the student. No scaling of the result is done with respect to max_points so it's possible to give extra-credit this way. Complete Current csp_question/question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 from exam_gen import * from .exp import * # Problem Variables w = Var ( \"w\" ) x = Var ( \"x\" ) y = Var ( \"y\" ) z = Var ( \"z\" ) vars = [ w , x , y , z ] # Problem Constraints exps = [ Not ( w ), Or ( x , Not ( w )), And ( w , Not ( Or ( x , Not ( z ))), Or ( y , z )), Or ( And ( x , Not ( w ), y , Not ( z )), And ( Not ( x ), Not ( y ))), And ( Or ( x , w , Not ( y ), Not ( z )), Or ( Not ( w ), z , y ), Or ( Not ( x ), w , y )), Or ( Not ( w ), x , And ( z , Not ( w ))), Or ( y , Not ( x )) ] class CspQuestion ( LatexDoc , MultipleChoiceQuestion ): body . text = r ''' From the options below choose: \\begin {itemize} \\item An assignment for \\emph {every} variable \\item At least two constraints \\end {itemize} Such that all chosen constraints are satisfied. Extra credit points will be awarded for every constraint above 2 that is chosen, but no points will be awarded if even a single chosen constraint is not satisfied by the given assignment. ''' # No need to shuffle this problem settings . grade . shuffle = False # Alternate template so question will render on a single page. settings . template . embedded = \"small_text.jn2.tex\" # Due to our custom grading function we won't mark any choices as # correct, so we need to supress the check to ensure at least one # correct choice settings . grade . supress_correct_choice_error = True def user_setup ( self , rng , ctxt ): # When working with a question's choices or settings at runtime # (inside the `user_setup` or other funtions) you can't refer to # them directly, instead they're all properties of `self`. # See how we use `self.choice` here instead of just `choice`. self . choice . total_number = 2 * len ( vars ) + len ( exps ) choice_exps = dict () # Generate choices for each variable assignment for ( i , v ) in enumerate ( vars ): self . choice [ 2 * i ] . text = r 'Variable: $ %s $' % ( v . print_tex ()) self . choice [ 2 * i + 1 ] . text = r 'Variable: $ %s $' % ( Not ( v ) . print_tex ()) choice_exps |= { 2 * i : v , 2 * i + 1 : Not ( v )} exp_start = 2 * len ( vars ) # Generate choices for each boolean expression for ( i , e ) in enumerate ( exps ): self . choice [ exp_start + i ] . text = r ' Constraint: $ %s $' % ( e . print_tex ()) choice_exps [ exp_start + i ] = e # Return the expressions (for use in `calculate_grade`) return { 'choice_exps' : choice_exps } # Specify that we'll be using a custom grading function settings . grade . style = \"custom\" # We will award between 0 and 2 points for this problem settings . grade . max_points = 2 def calculate_grade ( self , ctxt , is_answer ): # Extract assignments from student choices assignments = dict () for i in range ( 0 , 2 * len ( vars )): assignment = ctxt [ 'choice_exps' ][ i ] if is_selected [ i ] and isinstance ( assignment , Var ): assignments [ assignment . name ] = True elif is_selected [ i ] and isinstance ( assignment , Not ): assignments [ assignment . exp . name ] = False # Extract Constraints that students chose constraints = list () for i in range ( 2 * len ( vars ), 2 * len ( vars ) + len ( exps )): if is_selected [ i ]: constraints . append ( ctxt [ 'choice_exps' ][ i ]) # Calculate and return score if len ( constraints ) <= 2 : return 0 # Not enough contraints chosen else : score = 0 for c in constraints : if c . eval ( assignments ) == True : score += 1 # Point per Satisfied Constraint else : return 0 # Unsatisfied Constraint = 0 Points return score Finishing Up \u00b6 Finally generate the new solution key with the following commands: $ ./exam.py cleanup $ ./exam.py build-solution:fake-class:erios TODO: image in assets/","title":"Custom Grading and Setup"},{"location":"tutorial/multiple_choice/custom_grading_and_setup.html#custom-setup-and-grading","text":"Here we'll be adding a needlessly complicated problem that shows off a number of advanced features and ways to interact with the exam_gen library. Students will have to choose an assignment of variables and some constraints to create a constraint satisfaction problem that meets various conditions. TODO: image in assets/","title":"Custom Setup and Grading"},{"location":"tutorial/multiple_choice/custom_grading_and_setup.html#initial-setup","text":"First we can create a new folder for our question and some initial files: $ mkdir csp_question $ touch csp_question/question.py $ touch csp_question/exp.py $ touch csp_question/small_text.jn2.tex exp.py will contain some code for manipulating and printing boolean formulas. Put the following in csp_question/exp.py : Complete Current csp_question/exp.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 import attr @attr . s class Var (): name = attr . ib () def eval ( self , vars ): return _eval_exp ( vars . get ( self . name , self ), vars ) def print_tex ( self ): return r '\\mathit{\\mathsf{ %s }}' % self . name def is_complex ( self ): return False @attr . s class Not (): exp = attr . ib () def __init__ ( self , e ): self . __attrs_init__ ( e ) def eval ( self , vars ): val = _eval_exp ( self . exp , vars ) if isinstance ( val , bool ): return not val elif isinstance ( val , Not ): return val . exp else : return val def print_tex ( self ): return r '\\neg{ %s }' % _print_wrap_tex ( self . exp ) def is_complex ( self ): return False @attr . s ( init = False ) class And (): exps = attr . ib () def __init__ ( self , * cmpnts ): self . __attrs_init__ ( cmpnts ) def eval ( self , vars ): result = list () for exp in self . exps : val = _eval_exp ( exp , vars ) if isinstance ( val , bool ): if val == False : return False elif isinstance ( val , And ): result += val . exps else : result . append ( val ) return result if len ( self . exps ) != 0 else True def is_complex ( self ): return len ( self . exps ) > 1 def print_tex ( self ): if len ( self . exps ) == 0 : return _print_tex ( True ) elif len ( self . exps ) == 1 : return _print_tex ( self . exps [ 0 ]) else : return r ' \\wedge ' . join ( map ( _print_wrap_tex , self . exps )) @attr . s ( init = False ) class Or (): exps = attr . ib () def __init__ ( self , * cmpnts ): self . __attrs_init__ ( cmpnts ) def eval ( self , vars ): result = list () for exp in self . exps : val = _eval_exp ( exp , vars ) if isinstance ( val , bool ): if val == True : return True elif isinstance ( val , Or ): result += val . exps else : result . append ( val ) return result if len ( self . exps ) != 0 else False def is_complex ( self ): return len ( self . exps ) > 1 def print_tex ( self ): if len ( self . exps ) == 0 : return _print_tex ( False ) elif len ( self . exps ) == 1 : return _print_tex ( self . exps [ 0 ]) else : return r ' \\vee ' . join ( map ( _print_wrap_tex , self . exps )) def _eval_exp ( exp , vars ): if isinstance ( exp , bool ): return exp else : exp . eval ( vars ) def _print_tex ( exp ): if isinstance ( exp , bool ): return r '\\mathsf{\\mathit{ %s }}' % ( \"True\" if exp else \"False\" ) else : return exp . print_tex () def _print_wrap_tex ( exp ): if isinstance ( exp , bool ): return _print_tex ( exp ) elif exp . is_complex (): return r '\\left( %s \\right)' % _print_tex ( exp ) else : return _print_tex ( exp ) Next we can initialize csp_question/question.py with: Complete Current csp_question/question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 from exam_gen import * from .exp import * # Problem Variables w = Var ( \"w\" ) x = Var ( \"x\" ) y = Var ( \"y\" ) z = Var ( \"z\" ) vars = [ w , x , y , z ] # Problem Constraints exps = [ Not ( w ), Or ( x , Not ( w )), And ( w , Not ( Or ( x , Not ( z ))), Or ( y , z )), Or ( And ( x , Not ( w ), y , Not ( z )), And ( Not ( x ), Not ( y ))), And ( Or ( x , w , Not ( y ), Not ( z )), Or ( Not ( w ), z , y ), Or ( Not ( x ), w , y )), Or ( Not ( w ), x , And ( z , Not ( w ))), Or ( y , Not ( x )) ] class CspQuestion ( LatexDoc , MultipleChoiceQuestion ): body . text = r ''' From the options below choose: \\begin {itemize} \\item An assignment for \\emph {every} variable \\item At least two constraints \\end {itemize} Such that all chosen constraints are satisfied. Extra credit points will be awarded for every constraint above 2 that is chosen, but no points will be awarded if even a single chosen constraint is not satisfied by the given assignment. ''' # No need to shuffle this problem settings . grade . shuffle = False Then we can edit exam.py to import and use the new question. To add the new import: 8 from csp_question.question import * To add our new question to the question list: 20 21 22 23 24 25 26 questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion , 'graph-question' : GraphQuestion , 'matrix-question' : MatrixQuestion , 'csp-question' : CspQuestion , } Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/usr/bin/env -S pipenv run python3 from exam_gen import * from addition_question import * from poly_question.question import * from graph_question.question import * from matrix_question.question import * from csp_question.question import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), } questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion , 'graph-question' : GraphQuestion , 'matrix-question' : MatrixQuestion , 'csp-question' : CspQuestion , } intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ())","title":"Initial Setup"},{"location":"tutorial/multiple_choice/custom_grading_and_setup.html#using-custom-question-templates","text":"This question has a lot of options and spills over to multiple pages. To fix this we'll overload the basic question template with one that has smaller text. First we can fill csp_question/small_text.jn2.tex with the following: Complete Current csp_question/small_text.jn2.tex 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { % if nesting_depth == 1 %} { \\large { Problem: {{ number }} } } \\\\ { % elif nesting_depth == 2 %} { \\large { Sub-problem: {{ number }} } } \\\\ { % elif nesting_depth == 3 %} { \\large { Sub-sub-problem: {{ number }} } } \\\\ { % else %} { \\large { Part: {{ number }} } } \\\\ { % endif %} { \\small {{ body.text }} \\\\ { % if format == 'solution' %} \\solution { {{ solution.text }} } \\\\ { % endif %} \\begin { enumerate } [label=( \\alph* )] { % for choice in choices %} \\item {{ choice.text }} { %- if format == 'solution' %} \\\\ \\solution { {{ \"correct\" if choice.is _ correct else \"incorrect\" }} { %- if choice.solution -%} {{ choice.solution }} {%- endif -%} } { %- endif -%} { %- endfor %} \\end { enumerate } } And then override the default template by adding the following to csp_question/question.py : 41 42 # Alternate template so question will render on a single page. settings . template . embedded = \"small_text.jn2.tex\" The settings.template.embedded option controls which template is used when a question or exam is being rendered within another document. If we wanted to change the template being used when something is being rendered as a separate, standalone document we'd edit settings.template.standalone .","title":"Using Custom Question Templates"},{"location":"tutorial/multiple_choice/custom_grading_and_setup.html#setting-up-choices-at-runtime-in-user_setup","text":"In order to get more control over the printing of choices, or to change them based on the rng and ctxt , we will want to manipulate them within the user_setup functions or other functions it calls. First let's make sure that no error is thrown when we make a number of choices and don't mark any as correct. Add the following to CspQuestion : 44 45 46 47 # Due to our custom grading function we won't mark any choices as # correct, so we need to supress the check to ensure at least one # correct choice settings . grade . supress_correct_choice_error = True Then we can add a new user_setup function to CspQuestion : 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def user_setup ( self , rng , ctxt ): # When working with a question's choices or settings at runtime # (inside the `user_setup` or other funtions) you can't refer to # them directly, instead they're all properties of `self`. # See how we use `self.choice` here instead of just `choice`. self . choice . total_number = 2 * len ( vars ) + len ( exps ) choice_exps = dict () # Generate choices for each variable assignment for ( i , v ) in enumerate ( vars ): self . choice [ 2 * i ] . text = r 'Variable: $ %s $' % ( v . print_tex ()) self . choice [ 2 * i + 1 ] . text = r 'Variable: $ %s $' % ( Not ( v ) . print_tex ()) choice_exps |= { 2 * i : v , 2 * i + 1 : Not ( v )} exp_start = 2 * len ( vars ) # Generate choices for each boolean expression for ( i , e ) in enumerate ( exps ): self . choice [ exp_start + i ] . text = r ' Constraint: $ %s $' % ( e . print_tex ()) choice_exps [ exp_start + i ] = e # Return the expressions (for use in `calculate_grade`) return { 'choice_exps' : choice_exps } Note how we use self to refer to choice and settings (like in line 55). This is standard python-ism, the variables you have access to when defining a class are associated with the class as a whole. Inside functions you must refer to properties of a specific instance of that class via self , as functions operate on instances instead of classes. Otherwise things work as usual, as with line 61 setting self . choice [ n ] . text just as we set choice [ n ] . text in earlier examples. exam_gen is designed so that while a class represents the general template for an exam or question, each instance is the version of that exam or question that is generated for a specific student . So when some aspect of your question depends on information that is unique to each student, like the student's unique rng , that needs to be set inside a function by way of self . In general the library is designed to allow the separation of student specific information from properties of the question itself (the heavy use of templating is a big part of this) but that's not always feasible, hence being able to set properties directly.","title":"Setting Up Choices at Runtime (in user_setup)"},{"location":"tutorial/multiple_choice/custom_grading_and_setup.html#defining-a-custom-grading-function","text":"While we'll discuss the autograding feature in more detail in another section, this is a good place to show how custom grading works for multiple-choice-questions. TODO: link to section. Initialize some settings by adding the following: 76 77 78 79 80 # Specify that we'll be using a custom grading function settings . grade . style = \"custom\" # We will award between 0 and 2 points for this problem settings . grade . max_points = 2 Define a calculate_grade function as follows: 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def calculate_grade ( self , ctxt , is_selected ): # Extract assignments from student choices assignments = dict () for i in range ( 0 , 2 * len ( vars )): assignment = ctxt [ 'choice_exps' ][ i ] if is_selected [ i ] and isinstance ( assignment , Var ): assignments [ assignment . name ] = True elif is_selcted [ i ] and isinstance ( assignment , Not ): assignments [ assignment . exp . name ] = False # Extract Constraints that students chose constraints = list () for i in range ( 2 * len ( vars ), 2 * len ( vars ) + len ( exps )): if is_selected [ i ]: constraints . append ( ctxt [ 'choice_exps' ][ i ]) # Calculate and return score if len ( constraints ) <= 2 : return 0 # Not enough contraints chosen else : score = 0 for c in constraints : if c . eval ( assignments ) == True : score += 1 # Point per Satisfied Constraint else : return 0 # Unsatisfied Constraint = 0 Points return score This function is given the user context ( ctxt ) that user_setup returned earlier and an array ( is_selected ) that tells you whether the student selected the corresponding entry in ( choice ). is_selected is unshuffled before being given to you so each is_selected[n] corresponds directly to choice[n] . calculate_grade should return the number of points to be given to the student. No scaling of the result is done with respect to max_points so it's possible to give extra-credit this way. Complete Current csp_question/question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 from exam_gen import * from .exp import * # Problem Variables w = Var ( \"w\" ) x = Var ( \"x\" ) y = Var ( \"y\" ) z = Var ( \"z\" ) vars = [ w , x , y , z ] # Problem Constraints exps = [ Not ( w ), Or ( x , Not ( w )), And ( w , Not ( Or ( x , Not ( z ))), Or ( y , z )), Or ( And ( x , Not ( w ), y , Not ( z )), And ( Not ( x ), Not ( y ))), And ( Or ( x , w , Not ( y ), Not ( z )), Or ( Not ( w ), z , y ), Or ( Not ( x ), w , y )), Or ( Not ( w ), x , And ( z , Not ( w ))), Or ( y , Not ( x )) ] class CspQuestion ( LatexDoc , MultipleChoiceQuestion ): body . text = r ''' From the options below choose: \\begin {itemize} \\item An assignment for \\emph {every} variable \\item At least two constraints \\end {itemize} Such that all chosen constraints are satisfied. Extra credit points will be awarded for every constraint above 2 that is chosen, but no points will be awarded if even a single chosen constraint is not satisfied by the given assignment. ''' # No need to shuffle this problem settings . grade . shuffle = False # Alternate template so question will render on a single page. settings . template . embedded = \"small_text.jn2.tex\" # Due to our custom grading function we won't mark any choices as # correct, so we need to supress the check to ensure at least one # correct choice settings . grade . supress_correct_choice_error = True def user_setup ( self , rng , ctxt ): # When working with a question's choices or settings at runtime # (inside the `user_setup` or other funtions) you can't refer to # them directly, instead they're all properties of `self`. # See how we use `self.choice` here instead of just `choice`. self . choice . total_number = 2 * len ( vars ) + len ( exps ) choice_exps = dict () # Generate choices for each variable assignment for ( i , v ) in enumerate ( vars ): self . choice [ 2 * i ] . text = r 'Variable: $ %s $' % ( v . print_tex ()) self . choice [ 2 * i + 1 ] . text = r 'Variable: $ %s $' % ( Not ( v ) . print_tex ()) choice_exps |= { 2 * i : v , 2 * i + 1 : Not ( v )} exp_start = 2 * len ( vars ) # Generate choices for each boolean expression for ( i , e ) in enumerate ( exps ): self . choice [ exp_start + i ] . text = r ' Constraint: $ %s $' % ( e . print_tex ()) choice_exps [ exp_start + i ] = e # Return the expressions (for use in `calculate_grade`) return { 'choice_exps' : choice_exps } # Specify that we'll be using a custom grading function settings . grade . style = \"custom\" # We will award between 0 and 2 points for this problem settings . grade . max_points = 2 def calculate_grade ( self , ctxt , is_answer ): # Extract assignments from student choices assignments = dict () for i in range ( 0 , 2 * len ( vars )): assignment = ctxt [ 'choice_exps' ][ i ] if is_selected [ i ] and isinstance ( assignment , Var ): assignments [ assignment . name ] = True elif is_selected [ i ] and isinstance ( assignment , Not ): assignments [ assignment . exp . name ] = False # Extract Constraints that students chose constraints = list () for i in range ( 2 * len ( vars ), 2 * len ( vars ) + len ( exps )): if is_selected [ i ]: constraints . append ( ctxt [ 'choice_exps' ][ i ]) # Calculate and return score if len ( constraints ) <= 2 : return 0 # Not enough contraints chosen else : score = 0 for c in constraints : if c . eval ( assignments ) == True : score += 1 # Point per Satisfied Constraint else : return 0 # Unsatisfied Constraint = 0 Points return score","title":"Defining a Custom Grading Function"},{"location":"tutorial/multiple_choice/custom_grading_and_setup.html#finishing-up","text":"Finally generate the new solution key with the following commands: $ ./exam.py cleanup $ ./exam.py build-solution:fake-class:erios TODO: image in assets/","title":"Finishing Up"},{"location":"tutorial/multiple_choice/simple_question.html","text":"Simple Multiple Choice Example \u00b6 For our first example we'll start with a multiple choice question about the properties of a graph. TODO: image in assets/ Initial Setup \u00b6 First we can create a new file and folder for our question: $ mkdir graph_question $ touch graph_question/question.py Then, as before, add a basic stub we can expand later. Start by writing the following into graph_question/question.py : Complete Current graph_question/question.py 1 2 3 4 from exam_gen import * class GraphQuestion ( LatexDoc , MultipleChoiceQuestion ): pass Note how on line 3 we inherit from MultipleChoiceQuestion rather than just Question , it's this change which gives us access to most of the new features we're going to use. Now we can change exam.py to include our new question by importing the correct file and updating our question list, as follows: To add the new import: 6 from graph_question.question import * To add our new question to the question list: 18 19 20 21 22 questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion , 'graph-question' : GraphQuestion , } Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #!/usr/bin/env -S pipenv run python3 from exam_gen import * from addition_question import * from poly_question.question import * from graph_question.question import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), } questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion , 'graph-question' : GraphQuestion , } intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) Finally run a quick test: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios Note that, unlike usual, this should produce an error: Result of ./exam.py build-exam:fake-class:erios Note that your exact output may differ slightly. $ ./exam.py build-exam:fake-class:erios . build-exam:fake-class:erios TaskError - taskid:build-exam:fake-class:erios PythonAction Error Traceback (most recent call last): File \"~/.local/share/virtualenvs/example_exam-B_yRD-c_/lib/python3.9/site-packages/doit/action.py\", line 437, in execute returned_value = self.py_callable(*self.args, **kwargs) File \"~/Workspace/exam_gen/exam_gen/build/loader/build_tasks.py\", line 169, in build_exam setup_exam(exam_obj, build_info) File \"~/Workspace/exam_gen/exam_gen/build/loader/build_tasks.py\", line 57, in setup_exam setup_log['children'] = exam_obj.on_children( File \"~/Workspace/exam_gen/exam_gen/property/document.py\", line 99, in on_children log[name] = (fun(question), question.on_children(fun)) File \"~/Workspace/exam_gen/exam_gen/build/loader/build_tasks.py\", line 58, in <lambda> lambda n: n.setup_build(build_info)) File \"~/Workspace/exam_gen/exam_gen/question/multiple_choice.py\", line 198, in setup_build self.validate_settings() File \"~/Workspace/exam_gen/exam_gen/question/multiple_choice.py\", line 388, in validate_settings raise RuntimeError(\"Question has no correct answers.\") RuntimeError: Question has no correct answers. This is because the MultipleChoiceQuestion class adds a number of checks against common mistakes, in this case a question that doesn't have any correct answers. Options for Multiple Choice Questions \u00b6 We'll start by looking at some of the core settings available to the MultipleChoiceQuestion class. Keep in mind that these are only a subset of what's available with more visible in <>. Replace <> with link to appropriate user guide page Add the following to the definition for GraphQuestion : 5 6 7 8 9 10 # Ensure we have the latex libraries we need settings . latex . header_includes = r \"\"\" \\usepackage {tikz} \\usetikzlibrary{shapes, decorations, patterns, arrows, chains, fit, calc, positioning} \"\"\" This option, settings.latex.header_includes , is actually from LatexDoc and allows you to specify packages that ought to be imported and other commands to place in the header area (before \\begin { document } ) of the final latex document. Note that the final .tex file will have all the header includes from all sub-documents without filtering out duplicates. Specify the maximum number of points that this question is assigned in the exam by adding: 12 13 # Set the number of points for this problem settings . grade . max_points = 2 TODO: link to user_guide with further detail Specify the grading style for this question by adding: 15 16 # Set the style of grade appropriately settings . grade . style = \"percent_correct\" The \"percent_correct\" option will, when we introduce auto-grading in more detail, grade students on how many options they correctly categorized. So they get credit for options they correctly marked as true as ones they correctly marked as false. TODO: link to user_guide with further detail Next we can tell the library to shuffle the available choices by adding: 18 19 # Chose which options to shuffle settings . grade . shuffle = True This will just randomize the positions of all the options presented to the student. Setting this variable to False will leave their order unchanged. TODO: link to user_guide with further detail Question Body and Context \u00b6 The body of the problem, to be added to GraphQuestion : 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # Set the problem body . text = r ''' We define a mask of a bipartite graph as a set of vertices in one bi-partition whose edges connect to \\emph {all} the vertices in the other bi-partition. \\begin {center} \\begin {tikzpicture} [thick, every node/.style={draw, circle, fill, inner sep=1.5pt}, shorten >= 3pt,shorten <= 3pt ] \\begin {scope} [start chain=going below,node distance=7mm] \\foreach \\i in {1,2,...,6} \\node[on chain] (l\\i) [label=left: $l_\\i$] {} ; \\end {scope} \\begin {scope} [xshift=4cm,yshift=-0.5cm,start chain=going below,node distance=7mm] \\foreach \\i in {1,2,...,5} \\node[on chain] (r\\i) [label=right: $r_\\i$] {} ; \\end {scope} { % f or (ln, rn) in edges %} \\draw (l{{ln}}) -- (r{{rn}}); { % e ndfor %} \\end {tikzpicture} \\end {center} Which of the following options are valid masks of the above graph? Choose all correct answers. ''' This expects a list of left-right pairs names edges as part of the context. Note how we're using the tikz Latex library here, hence our need to add it to the header_includes from earlier. Next we add a quick helper function to take a premade graph and some possible choices for the question and permute the various vertices involved. 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def gen_bigraph ( self , rng ): # We're just going to shuffle the vertices on a fixed bi-graph l_verts , r_verts = ( 6 , 5 ) edges = [( 1 , 2 ), ( 1 , 4 ), ( 2 , 1 ), ( 2 , 3 ), ( 3 , 5 ), ( 4 , 2 ), ( 4 , 4 ), ( 5 , 3 ), ( 6 , 3 ), ( 6 , 4 ), ( 6 , 5 )] masks = [( 'l' , 6 , 2 , 1 ),( 'l' , 2 , 4 , 6 ),( 'l' , 1 , 4 , 3 ),( 'r' , 2 , 3 , 5 ),( 'r' , 4 , 3 , 5 )] non_masks = [( 'l' , 5 , 4 , 2 ), ( 'l' , 5 , 6 , 2 ),( 'r' , 1 , 4 , 5 )] permute_l = { k + 1 : v for ( k , v ) in enumerate ( rng . sample ( range ( 1 , l_verts + 1 ), l_verts ))} permute_r = { k + 1 : v for ( k , v ) in enumerate ( rng . sample ( range ( 1 , r_verts + 1 ), r_verts ))} def permute_mask ( side , a , b , c ): permute = permute_l if side == 'l' else permute_r verts = sorted ([ permute [ v ] for v in [ a , b , c ]]) return ( side , verts [ 0 ], verts [ 1 ], verts [ 2 ]) return { 'edges' : [( permute_l [ l ], permute_r [ r ]) for ( l , r ) in edges ] , 'masks' : [ permute_mask ( * m ) for m in masks ] , 'non_masks' : [ permute_mask ( * m ) for m in non_masks ] } The three return value are: - 'edges' : The list of pairs as expected by the body template - 'masks' : Possible correct answers to the question - 'non-masks' : Possible incorrect answers to the question We also need to add a user_setup function that will get the appropriate results from gen_bigraph and format them into a nicer context. 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def user_setup ( self , rng , ctxt ): graph_data = self . gen_bigraph ( rng ) masks = rng . sample ( graph_data [ 'masks' ], 3 ) non_masks = rng . sample ( graph_data [ 'non_masks' ], 2 ) return { 'edges' : graph_data [ 'edges' ], # Concat correct and incorrect answers, so correct ones are in # indices [0,1,2] and incorrect ones are in [3,4] 'potential_masks' : masks + non_masks , } Specifying Choices \u00b6 The key to manipulating choices in a MultipleChoieQuestion is the choice variable. ( self . choice if you're in user_setup or another function.) Add the following to GraphQuestion to specify that there are 5 total options for students to choose from: 90 choice . total_number = 5 The choice.total_number variables lets you which you specify how many different choices are provided for the question. In general one ought set this first, before trying to manipulate any choices directly. Next we can set the actual text for all the choice by adding: 92 93 94 95 96 97 choice . text = r ''' ${ % f or i in [1,2,3] -%} {{potential_masks[index][0]}}_{{potential_masks[index][i]}} { %- i f not loop.last -%}, { % e ndif -%} { %- e ndfor %}$ ''' When used like this choice works like body or solution , where you can assign templates as either a raw string (via choice.text ) or as as pointer to a file (via choice.file ). This particular version, where we're assigning a template to all the choices at once adds a special variable called index . The index variable will have the value 0 when called for choice 0 , 1 for choice 1 , and so on.. Here we index into the list potential_masks , that we created in user_setup , to get each separate option for the problem. Finally we need to specify which options are correct by adding: 99 100 for i in [ 0 , 1 , 2 ]: choice [ i ] . is_correct = True The is_correct property of a choice is how you an specify whether the system should see it as true or false. Also note how we can index into the choices as if they were a list, as with choice [ i ] here, and work with each of them individually. This also works with other parameters like choice [ i ] . text but the next section of the tutorial will examine that in more depth. Complete Current graph_question/question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 from exam_gen import * class GraphQuestion ( LatexDoc , MultipleChoiceQuestion ): # Ensure we have the latex libraries we need settings . latex . header_includes = r \"\"\" \\usepackage {tikz} \\usetikzlibrary{shapes, decorations, patterns, arrows, chains, fit, calc, positioning} \"\"\" # Set the number of points for this problem settings . grade . max_points = 2 # Set the style of grade appropriately settings . grade . style = \"percent_correct\" # Chose which options to shuffle settings . grade . shuffle = True # Set the problem body . text = r ''' We define a mask of a bipartite graph as a set of vertices in one bi-partition whose edges connect to \\emph {all} the vertices in the other bi-partition. \\begin {center} \\begin {tikzpicture} [thick, every node/.style={draw, circle, fill, inner sep=1.5pt}, shorten >= 3pt,shorten <= 3pt ] \\begin {scope} [start chain=going below,node distance=7mm] \\foreach \\i in {1,2,...,6} \\node[on chain] (l\\i) [label=left: $l_\\i$] {} ; \\end {scope} \\begin {scope} [xshift=4cm,yshift=-0.5cm,start chain=going below,node distance=7mm] \\foreach \\i in {1,2,...,5} \\node[on chain] (r\\i) [label=right: $r_\\i$] {} ; \\end {scope} { % f or (ln, rn) in edges %} \\draw (l{{ln}}) -- (r{{rn}}); { % e ndfor %} \\end {tikzpicture} \\end {center} Which of the following options are valid masks of the above graph? Choose all correct answers. ''' def gen_bigraph ( self , rng ): # We're just going to shuffle the vertices on a fixed bi-graph l_verts , r_verts = ( 6 , 5 ) edges = [( 1 , 2 ), ( 1 , 4 ), ( 2 , 1 ), ( 2 , 3 ), ( 3 , 5 ), ( 4 , 2 ), ( 4 , 4 ), ( 5 , 3 ), ( 6 , 3 ), ( 6 , 4 ), ( 6 , 5 )] masks = [( 'l' , 6 , 2 , 1 ),( 'l' , 2 , 4 , 6 ),( 'l' , 1 , 4 , 3 ),( 'r' , 2 , 3 , 5 ),( 'r' , 4 , 3 , 5 )] non_masks = [( 'l' , 5 , 4 , 2 ), ( 'l' , 5 , 6 , 2 ),( 'r' , 1 , 4 , 5 )] permute_l = { k + 1 : v for ( k , v ) in enumerate ( rng . sample ( range ( 1 , l_verts + 1 ), l_verts ))} permute_r = { k + 1 : v for ( k , v ) in enumerate ( rng . sample ( range ( 1 , r_verts + 1 ), r_verts ))} def permute_mask ( side , a , b , c ): permute = permute_l if side == 'l' else permute_r verts = sorted ([ permute [ v ] for v in [ a , b , c ]]) return ( side , verts [ 0 ], verts [ 1 ], verts [ 2 ]) return { 'edges' : [( permute_l [ l ], permute_r [ r ]) for ( l , r ) in edges ] , 'masks' : [ permute_mask ( * m ) for m in masks ] , 'non_masks' : [ permute_mask ( * m ) for m in non_masks ] } def user_setup ( self , rng , ctxt ): graph_data = self . gen_bigraph ( rng ) masks = rng . sample ( graph_data [ 'masks' ], 3 ) non_masks = rng . sample ( graph_data [ 'non_masks' ], 2 ) return { 'edges' : graph_data [ 'edges' ], # Concat correct and incorrect answers, so correct ones are in # indices [0,1,2] and incorrect ones are in [3,4] 'potential_masks' : masks + non_masks , } choice . total_number = 5 choice . text = r ''' ${ % f or i in [1,2,3] -%} {{potential_masks[index][0]}}_{{potential_masks[index][i]}} { %- i f not loop.last -%}, { % e ndif -%} { %- e ndfor %}$ ''' for i in [ 0 , 1 , 2 ]: choice [ i ] . is_correct = True Final Testing \u00b6 We can then generate the new solution key with the following commands: We're using acelderon instead of erios this time, in order to make the shuffling of the choices more evident. $ ./exam.py cleanup $ ./exam.py build-solution:fake-class:acalderon TODO: image in assets/","title":"Simple Questions"},{"location":"tutorial/multiple_choice/simple_question.html#simple-multiple-choice-example","text":"For our first example we'll start with a multiple choice question about the properties of a graph. TODO: image in assets/","title":"Simple Multiple Choice Example"},{"location":"tutorial/multiple_choice/simple_question.html#initial-setup","text":"First we can create a new file and folder for our question: $ mkdir graph_question $ touch graph_question/question.py Then, as before, add a basic stub we can expand later. Start by writing the following into graph_question/question.py : Complete Current graph_question/question.py 1 2 3 4 from exam_gen import * class GraphQuestion ( LatexDoc , MultipleChoiceQuestion ): pass Note how on line 3 we inherit from MultipleChoiceQuestion rather than just Question , it's this change which gives us access to most of the new features we're going to use. Now we can change exam.py to include our new question by importing the correct file and updating our question list, as follows: To add the new import: 6 from graph_question.question import * To add our new question to the question list: 18 19 20 21 22 questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion , 'graph-question' : GraphQuestion , } Complete Current exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #!/usr/bin/env -S pipenv run python3 from exam_gen import * from addition_question import * from poly_question.question import * from graph_question.question import * class NewExam ( LatexDoc , Exam ): classes = { 'fake-class' : Classroom . with_options ( roster = BCoursesCSVRoster . with_options ( file_name = \"class-1.csv\" ) ), } questions = { 'addition-question' : SumQuestion , 'poly-question' : PolyQuestion , 'graph-question' : GraphQuestion , } intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) Finally run a quick test: $ ./exam.py cleanup $ ./exam.py build-exam:fake-class:erios Note that, unlike usual, this should produce an error: Result of ./exam.py build-exam:fake-class:erios Note that your exact output may differ slightly. $ ./exam.py build-exam:fake-class:erios . build-exam:fake-class:erios TaskError - taskid:build-exam:fake-class:erios PythonAction Error Traceback (most recent call last): File \"~/.local/share/virtualenvs/example_exam-B_yRD-c_/lib/python3.9/site-packages/doit/action.py\", line 437, in execute returned_value = self.py_callable(*self.args, **kwargs) File \"~/Workspace/exam_gen/exam_gen/build/loader/build_tasks.py\", line 169, in build_exam setup_exam(exam_obj, build_info) File \"~/Workspace/exam_gen/exam_gen/build/loader/build_tasks.py\", line 57, in setup_exam setup_log['children'] = exam_obj.on_children( File \"~/Workspace/exam_gen/exam_gen/property/document.py\", line 99, in on_children log[name] = (fun(question), question.on_children(fun)) File \"~/Workspace/exam_gen/exam_gen/build/loader/build_tasks.py\", line 58, in <lambda> lambda n: n.setup_build(build_info)) File \"~/Workspace/exam_gen/exam_gen/question/multiple_choice.py\", line 198, in setup_build self.validate_settings() File \"~/Workspace/exam_gen/exam_gen/question/multiple_choice.py\", line 388, in validate_settings raise RuntimeError(\"Question has no correct answers.\") RuntimeError: Question has no correct answers. This is because the MultipleChoiceQuestion class adds a number of checks against common mistakes, in this case a question that doesn't have any correct answers.","title":"Initial Setup"},{"location":"tutorial/multiple_choice/simple_question.html#options-for-multiple-choice-questions","text":"We'll start by looking at some of the core settings available to the MultipleChoiceQuestion class. Keep in mind that these are only a subset of what's available with more visible in <>. Replace <> with link to appropriate user guide page Add the following to the definition for GraphQuestion : 5 6 7 8 9 10 # Ensure we have the latex libraries we need settings . latex . header_includes = r \"\"\" \\usepackage {tikz} \\usetikzlibrary{shapes, decorations, patterns, arrows, chains, fit, calc, positioning} \"\"\" This option, settings.latex.header_includes , is actually from LatexDoc and allows you to specify packages that ought to be imported and other commands to place in the header area (before \\begin { document } ) of the final latex document. Note that the final .tex file will have all the header includes from all sub-documents without filtering out duplicates. Specify the maximum number of points that this question is assigned in the exam by adding: 12 13 # Set the number of points for this problem settings . grade . max_points = 2 TODO: link to user_guide with further detail Specify the grading style for this question by adding: 15 16 # Set the style of grade appropriately settings . grade . style = \"percent_correct\" The \"percent_correct\" option will, when we introduce auto-grading in more detail, grade students on how many options they correctly categorized. So they get credit for options they correctly marked as true as ones they correctly marked as false. TODO: link to user_guide with further detail Next we can tell the library to shuffle the available choices by adding: 18 19 # Chose which options to shuffle settings . grade . shuffle = True This will just randomize the positions of all the options presented to the student. Setting this variable to False will leave their order unchanged. TODO: link to user_guide with further detail","title":"Options for Multiple Choice Questions"},{"location":"tutorial/multiple_choice/simple_question.html#question-body-and-context","text":"The body of the problem, to be added to GraphQuestion : 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 # Set the problem body . text = r ''' We define a mask of a bipartite graph as a set of vertices in one bi-partition whose edges connect to \\emph {all} the vertices in the other bi-partition. \\begin {center} \\begin {tikzpicture} [thick, every node/.style={draw, circle, fill, inner sep=1.5pt}, shorten >= 3pt,shorten <= 3pt ] \\begin {scope} [start chain=going below,node distance=7mm] \\foreach \\i in {1,2,...,6} \\node[on chain] (l\\i) [label=left: $l_\\i$] {} ; \\end {scope} \\begin {scope} [xshift=4cm,yshift=-0.5cm,start chain=going below,node distance=7mm] \\foreach \\i in {1,2,...,5} \\node[on chain] (r\\i) [label=right: $r_\\i$] {} ; \\end {scope} { % f or (ln, rn) in edges %} \\draw (l{{ln}}) -- (r{{rn}}); { % e ndfor %} \\end {tikzpicture} \\end {center} Which of the following options are valid masks of the above graph? Choose all correct answers. ''' This expects a list of left-right pairs names edges as part of the context. Note how we're using the tikz Latex library here, hence our need to add it to the header_includes from earlier. Next we add a quick helper function to take a premade graph and some possible choices for the question and permute the various vertices involved. 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 def gen_bigraph ( self , rng ): # We're just going to shuffle the vertices on a fixed bi-graph l_verts , r_verts = ( 6 , 5 ) edges = [( 1 , 2 ), ( 1 , 4 ), ( 2 , 1 ), ( 2 , 3 ), ( 3 , 5 ), ( 4 , 2 ), ( 4 , 4 ), ( 5 , 3 ), ( 6 , 3 ), ( 6 , 4 ), ( 6 , 5 )] masks = [( 'l' , 6 , 2 , 1 ),( 'l' , 2 , 4 , 6 ),( 'l' , 1 , 4 , 3 ),( 'r' , 2 , 3 , 5 ),( 'r' , 4 , 3 , 5 )] non_masks = [( 'l' , 5 , 4 , 2 ), ( 'l' , 5 , 6 , 2 ),( 'r' , 1 , 4 , 5 )] permute_l = { k + 1 : v for ( k , v ) in enumerate ( rng . sample ( range ( 1 , l_verts + 1 ), l_verts ))} permute_r = { k + 1 : v for ( k , v ) in enumerate ( rng . sample ( range ( 1 , r_verts + 1 ), r_verts ))} def permute_mask ( side , a , b , c ): permute = permute_l if side == 'l' else permute_r verts = sorted ([ permute [ v ] for v in [ a , b , c ]]) return ( side , verts [ 0 ], verts [ 1 ], verts [ 2 ]) return { 'edges' : [( permute_l [ l ], permute_r [ r ]) for ( l , r ) in edges ] , 'masks' : [ permute_mask ( * m ) for m in masks ] , 'non_masks' : [ permute_mask ( * m ) for m in non_masks ] } The three return value are: - 'edges' : The list of pairs as expected by the body template - 'masks' : Possible correct answers to the question - 'non-masks' : Possible incorrect answers to the question We also need to add a user_setup function that will get the appropriate results from gen_bigraph and format them into a nicer context. 75 76 77 78 79 80 81 82 83 84 85 86 87 88 def user_setup ( self , rng , ctxt ): graph_data = self . gen_bigraph ( rng ) masks = rng . sample ( graph_data [ 'masks' ], 3 ) non_masks = rng . sample ( graph_data [ 'non_masks' ], 2 ) return { 'edges' : graph_data [ 'edges' ], # Concat correct and incorrect answers, so correct ones are in # indices [0,1,2] and incorrect ones are in [3,4] 'potential_masks' : masks + non_masks , }","title":"Question Body and Context"},{"location":"tutorial/multiple_choice/simple_question.html#specifying-choices","text":"The key to manipulating choices in a MultipleChoieQuestion is the choice variable. ( self . choice if you're in user_setup or another function.) Add the following to GraphQuestion to specify that there are 5 total options for students to choose from: 90 choice . total_number = 5 The choice.total_number variables lets you which you specify how many different choices are provided for the question. In general one ought set this first, before trying to manipulate any choices directly. Next we can set the actual text for all the choice by adding: 92 93 94 95 96 97 choice . text = r ''' ${ % f or i in [1,2,3] -%} {{potential_masks[index][0]}}_{{potential_masks[index][i]}} { %- i f not loop.last -%}, { % e ndif -%} { %- e ndfor %}$ ''' When used like this choice works like body or solution , where you can assign templates as either a raw string (via choice.text ) or as as pointer to a file (via choice.file ). This particular version, where we're assigning a template to all the choices at once adds a special variable called index . The index variable will have the value 0 when called for choice 0 , 1 for choice 1 , and so on.. Here we index into the list potential_masks , that we created in user_setup , to get each separate option for the problem. Finally we need to specify which options are correct by adding: 99 100 for i in [ 0 , 1 , 2 ]: choice [ i ] . is_correct = True The is_correct property of a choice is how you an specify whether the system should see it as true or false. Also note how we can index into the choices as if they were a list, as with choice [ i ] here, and work with each of them individually. This also works with other parameters like choice [ i ] . text but the next section of the tutorial will examine that in more depth. Complete Current graph_question/question.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 from exam_gen import * class GraphQuestion ( LatexDoc , MultipleChoiceQuestion ): # Ensure we have the latex libraries we need settings . latex . header_includes = r \"\"\" \\usepackage {tikz} \\usetikzlibrary{shapes, decorations, patterns, arrows, chains, fit, calc, positioning} \"\"\" # Set the number of points for this problem settings . grade . max_points = 2 # Set the style of grade appropriately settings . grade . style = \"percent_correct\" # Chose which options to shuffle settings . grade . shuffle = True # Set the problem body . text = r ''' We define a mask of a bipartite graph as a set of vertices in one bi-partition whose edges connect to \\emph {all} the vertices in the other bi-partition. \\begin {center} \\begin {tikzpicture} [thick, every node/.style={draw, circle, fill, inner sep=1.5pt}, shorten >= 3pt,shorten <= 3pt ] \\begin {scope} [start chain=going below,node distance=7mm] \\foreach \\i in {1,2,...,6} \\node[on chain] (l\\i) [label=left: $l_\\i$] {} ; \\end {scope} \\begin {scope} [xshift=4cm,yshift=-0.5cm,start chain=going below,node distance=7mm] \\foreach \\i in {1,2,...,5} \\node[on chain] (r\\i) [label=right: $r_\\i$] {} ; \\end {scope} { % f or (ln, rn) in edges %} \\draw (l{{ln}}) -- (r{{rn}}); { % e ndfor %} \\end {tikzpicture} \\end {center} Which of the following options are valid masks of the above graph? Choose all correct answers. ''' def gen_bigraph ( self , rng ): # We're just going to shuffle the vertices on a fixed bi-graph l_verts , r_verts = ( 6 , 5 ) edges = [( 1 , 2 ), ( 1 , 4 ), ( 2 , 1 ), ( 2 , 3 ), ( 3 , 5 ), ( 4 , 2 ), ( 4 , 4 ), ( 5 , 3 ), ( 6 , 3 ), ( 6 , 4 ), ( 6 , 5 )] masks = [( 'l' , 6 , 2 , 1 ),( 'l' , 2 , 4 , 6 ),( 'l' , 1 , 4 , 3 ),( 'r' , 2 , 3 , 5 ),( 'r' , 4 , 3 , 5 )] non_masks = [( 'l' , 5 , 4 , 2 ), ( 'l' , 5 , 6 , 2 ),( 'r' , 1 , 4 , 5 )] permute_l = { k + 1 : v for ( k , v ) in enumerate ( rng . sample ( range ( 1 , l_verts + 1 ), l_verts ))} permute_r = { k + 1 : v for ( k , v ) in enumerate ( rng . sample ( range ( 1 , r_verts + 1 ), r_verts ))} def permute_mask ( side , a , b , c ): permute = permute_l if side == 'l' else permute_r verts = sorted ([ permute [ v ] for v in [ a , b , c ]]) return ( side , verts [ 0 ], verts [ 1 ], verts [ 2 ]) return { 'edges' : [( permute_l [ l ], permute_r [ r ]) for ( l , r ) in edges ] , 'masks' : [ permute_mask ( * m ) for m in masks ] , 'non_masks' : [ permute_mask ( * m ) for m in non_masks ] } def user_setup ( self , rng , ctxt ): graph_data = self . gen_bigraph ( rng ) masks = rng . sample ( graph_data [ 'masks' ], 3 ) non_masks = rng . sample ( graph_data [ 'non_masks' ], 2 ) return { 'edges' : graph_data [ 'edges' ], # Concat correct and incorrect answers, so correct ones are in # indices [0,1,2] and incorrect ones are in [3,4] 'potential_masks' : masks + non_masks , } choice . total_number = 5 choice . text = r ''' ${ % f or i in [1,2,3] -%} {{potential_masks[index][0]}}_{{potential_masks[index][i]}} { %- i f not loop.last -%}, { % e ndif -%} { %- e ndfor %}$ ''' for i in [ 0 , 1 , 2 ]: choice [ i ] . is_correct = True","title":"Specifying Choices"},{"location":"tutorial/multiple_choice/simple_question.html#final-testing","text":"We can then generate the new solution key with the following commands: We're using acelderon instead of erios this time, in order to make the shuffling of the choices more evident. $ ./exam.py cleanup $ ./exam.py build-solution:fake-class:acalderon TODO: image in assets/","title":"Final Testing"},{"location":"user_guide/exams.html","text":"Exams / Assignments \u00b6 The exam or assignment is the root of any project that uses exam_gen . It serves a number of purposes: Point to stored information about class rosters and students who will take the exam. Point to questions that will be included as part of the exam. Determine how to render the exam as a single document. Act as a command line executable for building and interacting with the exam. 1 todo explanation of intro pointer to u_g on user setup pointer to u_g on classes pointer to u_g on questions pointer to u_g on build Options taken from API","title":"Exams/Assignments"},{"location":"user_guide/exams.html#exams-assignments","text":"The exam or assignment is the root of any project that uses exam_gen . It serves a number of purposes: Point to stored information about class rosters and students who will take the exam. Point to questions that will be included as part of the exam. Determine how to render the exam as a single document. Act as a command line executable for building and interacting with the exam. 1 todo explanation of intro pointer to u_g on user setup pointer to u_g on classes pointer to u_g on questions pointer to u_g on build Options taken from API","title":"Exams / Assignments"},{"location":"user_guide/project_setup.html","text":"Project Setup and Organization \u00b6 exam_gen projects have two major components: Exams and Classrooms An Exam or assignment is a broad wrapper around the questions, student instructions, grading mechanisms, and other textual elements that define what a student reads and does when they're doing the task. Questions are self-contained sections of the exam that have some text, scoring mechanisms, and/or sub-questions. A Classroom defines a group of students who can interact with the assignment in various ways. It has various sub-components that describe how to import, store, organize, and export information about how each of those students interacted with the exam. A Roster that lists each student in the class. This is the only mandatory component of a classroom as students are needed to generate personalized exams. The Answers component describes how to parse and imported student answers to exam questions for grading and evaluation. Likewise, Scores will import the grades teachers assign to questions that cannot be graded automatically. The Grade module will combine teacher provided scores and auto-grading to generate and export grades for allthe students. In a project each of the highlighted elements above is represented by a python class that acts as a configuration file that can be read and executed to generate various outputs like exam pdfs , grade spreadsheets , and solution keys . Environment Setup \u00b6 The project environment is very simple to set up. The only core dependency is Pipenv: Pipenv : Hides a lot of python packing and automates much of the dependency management process. In addition each output format usually has its own requirements. See below for the output format you're targeting: LaTeX-based PDF Output The only requirement for LaTeX pdf output is TeX Live . TeX Live : Needed to actually build the exams. Installing the full version (usually texlive-full ) is recommended. Ubuntu: sudo apt install texlive-full Other Linux: Check your distro's package manager or see here . Mac: MacTeX or install via homebrew. Windows: Follow the instructions here Directory Setup \u00b6 Create a new directory ( <proj_dir> ) for your exam: $ mkdir <proj_dir> Within <proj_dir> use pipenv to install this library: $ pipenv install <repo_url> <repo_url> is currently https://github.com/rohit507/exam_gen.git but is likely to change. Any git repo containing this library will work. Save this file as exam.py in the project directory. The name can be changed but will require the other commands to be modified accordingly. Full contents of exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/usr/bin/env -S pipenv run python3 from exam_gen import * class MyExam ( LatexDoc , Exam ): classes = {} questions = {} intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) Ensure that exam.py is executable, otherwise replace ./exam.py with pipenv run python3 exam.py in future steps. $ chmod +x exam.py Test the setup with the following, ensure it produces a short help message: $ ./exam.py Next Steps \u00b6 Add classrooms and students using the instructions here . Add questions using the instructions here . Find other options and answers to questions here . fix links above","title":"Project Setup and Organization"},{"location":"user_guide/project_setup.html#project-setup-and-organization","text":"exam_gen projects have two major components: Exams and Classrooms An Exam or assignment is a broad wrapper around the questions, student instructions, grading mechanisms, and other textual elements that define what a student reads and does when they're doing the task. Questions are self-contained sections of the exam that have some text, scoring mechanisms, and/or sub-questions. A Classroom defines a group of students who can interact with the assignment in various ways. It has various sub-components that describe how to import, store, organize, and export information about how each of those students interacted with the exam. A Roster that lists each student in the class. This is the only mandatory component of a classroom as students are needed to generate personalized exams. The Answers component describes how to parse and imported student answers to exam questions for grading and evaluation. Likewise, Scores will import the grades teachers assign to questions that cannot be graded automatically. The Grade module will combine teacher provided scores and auto-grading to generate and export grades for allthe students. In a project each of the highlighted elements above is represented by a python class that acts as a configuration file that can be read and executed to generate various outputs like exam pdfs , grade spreadsheets , and solution keys .","title":"Project Setup and Organization"},{"location":"user_guide/project_setup.html#environment-setup","text":"The project environment is very simple to set up. The only core dependency is Pipenv: Pipenv : Hides a lot of python packing and automates much of the dependency management process. In addition each output format usually has its own requirements. See below for the output format you're targeting: LaTeX-based PDF Output The only requirement for LaTeX pdf output is TeX Live . TeX Live : Needed to actually build the exams. Installing the full version (usually texlive-full ) is recommended. Ubuntu: sudo apt install texlive-full Other Linux: Check your distro's package manager or see here . Mac: MacTeX or install via homebrew. Windows: Follow the instructions here","title":"Environment Setup"},{"location":"user_guide/project_setup.html#directory-setup","text":"Create a new directory ( <proj_dir> ) for your exam: $ mkdir <proj_dir> Within <proj_dir> use pipenv to install this library: $ pipenv install <repo_url> <repo_url> is currently https://github.com/rohit507/exam_gen.git but is likely to change. Any git repo containing this library will work. Save this file as exam.py in the project directory. The name can be changed but will require the other commands to be modified accordingly. Full contents of exam.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #!/usr/bin/env -S pipenv run python3 from exam_gen import * class MyExam ( LatexDoc , Exam ): classes = {} questions = {} intro . text = r ''' \\emph{Example Exam Introduction} ''' def user_setup ( self , ** kwargs ): pass if __name__ == \"__main__\" : run_cli ( globals ()) Ensure that exam.py is executable, otherwise replace ./exam.py with pipenv run python3 exam.py in future steps. $ chmod +x exam.py Test the setup with the following, ensure it produces a short help message: $ ./exam.py","title":"Directory Setup"},{"location":"user_guide/project_setup.html#next-steps","text":"Add classrooms and students using the instructions here . Add questions using the instructions here . Find other options and answers to questions here . fix links above","title":"Next Steps"}]}; var __search = { index: Promise.resolve(local_index) }