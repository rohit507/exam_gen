from pprint import *
import exam_gen.util.logging as logging
import attr
import attr.validators as valid
from exam_gen.util.attrs_wrapper import attrs

log = logging.new(__name__)

class PrepareAttrs(type):
    """
    Classes using this metaclass can define a `__prepare_attrs__` class method to
    manipulate the attributes available during the definition of any *child*
    classes.
    """

    @classmethod
    def __prepare_attrs__(cls, name,bases, attrs):
        """
        Define this function in classes using this metaclass to manipulate the
        attributes available in subclass definitions.

        ???+ Important
            Any function defining `__prepare_attrs__` should make sure it's
            idempotent in the `attrs` dictionary. Equivalently, the
            following should work for all possible `name`,`bases`,and `attrs`:

            ``` python
              prep_attrs = lambda a : YourClass.__prepare_attrs__(name,bases,a)

              assert(prep_attrs(attrs) == prep_attrs(prep_attrs(attrs)))
            ```

        Args:
           name (str): The name of the class being created
           bases (list): list of classes this class is derived from
           attrs (dict): The attributes defined by previous classes in the mro

        Returns:
           dict: The edited `attrs` dictionary that will be available to child
           classes as they're defined. The simplest possible version will just
           return the argument directly.
        """
        return attrs

    @classmethod
    def __prepare__(metaclass, name, bases):

        attrs = super().__prepare__(name,bases)
        mro = PrepareAttrs.get_future_mro(name, bases)

        for cls in reversed(mro):

            prep_hook = getattr(cls,'__prepare_attrs__', None)
            if prep_hook is not None:
                attrs = prep_hook(name,bases,attrs)

        return attrs

    # Code below from : https://stackoverflow.com/a/52427184
    # Meant to replicate the mro calculation process in python without
    # The sort of side effects that just using type(name,bases,{}).__mro__
    # would produce.

    stub_cache = {object: object}

    @classmethod
    def get_stub_class(self, cls):
        """
        Creates/retrieves a class object that is a side effect free version
        of another class.

        Args:
          cls (class): An external class

        Returns:
          class: An 'empty' stub with an identical mro to the parent class.
              This is cached and so will return the same stub class each time
              it's called on another class.
        """
        if cls is object:
            return object
        stub_bases = []
        for base in cls.__bases__:
            stub_bases.append(self.get_stub_class(base))
        if cls not in self.stub_cache:
            self.stub_cache[cls] = type(cls.__name__, tuple(stub_bases), {})
        return self.stub_cache[cls]

    @classmethod
    def get_future_mro(self, name, bases):
        """
        Method to get the mro of a potential new class without triggering a
        number of class initialization and metaclass side-effects. Results are
        cached internal to the `PrepareAttrs` class object.

        Args:
           name (str): The name of the class you're getting an mro for
           bases (tuple): A tuple of all the classes that the new one
              will directly inherit from.

        Returns:
           list: The mro that a hypothetical class with the given
              bases would have.
        """
        stub_bases = tuple(self.get_stub_class(base) for base in bases)
        stub_cls = type(name, stub_bases, {})
        reversed_cache = {value:key for key, value in self.stub_cache.items()}
        return [reversed_cache[mro_base] for mro_base in  stub_cls.__mro__[1:]]

@attr.s(kw_only=True)
class PrepareAttrDecorator():
    """
    Can be used to create superclasses that define a new attribute that's
    available at class definition for anything that inherits from them.

    Instances of this class have a `decorate()` function that can be used as
    a class transformer. In general you'll want to initialize this in a
    separate function and return the `decorate()` method to create your class
    decorator.

    This will generally define a new class that subclasses whatever it's
    decorating.

    ??? Info "The Full Decoration Process"

         1. `prep`: defining and creating the `__prepare_attrs__` function,
            which is run before a class's definition is evaluated and controls
            what's in the environment during class definition.

            1. `new_inst`: Create a new instance of your attr for this specific
               class.

            1. `env_update`: If your attribute already exists in the environment
               generated by a superclass's `__prepare_attrs__`, then update your
               the new instance with that information.

            1. `sc_update`: If the fully initialized superclass has your
               attribute, then update this class's instance with that info.

            1. Add the final version of the attr to the environment that
               `__prepare_attrs__` produces.

         1. `scinit`: defining and creating the `__init_subclass__` function,
            which is run just after the class is defined and helps create the
            final version of the class.

            1. `mk_secret_inst`: Create the instance of the class that'll be
               stored in a "secret" attribute for restoration when we're
               initializing a new instance.

            1. `attr_docstring`: Generate the docstring for the attribute we're
               initializing.

            1. `prop_cls_name`: Generate a name for the `#!py property()`
               subclass we'll use to make the `attr_docstring` visible to
               documentation tools.

            1. `prop_tweak_dir`: Tweak the directory of the new property we're
               going to create. Useful for making sure that `__setattr__`,
               `__getattr__`, and other dunders are accessible.

            1. Create a new pseudo-property that holds the docstring and attach
               it to our new attribute.

            1. `tweak_cls`: Potentially further tweak our subclass.

         1. `new`: defining and creating the `__new__` function.

            1. `mk_inst`: Create the instance that will populate our new
               attribute at runtime, usually by creating a clone or copy of
               what's in the "secret" class attribute.

            1. Assign the newly created instance to the original attr name.

         1. `init`: defining and creating the `__init__` function.

            1. `tweak_fun`: Manipulate the default `__init__` function somehow,
               this allows for arbitrary wrapping or complete replacement.

         1. `final`: tweaking and finalizing the final output class.

            1. `tweak_ns`: Tweak the namespace that will be used to initialize
               the newly created class. This is run after adding the various
               important dunders to the namespace so can manipulate them
               directly.

            1. `tweak_cls`: Tweak the class after it has been created if
               needed.

    Attributes:

       attr_name (str): The name of the attribute to be created.

       secret_attr_name (str): The name of the secret attribute which is
          used to store the intended attribute value while documentation is
          generated. (defaults to `#!py "__{}".format(attr_name)`)

       prep_attr_inst (callable): See `AttrDecorData` for
          details.

       prep_env_update (callable): See `AttrDecorData` for
          details.

       prep_sc_update (callable): See `AttrDecorData` for details.

       scinit_mk_secret_inst (callable): See `AttrDecorData` for details.

       scinit_attr_docstring (callable): See `AttrDecorData` for details.

       scinit_prop_cls_name (callable): See `AttrDecorData` for details.

       scinit_prop_tweak_dir (callable): See `AttrDecorData` for details.

       scinit_tweak_cls (callable): See `AttrDecorData` for details.

    """


    attr_name = attr.ib(
        validator=valid.instance_of(str)
    )

    secret_attr_name = attr.ib(
        validator=valid.instance_of(str)
    )

    @secret_attr_name.default
    def secret_attr_name_default(self):
        return "__{}".format(self.attr_name)

    prep_attr_inst = attr.ib(
        validator=valid.is_callable()
    )

    prep_env_update = attr.ib()

    prep_sc_update = attr.ib()

    scinit_mk_secret_inst = attr.ib()

    scinit_attr_docstring = attr.ib()

    scinit_prop_cls_name = attr.ib()

    scinit_prop_tweak_dir = attr.ib()

    scinit_tweak_cls = attr.ib()

    new_mk_inst = attr.ib()

    init_tweak_fun = attr.ib()

    final_tweak_ns = attr.ib()

    final_tweak_cls = attr.ib()

class AttrDecorData():
    """
    This class mostly exists to provide nicely formatted docs for
    `PrepareAttrDecorator` and its attributes.
    """

    @staticmethod
    def prep_attr_inst(prep_meta, prep_attr_decorator):
        """
        Todo.

        Parameters:

           meta (Meta): Metadata associated with this phase of decoration.
              Look at the corresponding class docs for details and available
              attributes.

           prep_attr_decorator (PrepAttrDecorator): The decorator instance
              which is currently using this function. Has useful attributes
              like `attr_name` and `secret_attr_name`

        Returns:

           type: Write details of expected return values

        """
        pass

    @staticmethod
    def prep_env_update(class_inst, env_inst, prep_meta, prep_attr_decorator):
        """
        Todo.

        Parameters:

           meta (Meta): Metadata associated with this phase of decoration.
              Look at the corresponding class docs for details and available
              attributes.

           prep_attr_decorator (PrepAttrDecorator): The decorator instance
              which is currently using this function. Has useful attributes
              like `attr_name` and `secret_attr_name`

        Returns:

           type: Write details of expected return values

        """
        pass

    @staticmethod
    def prep_sc_update(class_inst, sc_inst, prep_meta, prep_attr_decorator):
        """
        Todo.

        Parameters:

           meta (Meta): Metadata associated with this phase of decoration.
              Look at the corresponding class docs for details and available
              attributes.

           prep_attr_decorator (PrepAttrDecorator): The decorator instance
              which is currently using this function. Has useful attributes
              like `attr_name` and `secret_attr_name`

        Returns:

           type: Write details of expected return values

        """
        pass

    @staticmethod
    def scinit_mk_secret_inst(class_inst, scinit_meta, prep_attr_decorator):
        """
        Todo.

        Parameters:

           meta (Meta): Metadata associated with this phase of decoration.
              Look at the corresponding class docs for details and available
              attributes.

           prep_attr_decorator (PrepAttrDecorator): The decorator instance
              which is currently using this function. Has useful attributes
              like `attr_name` and `secret_attr_name`

        Returns:

           type: Write details of expected return values

        """
        pass

    @staticmethod
    def scinit_prop_cls_name(scinit_meta, prep_attr_decorator):
        """
        Todo.

        Parameters:

           meta (Meta): Metadata associated with this phase of decoration.
              Look at the corresponding class docs for details and available
              attributes.

           prep_attr_decorator (PrepAttrDecorator): The decorator instance
              which is currently using this function. Has useful attributes
              like `attr_name` and `secret_attr_name`

        Returns:

           type: Write details of expected return values

        """
        pass

    @staticmethod
    def scinit_prop_tweak_dir(namespace,
                              secret_inst,
                              scinit_meta,
                              prep_attr_decorator):
        """
        Todo.

        Parameters:

           meta (Meta): Metadata associated with this phase of decoration.
              Look at the corresponding class docs for details and available
              attributes.

           prep_attr_decorator (PrepAttrDecorator): The decorator instance
              which is currently using this function. Has useful attributes
              like `attr_name` and `secret_attr_name`

        Returns:

           type: Write details of expected return values

        """
        pass

    @staticmethod
    def scinit_tweak_cls(cls,
                         secret_inst,
                         scinit_meta,
                         prep_attr_decorator):
        """
        Todo.

        Parameters:

           meta (Meta): Metadata associated with this phase of decoration.
              Look at the corresponding class docs for details and available
              attributes.

           prep_attr_decorator (PrepAttrDecorator): The decorator instance
              which is currently using this function. Has useful attributes
              like `attr_name` and `secret_attr_name`

        Returns:

           type: Write details of expected return values

        """
        pass

    @staticmethod
    def new_mk_inst(secret_inst, new_meta, prep_attr_decorator):
        """
        Todo.

        Parameters:

           meta (Meta): Metadata associated with this phase of decoration.
              Look at the corresponding class docs for details and available
              attributes.

           prep_attr_decorator (PrepAttrDecorator): The decorator instance
              which is currently using this function. Has useful attributes
              like `attr_name` and `secret_attr_name`

        Returns:

           type: Write details of expected return values

        """
        pass

    @staticmethod
    def init_tweak_fun(init_fun, init_meta, prep_attr_decorator):
        """
        Todo.

        Parameters:

           meta (Meta): Metadata associated with this phase of decoration.
              Look at the corresponding class docs for details and available
              attributes.

           prep_attr_decorator (PrepAttrDecorator): The decorator instance
              which is currently using this function. Has useful attributes
              like `attr_name` and `secret_attr_name`

        Returns:

           type: Write details of expected return values

        """
        pass

    @staticmethod
    def final_tweak_ns(namespace, final_meta, prep_attr_decorator):
        """
        Todo.

        Parameters:

           meta (Meta): Metadata associated with this phase of decoration.
              Look at the corresponding class docs for details and available
              attributes.

           prep_attr_decorator (PrepAttrDecorator): The decorator instance
              which is currently using this function. Has useful attributes
              like `attr_name` and `secret_attr_name`

        Returns:

           type: Write details of expected return values

        """
        pass

    @staticmethod
    def final_tweak_cls(final_cls, final_meta, prep_attr_decorator):
        """
        Todo.

        Parameters:

           meta (Meta): Metadata associated with this phase of decoration.
              Look at the corresponding class docs for details and available
              attributes.

           prep_attr_decorator (PrepAttrDecorator): The decorator instance
              which is currently using this function. Has useful attributes
              like `attr_name` and `secret_attr_name`

        Returns:

           type: Write details of expected return values

        """
        pass

@attr.s
class ScInitMeta():
    cls = attr.ib()
    result_class = attr.ib()

@attr.s
class PrepMeta():
    cls = attr.ib()
    name = attr.ib()
    bases = attr.ib()
    env = attr.ib()
